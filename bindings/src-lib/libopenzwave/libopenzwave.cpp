/* Generated by Cython 0.25.2 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03020000)
    #error Cython requires Python 2.6+ or Python 3.2+.
#else
#define CYTHON_ABI "0_25_2"
#include <stddef.h>
#ifndef offsetof
  #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#ifndef HAVE_LONG_LONG
  #if PY_VERSION_HEX >= 0x03030000 || (PY_MAJOR_VERSION == 2 && PY_VERSION_HEX >= 0x02070000)
    #define HAVE_LONG_LONG
  #endif
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
  #define CYTHON_COMPILING_IN_PYPY 1
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #undef CYTHON_USE_TYPE_SLOTS
  #define CYTHON_USE_TYPE_SLOTS 0
  #undef CYTHON_USE_ASYNC_SLOTS
  #define CYTHON_USE_ASYNC_SLOTS 0
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #undef CYTHON_USE_UNICODE_INTERNALS
  #define CYTHON_USE_UNICODE_INTERNALS 0
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #undef CYTHON_AVOID_BORROWED_REFS
  #define CYTHON_AVOID_BORROWED_REFS 1
  #undef CYTHON_ASSUME_SAFE_MACROS
  #define CYTHON_ASSUME_SAFE_MACROS 0
  #undef CYTHON_UNPACK_METHODS
  #define CYTHON_UNPACK_METHODS 0
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
#elif defined(PYSTON_VERSION)
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 1
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #undef CYTHON_USE_ASYNC_SLOTS
  #define CYTHON_USE_ASYNC_SLOTS 0
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
#else
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 1
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #if PY_MAJOR_VERSION < 3
    #undef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 0
  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYLONG_INTERNALS
    #define CYTHON_USE_PYLONG_INTERNALS 0
  #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
    #define CYTHON_USE_PYLONG_INTERNALS 1
  #endif
  #ifndef CYTHON_USE_PYLIST_INTERNALS
    #define CYTHON_USE_PYLIST_INTERNALS 1
  #endif
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #if PY_VERSION_HEX < 0x030300F0
    #undef CYTHON_USE_UNICODE_WRITER
    #define CYTHON_USE_UNICODE_WRITER 0
  #elif !defined(CYTHON_USE_UNICODE_WRITER)
    #define CYTHON_USE_UNICODE_WRITER 1
  #endif
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #ifndef CYTHON_FAST_THREAD_STATE
    #define CYTHON_FAST_THREAD_STATE 1
  #endif
  #ifndef CYTHON_FAST_PYCALL
    #define CYTHON_FAST_PYCALL 1
  #endif
#endif
#if !defined(CYTHON_FAST_PYCCALL)
#define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
#endif
#if CYTHON_USE_PYLONG_INTERNALS
  #include "longintrepr.h"
  #undef SHIFT
  #undef BASE
  #undef MASK
#endif
#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
  #define Py_OptimizeFlag 0
#endif
#define __PYX_BUILD_PY_SSIZE_T "n"
#define CYTHON_FORMAT_SSIZE_T "z"
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyType_Type
#endif
#ifndef Py_TPFLAGS_CHECKTYPES
  #define Py_TPFLAGS_CHECKTYPES 0
#endif
#ifndef Py_TPFLAGS_HAVE_INDEX
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#ifndef Py_TPFLAGS_HAVE_NEWBUFFER
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#ifndef Py_TPFLAGS_HAVE_FINALIZE
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#ifndef METH_FASTCALL
  #define METH_FASTCALL 0x80
  typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject **args,
                                              Py_ssize_t nargs, PyObject *kwnames);
#else
  #define __Pyx_PyCFunctionFast _PyCFunctionFast
#endif
#if CYTHON_FAST_PYCCALL
#define __Pyx_PyFastCFunction_Check(func)\
    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST)))))
#else
#define __Pyx_PyFastCFunction_Check(func) 0
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
#else
  #define CYTHON_PEP393_ENABLED 0
  #define PyUnicode_1BYTE_KIND  1
  #define PyUnicode_2BYTE_KIND  2
  #define PyUnicode_4BYTE_KIND  4
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535 : 1114111)
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = ch)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
  #define PyObject_Malloc(s)   PyMem_Malloc(s)
  #define PyObject_Free(p)     PyMem_Free(p)
  #define PyObject_Realloc(p)  PyMem_Realloc(p)
#endif
#if CYTHON_COMPILING_IN_PYSTON
  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
#else
  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
#endif
#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION < 3 && !defined(PyObject_ASCII)
  #define PyObject_ASCII(o)            PyObject_Repr(o)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
  #ifndef PyUnicode_InternFromString
    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
  #endif
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
#else
  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
#endif
#if CYTHON_USE_ASYNC_SLOTS
  #if PY_VERSION_HEX >= 0x030500B1
    #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
    #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
  #else
    typedef struct {
        unaryfunc am_await;
        unaryfunc am_aiter;
        unaryfunc am_anext;
    } __Pyx_PyAsyncMethodsStruct;
    #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
  #endif
#else
  #define __Pyx_PyType_AsAsync(obj) NULL
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
#ifndef CYTHON_MAYBE_UNUSED_VAR
#  if defined(__cplusplus)
     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
#  else
#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
#  endif
#endif
#ifndef CYTHON_NCP_UNUSED
# if CYTHON_COMPILING_IN_CPYTHON
#  define CYTHON_NCP_UNUSED
# else
#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
# endif
#endif
#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)

#ifndef __cplusplus
  #error "Cython files generated with the C++ option must be compiled with a C++ compiler."
#endif
#ifndef CYTHON_INLINE
  #if defined(__clang__)
    #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
  #else
    #define CYTHON_INLINE inline
  #endif
#endif
template<typename T>
void __Pyx_call_destructor(T& x) {
    x.~T();
}
template<typename T>
class __Pyx_FakeReference {
  public:
    __Pyx_FakeReference() : ptr(NULL) { }
    __Pyx_FakeReference(const T& ref) : ptr(const_cast<T*>(&ref)) { }
    T *operator->() { return ptr; }
    T *operator&() { return ptr; }
    operator T&() { return *ptr; }
    template<typename U> bool operator ==(U other) { return *ptr == other; }
    template<typename U> bool operator !=(U other) { return *ptr != other; }
  private:
    T *ptr;
};

#if defined(WIN32) || defined(MS_WINDOWS)
  #define _USE_MATH_DEFINES
#endif
#include <math.h>
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif
#if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
#define __Pyx_truncl trunc
#else
#define __Pyx_truncl truncl
#endif


#define __PYX_ERR(f_index, lineno, Ln_error) \
{ \
  __pyx_filename = __pyx_f[f_index]; __pyx_lineno = lineno; __pyx_clineno = __LINE__; goto Ln_error; \
}

#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#define __PYX_HAVE__libopenzwave
#define __PYX_HAVE_API__libopenzwave
#include <utility>
#include "ios"
#include "new"
#include "stdexcept"
#include "typeinfo"
#include <map>
#include <vector>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <string>
#include "Group.h"
#include "Node.h"
#include "Driver.h"
#include "ValueID.h"
#include "Notification.h"
#include "Options.h"
#include "Log.h"
#include "Manager.h"
#include "pyversion.h"
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#ifdef PYREX_WITHOUT_ASSERTIONS
#define CYTHON_WITHOUT_ASSERTIONS
#endif

typedef struct {PyObject **p; const char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
#define __PYX_DEFAULT_STRING_ENCODING "utf8"
#define __Pyx_PyObject_FromString __Pyx_PyUnicode_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#define __Pyx_uchar_cast(c) ((unsigned char)c)
#define __Pyx_long_cast(x) ((long)x)
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (\
    (sizeof(type) < sizeof(Py_ssize_t))  ||\
    (sizeof(type) > sizeof(Py_ssize_t) &&\
          likely(v < (type)PY_SSIZE_T_MAX ||\
                 v == (type)PY_SSIZE_T_MAX)  &&\
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||\
                                v == (type)PY_SSIZE_T_MIN)))  ||\
    (sizeof(type) == sizeof(Py_ssize_t) &&\
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||\
                               v == (type)PY_SSIZE_T_MAX)))  )
#if defined (__cplusplus) && __cplusplus >= 201103L
    #include <cstdlib>
    #define __Pyx_sst_abs(value) std::abs(value)
#elif SIZEOF_INT >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) abs(value)
#elif SIZEOF_LONG >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) labs(value)
#elif defined (_MSC_VER) && defined (_M_X64)
    #define __Pyx_sst_abs(value) _abs64(value)
#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define __Pyx_sst_abs(value) llabs(value)
#elif defined (__GNUC__)
    #define __Pyx_sst_abs(value) __builtin_llabs(value)
#else
    #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
#endif
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyObject_AsSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
#define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
#define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
#define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
#define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
#if PY_MAJOR_VERSION < 3
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
{
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return (size_t)(u_end - u - 1);
}
#else
#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
#endif
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
#define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
#define __Pyx_PyBool_FromLong(b) ((b) ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False))
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
#if CYTHON_ASSUME_SAFE_MACROS
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
#else
#define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
#endif
#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    const char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    if (strcmp(default_encoding_c, "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (!ascii_chars_u) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
        Py_DECREF(ascii_chars_u);
        Py_DECREF(ascii_chars_b);
    }
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


/* Test for GCC > 2.95 */
#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
  #define likely(x)   __builtin_expect(!!(x), 1)
  #define unlikely(x) __builtin_expect(!!(x), 0)
#else /* !__GNUC__ or GCC < 2.95 */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */

static PyObject *__pyx_m;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static PyObject *__pyx_empty_unicode;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "src-lib/libopenzwave/libopenzwave.pyx",
  "stringsource",
};

/*--- Type declarations ---*/
struct __pyx_obj_12libopenzwave_PyOptions;
struct __pyx_obj_12libopenzwave_RetAlloc;
struct __pyx_obj_12libopenzwave_InstanceAssociationAlloc;
struct __pyx_obj_12libopenzwave_PyManager;

/* "group.pxd":28
 *         uint8_t m_instance
 * 
 * ctypedef InstanceAssociation InstanceAssociation_t             # <<<<<<<<<<<<<<
 * 
 */
typedef OpenZWave::InstanceAssociation __pyx_t_5group_InstanceAssociation_t;

/* "node.pxd":59
 *         vector[CommandClassData] m_ccData     # List of statistic on each command_class
 * 
 * ctypedef NodeData NodeData_t             # <<<<<<<<<<<<<<
 * 
 */
typedef struct OpenZWave::Node::NodeData __pyx_t_4node_NodeData_t;

/* "driver.pxd":102
 *         ControllerError_Overflow = 12                     # RequestNetworkUpdate error *[inserted by cython to avoid comment closer]/
 * 
 * ctypedef DriverData DriverData_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef void (*pfnControllerCallback_t)( ControllerState _state, ControllerError _error, void* _context )
 */
typedef struct OpenZWave::Driver::DriverData __pyx_t_6driver_DriverData_t;

/* "driver.pxd":104
 * ctypedef DriverData DriverData_t
 * 
 * ctypedef void (*pfnControllerCallback_t)( ControllerState _state, ControllerError _error, void* _context )             # <<<<<<<<<<<<<<
 */
typedef void (*__pyx_t_6driver_pfnControllerCallback_t)(enum OpenZWave::Driver::ControllerState, enum OpenZWave::Driver::ControllerError, void *);

/* "notification.pxd":30
 *     ctypedef char* const_notification "OpenZWave::Notification const*"
 * 
 * ctypedef void (*pfnOnNotification_t)(const_notification _pNotification, void* _context )             # <<<<<<<<<<<<<<
 * 
 * cdef extern from "Notification.h" namespace "OpenZWave::Notification":
 */
typedef void (*__pyx_t_12notification_pfnOnNotification_t)(OpenZWave::Notification const*, void *);

/* "manager.pxd":37
 * import os
 * 
 * ctypedef uint8_t** int_associations             # <<<<<<<<<<<<<<
 * ctypedef InstanceAssociation_t** struct_associations
 * 
 */
typedef uint8_t **__pyx_t_7manager_int_associations;

/* "manager.pxd":38
 * 
 * ctypedef uint8_t** int_associations
 * ctypedef InstanceAssociation_t** struct_associations             # <<<<<<<<<<<<<<
 * 
 * cdef extern from "Manager.h" namespace "OpenZWave":
 */
typedef __pyx_t_5group_InstanceAssociation_t **__pyx_t_7manager_struct_associations;

/* "libopenzwave.pyx":644
 *     return None
 * 
 * cdef class PyOptions:             # <<<<<<<<<<<<<<
 *     """
 *     Manage options manager
 */
struct __pyx_obj_12libopenzwave_PyOptions {
  PyObject_HEAD
  PyObject *_config_path;
  PyObject *_user_path;
  PyObject *_cmd_line;
  OpenZWave::Options *options;
};


/* "libopenzwave.pyx":943
 * 
 * 
 * cdef class RetAlloc:             # <<<<<<<<<<<<<<
 *     """
 *     Map an array of uint8_t used when retrieving sets.
 */
struct __pyx_obj_12libopenzwave_RetAlloc {
  PyObject_HEAD
  uint32_t siz;
  uint8_t *data;
};


/* "libopenzwave.pyx":960
 *         free(self.data)
 * 
 * cdef class InstanceAssociationAlloc:             # <<<<<<<<<<<<<<
 *     """
 *     Map an array of InstanceAssociation_t used when retrieving sets of associationInstances.
 */
struct __pyx_obj_12libopenzwave_InstanceAssociationAlloc {
  PyObject_HEAD
  uint32_t siz;
  uint8_t *data;
};


/* "libopenzwave.pyx":977
 *         free(self.data)
 * 
 * cdef class PyManager:             # <<<<<<<<<<<<<<
 *     '''
 * The main public interface to OpenZWave.
 */
struct __pyx_obj_12libopenzwave_PyManager {
  PyObject_HEAD
  OpenZWave::Manager *manager;
  PyObject *_watcherCallback;
  PyObject *_controllerCallback;
};


/* --- Runtime support code (head) --- */
/* Refnanny.proto */
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          if (acquire_gil) {\
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
              PyGILState_Release(__pyx_gilstate_save);\
          } else {\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext()\
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif
#define __Pyx_XDECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_XDECREF(tmp);\
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_DECREF(tmp);\
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

/* PyObjectGetAttrStr.proto */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

/* GetBuiltinName.proto */
static PyObject *__Pyx_GetBuiltinName(PyObject *name);

/* RaiseArgTupleInvalid.proto */
static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);

/* RaiseDoubleKeywords.proto */
static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);

/* ParseKeywords.proto */
static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
    const char* function_name);

/* PyObjectCall.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

/* PyThreadStateGet.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
#define __Pyx_PyThreadState_assign  __pyx_tstate = PyThreadState_GET();
#else
#define __Pyx_PyThreadState_declare
#define __Pyx_PyThreadState_assign
#endif

/* PyErrFetchRestore.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
#endif

/* WriteUnraisableException.proto */
static void __Pyx_WriteUnraisable(const char *name, int clineno,
                                  int lineno, const char *filename,
                                  int full_traceback, int nogil);

/* GetModuleGlobalName.proto */
static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name);

/* SaveResetException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
#else
#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
#endif

/* GetException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
#endif

/* PyCFunctionFastCall.proto */
#if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
#else
#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
#endif

/* PyFunctionFastCall.proto */
#if CYTHON_FAST_PYCALL
#define __Pyx_PyFunction_FastCall(func, args, nargs)\
    __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, int nargs, PyObject *kwargs);
#else
#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
#endif
#endif

/* PyObjectCallMethO.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
#endif

/* PyObjectCallOneArg.proto */
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);

/* PyObjectSetAttrStr.proto */
#if CYTHON_USE_TYPE_SLOTS
#define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o,n,NULL)
static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_setattro))
        return tp->tp_setattro(obj, attr_name, value);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_setattr))
        return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
#endif
    return PyObject_SetAttr(obj, attr_name, value);
}
#else
#define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
#define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
#endif

/* IncludeStringH.proto */
#include <string.h>

/* BytesEquals.proto */
static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);

/* UnicodeEquals.proto */
static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);

/* StrEquals.proto */
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyString_Equals __Pyx_PyUnicode_Equals
#else
#define __Pyx_PyString_Equals __Pyx_PyBytes_Equals
#endif

/* GetItemInt.proto */
#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                     int is_list, int wraparound, int boundscheck);

/* ForceInitThreads.proto */
#ifndef __PYX_FORCE_INIT_THREADS
  #define __PYX_FORCE_INIT_THREADS 0
#endif

/* None.proto */
static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname);

/* Import.proto */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);

/* ImportFrom.proto */
static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);

/* PyErrExceptionMatches.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
#else
#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
#endif

/* PyObjectCallNoArg.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
#else
#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
#endif

/* RaiseException.proto */
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);

/* ArgTypeTest.proto */
static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact);

/* PySequenceContains.proto */
static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
    int result = PySequence_Contains(seq, item);
    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
}

/* ListAppend.proto */
#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
#endif

/* PyObjectCallMethod1.proto */
static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg);

/* append.proto */
static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x);

/* DictGetItem.proto */
#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key) {
    PyObject *value;
    value = PyDict_GetItemWithError(d, key);
    if (unlikely(!value)) {
        if (!PyErr_Occurred()) {
            PyObject* args = PyTuple_Pack(1, key);
            if (likely(args))
                PyErr_SetObject(PyExc_KeyError, args);
            Py_XDECREF(args);
        }
        return NULL;
    }
    Py_INCREF(value);
    return value;
}
#else
    #define __Pyx_PyDict_GetItem(d, key) PyObject_GetItem(d, key)
#endif

/* SwapException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_ExceptionSwap(type, value, tb)  __Pyx__ExceptionSwap(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);
#endif

/* UnicodeAsUCS4.proto */
static CYTHON_INLINE Py_UCS4 __Pyx_PyUnicode_AsPy_UCS4(PyObject*);

/* object_ord.proto */
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyObject_Ord(c)\
    (likely(PyUnicode_Check(c)) ? (long)__Pyx_PyUnicode_AsPy_UCS4(c) : __Pyx__PyObject_Ord(c))
#else
#define __Pyx_PyObject_Ord(c) __Pyx__PyObject_Ord(c)
#endif
static long __Pyx__PyObject_Ord(PyObject* c);

/* PyIntBinop.proto */
#if !CYTHON_COMPILING_IN_PYPY
static PyObject* __Pyx_PyInt_EqObjC(PyObject *op1, PyObject *op2, long intval, int inplace);
#else
#define __Pyx_PyInt_EqObjC(op1, op2, intval, inplace)\
    PyObject_RichCompare(op1, op2, Py_EQ)
    #endif

/* ListCompAppend.proto */
#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len)) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
#endif

/* PyIntBinop.proto */
#if !CYTHON_COMPILING_IN_PYPY
static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, long intval, int inplace);
#else
#define __Pyx_PyInt_AddObjC(op1, op2, intval, inplace)\
    (inplace ? PyNumber_InPlaceAdd(op1, op2) : PyNumber_Add(op1, op2))
#endif

/* CalculateMetaclass.proto */
static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases);

/* FetchCommonType.proto */
static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);

/* CythonFunction.proto */
#define __Pyx_CyFunction_USED 1
#include <structmember.h>
#define __Pyx_CYFUNCTION_STATICMETHOD  0x01
#define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
#define __Pyx_CYFUNCTION_CCLASS        0x04
#define __Pyx_CyFunction_GetClosure(f)\
    (((__pyx_CyFunctionObject *) (f))->func_closure)
#define __Pyx_CyFunction_GetClassObj(f)\
    (((__pyx_CyFunctionObject *) (f))->func_classobj)
#define __Pyx_CyFunction_Defaults(type, f)\
    ((type *)(((__pyx_CyFunctionObject *) (f))->defaults))
#define __Pyx_CyFunction_SetDefaultsGetter(f, g)\
    ((__pyx_CyFunctionObject *) (f))->defaults_getter = (g)
typedef struct {
    PyCFunctionObject func;
#if PY_VERSION_HEX < 0x030500A0
    PyObject *func_weakreflist;
#endif
    PyObject *func_dict;
    PyObject *func_name;
    PyObject *func_qualname;
    PyObject *func_doc;
    PyObject *func_globals;
    PyObject *func_code;
    PyObject *func_closure;
    PyObject *func_classobj;
    void *defaults;
    int defaults_pyobjects;
    int flags;
    PyObject *defaults_tuple;
    PyObject *defaults_kwdict;
    PyObject *(*defaults_getter)(PyObject *);
    PyObject *func_annotations;
} __pyx_CyFunctionObject;
static PyTypeObject *__pyx_CyFunctionType = 0;
#define __Pyx_CyFunction_NewEx(ml, flags, qualname, self, module, globals, code)\
    __Pyx_CyFunction_New(__pyx_CyFunctionType, ml, flags, qualname, self, module, globals, code)
static PyObject *__Pyx_CyFunction_New(PyTypeObject *, PyMethodDef *ml,
                                      int flags, PyObject* qualname,
                                      PyObject *self,
                                      PyObject *module, PyObject *globals,
                                      PyObject* code);
static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *m,
                                                         size_t size,
                                                         int pyobjects);
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *m,
                                                            PyObject *tuple);
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *m,
                                                             PyObject *dict);
static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *m,
                                                              PyObject *dict);
static int __pyx_CyFunction_init(void);

/* Py3ClassCreate.proto */
static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name, PyObject *qualname,
                                           PyObject *mkw, PyObject *modname, PyObject *doc);
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases, PyObject *dict,
                                      PyObject *mkw, int calculate_metaclass, int allow_py2_metaclass);

/* CodeObjectCache.proto */
typedef struct {
    PyCodeObject* code_object;
    int code_line;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

/* AddTraceback.proto */
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename);

/* CppExceptionConversion.proto */
#ifndef __Pyx_CppExn2PyErr
#include <new>
#include <typeinfo>
#include <stdexcept>
#include <ios>
static void __Pyx_CppExn2PyErr() {
  try {
    if (PyErr_Occurred())
      ; // let the latest Python exn pass through and ignore the current one
    else
      throw;
  } catch (const std::bad_alloc& exn) {
    PyErr_SetString(PyExc_MemoryError, exn.what());
  } catch (const std::bad_cast& exn) {
    PyErr_SetString(PyExc_TypeError, exn.what());
  } catch (const std::bad_typeid& exn) {
    PyErr_SetString(PyExc_TypeError, exn.what());
  } catch (const std::domain_error& exn) {
    PyErr_SetString(PyExc_ValueError, exn.what());
  } catch (const std::invalid_argument& exn) {
    PyErr_SetString(PyExc_ValueError, exn.what());
  } catch (const std::ios_base::failure& exn) {
    PyErr_SetString(PyExc_IOError, exn.what());
  } catch (const std::out_of_range& exn) {
    PyErr_SetString(PyExc_IndexError, exn.what());
  } catch (const std::overflow_error& exn) {
    PyErr_SetString(PyExc_OverflowError, exn.what());
  } catch (const std::range_error& exn) {
    PyErr_SetString(PyExc_ArithmeticError, exn.what());
  } catch (const std::underflow_error& exn) {
    PyErr_SetString(PyExc_ArithmeticError, exn.what());
  } catch (const std::exception& exn) {
    PyErr_SetString(PyExc_RuntimeError, exn.what());
  }
  catch (...)
  {
    PyErr_SetString(PyExc_RuntimeError, "Unknown exception");
  }
}
#endif

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueType(enum OpenZWave::ValueID::ValueType value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint8_t(uint8_t value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int32_t(int32_t value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int16_t(int16_t value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint64_t(uint64_t value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueGenre(enum OpenZWave::ValueID::ValueGenre value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint32_t(uint32_t value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Notification_3a__3a_NotificationType(enum OpenZWave::Notification::NotificationType value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerState(enum OpenZWave::Driver::ControllerState value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerError(enum OpenZWave::Driver::ControllerError value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerInterface(enum OpenZWave::Driver::ControllerInterface value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint16_t(uint16_t value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int8_t(int8_t value);

/* CIntFromPy.proto */
static CYTHON_INLINE uint32_t __Pyx_PyInt_As_uint32_t(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE uint8_t __Pyx_PyInt_As_uint8_t(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE uint64_t __Pyx_PyInt_As_uint64_t(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE int32_t __Pyx_PyInt_As_int32_t(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE int16_t __Pyx_PyInt_As_int16_t(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE enum OpenZWave::Driver::ControllerCommand __Pyx_PyInt_As_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerCommand(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

/* CheckBinaryVersion.proto */
static int __Pyx_check_binary_version(void);

/* InitStrings.proto */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);


/* Module declarations from 'libcpp.utility' */

/* Module declarations from 'libcpp.map' */

/* Module declarations from 'libcpp' */

/* Module declarations from 'libcpp.vector' */

/* Module declarations from 'libc.stdint' */

/* Module declarations from 'libc.string' */

/* Module declarations from 'libc.stdlib' */

/* Module declarations from 'mylibc' */

/* Module declarations from 'group' */

/* Module declarations from 'node' */

/* Module declarations from 'driver' */

/* Module declarations from 'values' */

/* Module declarations from 'notification' */

/* Module declarations from 'options' */

/* Module declarations from 'log' */

/* Module declarations from 'manager' */

/* Module declarations from 'libopenzwave' */
static PyTypeObject *__pyx_ptype_12libopenzwave_PyOptions = 0;
static PyTypeObject *__pyx_ptype_12libopenzwave_RetAlloc = 0;
static PyTypeObject *__pyx_ptype_12libopenzwave_InstanceAssociationAlloc = 0;
static PyTypeObject *__pyx_ptype_12libopenzwave_PyManager = 0;
static std::map<uint64_t,OpenZWave::ValueID>  __pyx_v_12libopenzwave_values_map;
static std::string __pyx_f_12libopenzwave_str_to_cppstr(PyObject *); /*proto*/
static PyObject *__pyx_f_12libopenzwave_cstr_to_str(PyObject *); /*proto*/
static PyObject *__pyx_f_12libopenzwave_getValueFromType(OpenZWave::Manager *, PyObject *); /*proto*/
static PyObject *__pyx_f_12libopenzwave_delValueId(OpenZWave::ValueID, PyObject *); /*proto*/
static PyObject *__pyx_f_12libopenzwave_addValueId(OpenZWave::ValueID, PyObject *); /*proto*/
static void __pyx_f_12libopenzwave_notif_callback(OpenZWave::Notification const*, void *); /*proto*/
static void __pyx_f_12libopenzwave_ctrl_callback(enum OpenZWave::Driver::ControllerState, enum OpenZWave::Driver::ControllerError, void *); /*proto*/
static PyObject *__pyx_f_12libopenzwave_driverData(int __pyx_skip_dispatch); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &); /*proto*/
#define __Pyx_MODULE_NAME "libopenzwave"
int __pyx_module_is_main_libopenzwave = 0;

/* Implementation of 'libopenzwave' */
static PyObject *__pyx_builtin_ImportError;
static PyObject *__pyx_builtin_AttributeError;
static PyObject *__pyx_builtin_range;
static PyObject *__pyx_builtin_chr;
static PyObject *__pyx_builtin_ValueError;
static const char __pyx_k_a[] = "a";
static const char __pyx_k_b[] = "b";
static const char __pyx_k_c[] = "c";
static const char __pyx_k__5[] = " : ";
static const char __pyx_k__6[] = "";
static const char __pyx_k_id[] = "id";
static const char __pyx_k_os[] = "os";
static const char __pyx_k_Hid[] = "Hid";
static const char __pyx_k_Int[] = "Int";
static const char __pyx_k_PY3[] = "PY3";
static const char __pyx_k_Raw[] = "Raw";
static const char __pyx_k__29[] = ".";
static const char __pyx_k_arg[] = "arg";
static const char __pyx_k_chr[] = "chr";
static const char __pyx_k_doc[] = "doc";
static const char __pyx_k_idx[] = "idx";
static const char __pyx_k_msg[] = "msg";
static const char __pyx_k_six[] = "six";
static const char __pyx_k_siz[] = "siz";
static const char __pyx_k_str[] = "__str__";
static const char __pyx_k_sys[] = "sys";
static const char __pyx_k_usr[] = "/usr";
static const char __pyx_k_Bool[] = "Bool";
static const char __pyx_k_Busy[] = "Busy";
static const char __pyx_k_Byte[] = "Byte";
static const char __pyx_k_Dead[] = "Dead";
static const char __pyx_k_Info[] = "Info";
static const char __pyx_k_List[] = "List";
static const char __pyx_k_None[] = "None";
static const char __pyx_k_R_OK[] = "R_OK";
static const char __pyx_k_User[] = "User";
static const char __pyx_k_W_OK[] = "W_OK";
static const char __pyx_k_dirn[] = "dirn";
static const char __pyx_k_dist[] = "_dist";
static const char __pyx_k_emit[] = "emit";
static const char __pyx_k_file[] = "__file__";
static const char __pyx_k_help[] = "help";
static const char __pyx_k_init[] = "__init__";
static const char __pyx_k_join[] = "join";
static const char __pyx_k_main[] = "__main__";
static const char __pyx_k_name[] = "name";
static const char __pyx_k_path[] = "path";
static const char __pyx_k_self[] = "self";
static const char __pyx_k_size[] = "size";
static const char __pyx_k_test[] = "__test__";
static const char __pyx_k_type[] = "type";
static const char __pyx_k_unit[] = "unit";
static const char __pyx_k_Alert[] = "Alert";
static const char __pyx_k_Alive[] = "Alive";
static const char __pyx_k_Awake[] = "Awake";
static const char __pyx_k_Basic[] = "Basic";
static const char __pyx_k_Debug[] = "Debug";
static const char __pyx_k_Error[] = "Error";
static const char __pyx_k_Fatal[] = "Fatal";
static const char __pyx_k_Group[] = "Group";
static const char __pyx_k_Probe[] = "Probe";
static const char __pyx_k_Short[] = "Short";
static const char __pyx_k_Sleep[] = "Sleep";
static const char __pyx_k_count[] = "count";
static const char __pyx_k_debug[] = "debug";
static const char __pyx_k_doc_2[] = "__doc__";
static const char __pyx_k_error[] = "error";
static const char __pyx_k_event[] = "event";
static const char __pyx_k_genre[] = "genre";
static const char __pyx_k_hours[] = "hours";
static const char __pyx_k_index[] = "index";
static const char __pyx_k_isdir[] = "isdir";
static const char __pyx_k_label[] = "label";
static const char __pyx_k_level[] = "level";
static const char __pyx_k_noack[] = "noack";
static const char __pyx_k_param[] = "param";
static const char __pyx_k_range[] = "range";
static const char __pyx_k_state[] = "state";
static const char __pyx_k_stype[] = "stype";
static const char __pyx_k_units[] = "units";
static const char __pyx_k_utf_8[] = "utf-8";
static const char __pyx_k_value[] = "value";
static const char __pyx_k_ACKCnt[] = "ACKCnt";
static const char __pyx_k_Always[] = "Always";
static const char __pyx_k_Button[] = "Button";
static const char __pyx_k_CANCnt[] = "CANCnt";
static const char __pyx_k_Cancel[] = "Cancel";
static const char __pyx_k_Config[] = "Config";
static const char __pyx_k_Detail[] = "Detail";
static const char __pyx_k_Failed[] = "Failed";
static const char __pyx_k_NAKCnt[] = "NAKCnt";
static const char __pyx_k_NodeOK[] = "NodeOK";
static const char __pyx_k_None_2[] = "None.";
static const char __pyx_k_Normal[] = "Normal";
static const char __pyx_k_NotSUC[] = "NotSUC";
static const char __pyx_k_OOFCnt[] = "OOFCnt";
static const char __pyx_k_Probe1[] = "Probe1";
static const char __pyx_k_SOFCnt[] = "SOFCnt";
static const char __pyx_k_Serial[] = "Serial";
static const char __pyx_k_Static[] = "Static";
static const char __pyx_k_String[] = "String";
static const char __pyx_k_System[] = "System";
static const char __pyx_k_WakeUp[] = "WakeUp";
static const char __pyx_k_access[] = "access";
static const char __pyx_k_append[] = "append";
static const char __pyx_k_ccData[] = "ccData";
static const char __pyx_k_config[] = "config";
static const char __pyx_k_create[] = "create";
static const char __pyx_k_decode[] = "decode";
static const char __pyx_k_encode[] = "encode";
static const char __pyx_k_exists[] = "exists";
static const char __pyx_k_getcwd[] = "getcwd";
static const char __pyx_k_homeId[] = "homeId";
static const char __pyx_k_homeid[] = "homeid";
static const char __pyx_k_import[] = "__import__";
static const char __pyx_k_isfile[] = "isfile";
static const char __pyx_k_logger[] = "logger";
static const char __pyx_k_module[] = "__module__";
static const char __pyx_k_nodeId[] = "nodeId";
static const char __pyx_k_nodeid[] = "nodeid";
static const char __pyx_k_record[] = "record";
static const char __pyx_k_sentTS[] = "sentTS";
static const char __pyx_k_setDoc[] = "setDoc";
static const char __pyx_k_shutil[] = "shutil";
static const char __pyx_k_verify[] = "verify";
static const char __pyx_k_Boolean[] = "Boolean.";
static const char __pyx_k_Decimal[] = "Decimal";
static const char __pyx_k_Dynamic[] = "Dynamic";
static const char __pyx_k_Exclude[] = "Exclude";
static const char __pyx_k_Handler[] = "Handler";
static const char __pyx_k_Include[] = "Include";
static const char __pyx_k_Integer[] = "Integer.";
static const char __pyx_k_Invalid[] = "Invalid";
static const char __pyx_k_Logging[] = "Logging";
static const char __pyx_k_NodeNew[] = "NodeNew";
static const char __pyx_k_Session[] = "Session";
static const char __pyx_k_Timeout[] = "Timeout";
static const char __pyx_k_Unknown[] = "Unknown";
static const char __pyx_k_Waiting[] = "Waiting";
static const char __pyx_k_Warning[] = "Warning";
static const char __pyx_k_abspath[] = "abspath";
static const char __pyx_k_command[] = "command";
static const char __pyx_k_dirname[] = "dirname";
static const char __pyx_k_dropped[] = "dropped";
static const char __pyx_k_logging[] = "logging";
static const char __pyx_k_message[] = "message";
static const char __pyx_k_minutes[] = "minutes";
static const char __pyx_k_netbusy[] = "netbusy";
static const char __pyx_k_prepare[] = "__prepare__";
static const char __pyx_k_quality[] = "quality";
static const char __pyx_k_readCnt[] = "readCnt";
static const char __pyx_k_retries[] = "retries";
static const char __pyx_k_sceneId[] = "sceneId";
static const char __pyx_k_sceneid[] = "sceneid";
static const char __pyx_k_sentCnt[] = "sentCnt";
static const char __pyx_k_setback[] = "setback";
static const char __pyx_k_valueId[] = "valueId";
static const char __pyx_k_version[] = "__version__";
static const char __pyx_k_warning[] = "warning";
static const char __pyx_k_ButtonOn[] = "ButtonOn";
static const char __pyx_k_Button_2[] = "Button.";
static const char __pyx_k_Complete[] = "Complete";
static const char __pyx_k_Disabled[] = "Disabled";
static const char __pyx_k_Internal[] = "Internal";
static const char __pyx_k_NodeInfo[] = "NodeInfo";
static const char __pyx_k_NotFound[] = "NotFound";
static const char __pyx_k_Overflow[] = "Overflow";
static const char __pyx_k_PyGenres[] = "PyGenres";
static const char __pyx_k_Schedule[] = "Schedule";
static const char __pyx_k_Sleeping[] = "Sleeping";
static const char __pyx_k_Starting[] = "Starting";
static const char __pyx_k_String_2[] = "String.";
static const char __pyx_k_UserPath[] = "UserPath";
static const char __pyx_k_Versions[] = "Versions";
static const char __pyx_k_buttonId[] = "buttonId";
static const char __pyx_k_buttonid[] = "buttonid";
static const char __pyx_k_cmd_line[] = "cmd_line";
static const char __pyx_k_copyfile[] = "copyfile";
static const char __pyx_k_groupIdx[] = "groupIdx";
static const char __pyx_k_groupidx[] = "groupidx";
static const char __pyx_k_instance[] = "instance";
static const char __pyx_k_location[] = "location";
static const char __pyx_k_new_node[] = "new node";
static const char __pyx_k_qualname[] = "__qualname__";
static const char __pyx_k_readOnly[] = "readOnly";
static const char __pyx_k_warnings[] = "warnings";
static const char __pyx_k_writeCnt[] = "writeCnt";
static const char __pyx_k_AddDevice[] = "AddDevice";
static const char __pyx_k_Associate[] = "Associate";
static const char __pyx_k_ButtonOff[] = "ButtonOff";
static const char __pyx_k_Completed[] = "Completed";
static const char __pyx_k_EnableSIS[] = "EnableSIS";
static const char __pyx_k_Instances[] = "Instances";
static const char __pyx_k_Interface[] = "Interface";
static const char __pyx_k_IsPrimary[] = "IsPrimary";
static const char __pyx_k_Neighbors[] = "Neighbors";
static const char __pyx_k_NodeAdded[] = "NodeAdded";
static const char __pyx_k_NodeEvent[] = "NodeEvent";
static const char __pyx_k_NodeReset[] = "NodeReset";
static const char __pyx_k_NotBridge[] = "NotBridge";
static const char __pyx_k_PYLIBRARY[] = "PYLIBRARY";
static const char __pyx_k_SUPPORTED[] = "SUPPORTED";
static const char __pyx_k_badroutes[] = "badroutes";
static const char __pyx_k_callbacks[] = "callbacks";
static const char __pyx_k_className[] = "className";
static const char __pyx_k_error_msg[] = "error_msg";
static const char __pyx_k_exception[] = "exception";
static const char __pyx_k_getLogger[] = "getLogger";
static const char __pyx_k_highPower[] = "highPower";
static const char __pyx_k_init___py[] = "__init__.py";
static const char __pyx_k_intensity[] = "intensity";
static const char __pyx_k_metaclass[] = "__metaclass__";
static const char __pyx_k_user_path[] = "user_path";
static const char __pyx_k_usr_local[] = "/usr/local";
static const char __pyx_k_zwcfg_xsd[] = "zwcfg.xsd";
static const char __pyx_k_ACKWaiting[] = "ACKWaiting";
static const char __pyx_k_ConfigPath[] = "ConfigPath";
static const char __pyx_k_InProgress[] = "InProgress";
static const char __pyx_k_NetworkKey[] = "NetworkKey";
static const char __pyx_k_No_command[] = "No command.";
static const char __pyx_k_NodeFailed[] = "NodeFailed";
static const char __pyx_k_NodeNaming[] = "NodeNaming";
static const char __pyx_k_NotPrimary[] = "NotPrimary";
static const char __pyx_k_SceneEvent[] = "SceneEvent";
static const char __pyx_k_ValueAdded[] = "ValueAdded";
static const char __pyx_k_ValueError[] = "ValueError";
static const char __pyx_k_addHandler[] = "addHandler";
static const char __pyx_k_configPath[] = "configPath";
static const char __pyx_k_doSecurity[] = "doSecurity";
static const char __pyx_k_node_added[] = "node added";
static const char __pyx_k_node_event[] = "node event";
static const char __pyx_k_pythonfunc[] = "pythonfunc";
static const char __pyx_k_readAborts[] = "readAborts";
static const char __pyx_k_receivedTS[] = "receivedTS";
static const char __pyx_k_routedbusy[] = "routedbusy";
static const char __pyx_k_sentFailed[] = "sentFailed";
static const char __pyx_k_setDocType[] = "setDocType";
static const char __pyx_k_AssumeAwake[] = "AssumeAwake";
static const char __pyx_k_DriverReady[] = "DriverReady";
static const char __pyx_k_DriverReset[] = "DriverReset";
static const char __pyx_k_EnumWithDoc[] = "EnumWithDoc";
static const char __pyx_k_Enum_helper[] = "Enum helper";
static const char __pyx_k_ImportError[] = "ImportError";
static const char __pyx_k_LogFileName[] = "LogFileName";
static const char __pyx_k_MsgComplete[] = "MsgComplete";
static const char __pyx_k_NoOperation[] = "NoOperation";
static const char __pyx_k_NodeRemoved[] = "NodeRemoved";
static const char __pyx_k_NullHandler[] = "NullHandler";
static const char __pyx_k_PyLogLevels[] = "PyLogLevels";
static const char __pyx_k_Text_string[] = "Text string";
static const char __pyx_k_badChecksum[] = "badChecksum";
static const char __pyx_k_config_path[] = "config_path";
static const char __pyx_k_node_naming[] = "node naming";
static const char __pyx_k_nondelivery[] = "nondelivery";
static const char __pyx_k_options_xml[] = "options.xml";
static const char __pyx_k_productName[] = "productName";
static const char __pyx_k_receivedCnt[] = "receivedCnt";
static const char __pyx_k_upNodeRoute[] = "upNodeRoute";
static const char __pyx_k_value_added[] = "value added";
static const char __pyx_k_Associations[] = "Associations";
static const char __pyx_k_CreateButton[] = "CreateButton";
static const char __pyx_k_DeleteButton[] = "DeleteButton";
static const char __pyx_k_DriverFailed[] = "DriverFailed";
static const char __pyx_k_Invalid_type[] = "Invalid type.";
static const char __pyx_k_NodeNotFound[] = "NodeNotFound";
static const char __pyx_k_NotSecondary[] = "NotSecondary";
static const char __pyx_k_Notification[] = "Notification";
static const char __pyx_k_PollInterval[] = "PollInterval";
static const char __pyx_k_ProtocolInfo[] = "ProtocolInfo";
static const char __pyx_k_PyOptionList[] = "PyOptionList";
static const char __pyx_k_PyOptionType[] = "PyOptionType";
static const char __pyx_k_PyStatDriver[] = "PyStatDriver";
static const char __pyx_k_PyValueTypes[] = "PyValueTypes";
static const char __pyx_k_RemoveDevice[] = "RemoveDevice";
static const char __pyx_k_RetryTimeout[] = "RetryTimeout";
static const char __pyx_k_SaveLogLevel[] = "SaveLogLevel";
static const char __pyx_k_StreamDetail[] = "StreamDetail";
static const char __pyx_k_ValueChanged[] = "ValueChanged";
static const char __pyx_k_ValueRemoved[] = "ValueRemoved";
static const char __pyx_k_addOptionInt[] = "addOptionInt";
static const char __pyx_k_classVersion[] = "classVersion";
static const char __pyx_k_commandClass[] = "commandClass";
static const char __pyx_k_driver_ready[] = "driver ready";
static const char __pyx_k_driver_reset[] = "driver reset";
static const char __pyx_k_libopenzwave[] = "libopenzwave";
static const char __pyx_k_milliseconds[] = "milliseconds";
static const char __pyx_k_node_removed[] = "node removed";
static const char __pyx_k_receivedDups[] = "receivedDups";
static const char __pyx_k_targetnodeid[] = "targetnodeid";
static const char __pyx_k_AppendLogFile[] = "AppendLogFile";
static const char __pyx_k_CALLBACK_DESC[] = "CALLBACK_DESC";
static const char __pyx_k_Configuration[] = "Configuration";
static const char __pyx_k_ConsoleOutput[] = "ConsoleOutput";
static const char __pyx_k_DriverRemoved[] = "DriverRemoved";
static const char __pyx_k_HasNodeFailed[] = "HasNodeFailed";
static const char __pyx_k_QueueLogLevel[] = "QueueLogLevel";
static const char __pyx_k_addOptionBool[] = "addOptionBool";
static const char __pyx_k_etc_openzwave[] = "/etc/openzwave/";
static const char __pyx_k_getConfigPath[] = "getConfigPath";
static const char __pyx_k_not_installed[] = "not_installed";
static const char __pyx_k_pkg_resources[] = "pkg_resources";
static const char __pyx_k_value_changed[] = "value changed";
static const char __pyx_k_value_removed[] = "value removed";
static const char __pyx_k_0x62_0x4c_0x63[] = "0x62,0x4c,0x63";
static const char __pyx_k_AttributeError[] = "AttributeError";
static const char __pyx_k_ButtonNotFound[] = "ButtonNotFound";
static const char __pyx_k_PollingEnabled[] = "PollingEnabled";
static const char __pyx_k_ValueRefreshed[] = "ValueRefreshed";
static const char __pyx_k_commandClassId[] = "commandClassId";
static const char __pyx_k_getOptionAsInt[] = "getOptionAsInt";
static const char __pyx_k_groups_changed[] = "groups changed";
static const char __pyx_k_lastRequestRTT[] = "lastRequestRTT";
static const char __pyx_k_AllNodesQueried[] = "AllNodesQueried";
static const char __pyx_k_CustomSecuredCC[] = "CustomSecuredCC";
static const char __pyx_k_EnumWithDocType[] = "EnumWithDocType";
static const char __pyx_k_PollingDisabled[] = "PollingDisabled";
static const char __pyx_k_PyNotifications[] = "PyNotifications";
static const char __pyx_k_Raw_byte_values[] = "Raw byte values";
static const char __pyx_k_ReplicationSend[] = "ReplicationSend";
static const char __pyx_k_addOptionString[] = "addOptionString";
static const char __pyx_k_controllerError[] = "controllerError";
static const char __pyx_k_controllerState[] = "controllerState";
static const char __pyx_k_getOptionAsBool[] = "getOptionAsBool";
static const char __pyx_k_lastResponseRTT[] = "lastResponseRTT";
static const char __pyx_k_polling_enabled[] = "polling enabled";
static const char __pyx_k_CreateNewPrimary[] = "CreateNewPrimary";
static const char __pyx_k_DumpTriggerLevel[] = "DumpTriggerLevel";
static const char __pyx_k_NodeProtocolInfo[] = "NodeProtocolInfo";
static const char __pyx_k_NullHandler_emit[] = "NullHandler.emit";
static const char __pyx_k_RemoveFailedNode[] = "RemoveFailedNode";
static const char __pyx_k_SecurityStrategy[] = "SecurityStrategy";
static const char __pyx_k_broadcastReadCnt[] = "broadcastReadCnt";
static const char __pyx_k_get_distribution[] = "get_distribution";
static const char __pyx_k_manufacturerName[] = "manufacturerName";
static const char __pyx_k_message_complete[] = "message complete";
static const char __pyx_k_notificationCode[] = "notificationCode";
static const char __pyx_k_notificationType[] = "notificationType";
static const char __pyx_k_openzwave_config[] = "openzwave/config";
static const char __pyx_k_polling_disabled[] = "polling disabled";
static const char __pyx_k_AssignReturnRoute[] = "AssignReturnRoute";
static const char __pyx_k_AwakeNodesQueried[] = "AwakeNodesQueried";
static const char __pyx_k_ControllerCommand[] = "ControllerCommand";
static const char __pyx_k_DriverMaxAttempts[] = "DriverMaxAttempts";
static const char __pyx_k_LibZWaveException[] = "LibZWaveException";
static const char __pyx_k_PyControllerError[] = "PyControllerError";
static const char __pyx_k_PyControllerState[] = "PyControllerState";
static const char __pyx_k_ReplaceFailedNode[] = "ReplaceFailedNode";
static const char __pyx_k_SaveConfiguration[] = "SaveConfiguration";
static const char __pyx_k_all_nodes_queried[] = "all nodes queried";
static const char __pyx_k_averageRequestRTT[] = "averageRequestRTT";
static const char __pyx_k_broadcastWriteCnt[] = "broadcastWriteCnt";
static const char __pyx_k_getOptionAsString[] = "getOptionAsString";
static const char __pyx_k_libopenzwave_file[] = "libopenzwave_file";
static const char __pyx_k_resource_filename[] = "resource_filename";
static const char __pyx_k_COMMAND_CLASS_DESC[] = "COMMAND_CLASS_DESC";
static const char __pyx_k_COMMAND_CLASS_HAIL[] = "COMMAND_CLASS_HAIL";
static const char __pyx_k_COMMAND_CLASS_KICK[] = "COMMAND_CLASS_KICK";
static const char __pyx_k_COMMAND_CLASS_LOCK[] = "COMMAND_CLASS_LOCK";
static const char __pyx_k_COMMAND_CLASS_MARK[] = "COMMAND_CLASS_MARK";
static const char __pyx_k_COMMAND_CLASS_TIME[] = "COMMAND_CLASS_TIME";
static const char __pyx_k_Completed_messages[] = "Completed messages.";
static const char __pyx_k_CreateNewPrimary_2[] = "CreateNewPrimary.";
static const char __pyx_k_EnumWithDoc_setDoc[] = "EnumWithDoc.setDoc";
static const char __pyx_k_Invalid_Log_Status[] = "Invalid Log Status";
static const char __pyx_k_NotifyTransactions[] = "NotifyTransactions";
static const char __pyx_k_RemoveFailedNode_2[] = "RemoveFailedNode.";
static const char __pyx_k_averageResponseRTT[] = "averageResponseRTT";
static const char __pyx_k_controllerErrorDoc[] = "controllerErrorDoc";
static const char __pyx_k_controllerErrorInt[] = "controllerErrorInt";
static const char __pyx_k_controllerStateDoc[] = "controllerStateDoc";
static const char __pyx_k_controllerStateInt[] = "controllerStateInt";
static const char __pyx_k_device_classes_xml[] = "device_classes.xml";
static const char __pyx_k_node_protocol_info[] = "node protocol info";
static const char __pyx_k_notif_callback_end[] = "notif_callback : end";
static const char __pyx_k_16_bit_signed_value[] = "16-bit signed value";
static const char __pyx_k_32_bit_signed_value[] = "32-bit signed value";
static const char __pyx_k_COMMAND_CLASS_ALARM[] = "COMMAND_CLASS_ALARM";
static const char __pyx_k_COMMAND_CLASS_BASIC[] = "COMMAND_CLASS_BASIC";
static const char __pyx_k_COMMAND_CLASS_CLOCK[] = "COMMAND_CLASS_CLOCK";
static const char __pyx_k_COMMAND_CLASS_COLOR[] = "COMMAND_CLASS_COLOR";
static const char __pyx_k_COMMAND_CLASS_METER[] = "COMMAND_CLASS_METER";
static const char __pyx_k_Disable_all_logging[] = "Disable all logging";
static const char __pyx_k_NodeQueriesComplete[] = "NodeQueriesComplete";
static const char __pyx_k_PerformReturnRoutes[] = "PerformReturnRoutes";
static const char __pyx_k_PyControllerCommand[] = "PyControllerCommand";
static const char __pyx_k_PyNotificationCodes[] = "PyNotificationCodes";
static const char __pyx_k_RefreshAllUserCodes[] = "RefreshAllUserCodes";
static const char __pyx_k_SendNodeInformation[] = "SendNodeInformation";
static const char __pyx_k_TransferPrimaryRole[] = "TransferPrimaryRole";
static const char __pyx_k_awake_nodes_queried[] = "awake nodes queried";
static const char __pyx_k_lastReceivedMessage[] = "lastReceivedMessage";
static const char __pyx_k_receivedUnsolicited[] = "receivedUnsolicited";
static const char __pyx_k_8_bit_unsigned_value[] = "8-bit unsigned value";
static const char __pyx_k_CWD_CONFIG_DIRECTORY[] = "CWD_CONFIG_DIRECTORY";
static const char __pyx_k_DistributionNotFound[] = "DistributionNotFound";
static const char __pyx_k_IntervalBetweenPolls[] = "IntervalBetweenPolls";
static const char __pyx_k_NotifyOnDriverUnload[] = "NotifyOnDriverUnload";
static const char __pyx_k_ReceiveConfiguration[] = "ReceiveConfiguration";
static const char __pyx_k_RequestNetworkUpdate[] = "RequestNetworkUpdate";
static const char __pyx_k_SuppressValueRefresh[] = "SuppressValueRefresh";
static const char __pyx_k_addValueId_ValueID_s[] = "addValueId : ValueID : %s";
static const char __pyx_k_delValueId_ValueID_s[] = "delValueId : ValueID : %s";
static const char __pyx_k_Boolean_true_or_false[] = "Boolean, true or false";
static const char __pyx_k_COMMAND_CLASS_BATTERY[] = "COMMAND_CLASS_BATTERY";
static const char __pyx_k_COMMAND_CLASS_DISPLAY[] = "COMMAND_CLASS_DISPLAY";
static const char __pyx_k_COMMAND_CLASS_VERSION[] = "COMMAND_CLASS_VERSION";
static const char __pyx_k_COMMAND_CLASS_WAKE_UP[] = "COMMAND_CLASS_WAKE_UP";
static const char __pyx_k_DeleteAllReturnRoutes[] = "DeleteAllReturnRoutes";
static const char __pyx_k_Driver_failed_to_load[] = "Driver failed to load.";
static const char __pyx_k_ManufacturerSpecific1[] = "ManufacturerSpecific1";
static const char __pyx_k_ManufacturerSpecific2[] = "ManufacturerSpecific2";
static const char __pyx_k_PyControllerInterface[] = "PyControllerInterface";
static const char __pyx_k_bIntervalBetweenPolls[] = "bIntervalBetweenPolls";
static const char __pyx_k_libopenzwave_location[] = "libopenzwave_location";
static const char __pyx_k_node_queries_complete[] = "node queries complete";
static const char __pyx_k_COMMAND_CLASS_LANGUAGE[] = "COMMAND_CLASS_LANGUAGE";
static const char __pyx_k_COMMAND_CLASS_SECURITY[] = "COMMAND_CLASS_SECURITY";
static const char __pyx_k_EnforceSecureReception[] = "EnforceSecureReception";
static const char __pyx_k_No_command_in_progress[] = "No command in progress.";
static const char __pyx_k_ReceiveConfiguration_2[] = "ReceiveConfiguration.";
static const char __pyx_k_The_command_has_failed[] = "The command has failed.";
static const char __pyx_k_share_openzwave_config[] = "share/openzwave/config";
static const char __pyx_k_AllNodesQueriedSomeDead[] = "AllNodesQueriedSomeDead";
static const char __pyx_k_COMMAND_CLASS_COMPOSITE[] = "COMMAND_CLASS_COMPOSITE";
static const char __pyx_k_COMMAND_CLASS_DOOR_LOCK[] = "COMMAND_CLASS_DOOR_LOCK";
static const char __pyx_k_COMMAND_CLASS_INDICATOR[] = "COMMAND_CLASS_INDICATOR";
static const char __pyx_k_COMMAND_CLASS_MULTI_CMD[] = "COMMAND_CLASS_MULTI_CMD";
static const char __pyx_k_COMMAND_CLASS_SCREEN_MD[] = "COMMAND_CLASS_SCREEN_MD";
static const char __pyx_k_COMMAND_CLASS_USER_CODE[] = "COMMAND_CLASS_USER_CODE";
static const char __pyx_k_LibZWaveException___str[] = "LibZWaveException.__str__";
static const char __pyx_k_Number_of_bad_checksums[] = "Number of bad checksums";
static const char __pyx_k_OZWAVE_CONFIG_DIRECTORY[] = "OZWAVE_CONFIG_DIRECTORY";
static const char __pyx_k_SetValueListSelection_s[] = "SetValueListSelection %s";
static const char __pyx_k_The_command_is_starting[] = "The command is starting.";
static const char __pyx_k_ctrl_callback_Message_s[] = "ctrl_callback : Message: %s";
static const char __pyx_k_usr_local_etc_openzwave[] = "/usr/local/etc/openzwave/";
static const char __pyx_k_COMMAND_CLASS_POWERLEVEL[] = "COMMAND_CLASS_POWERLEVEL";
static const char __pyx_k_COMMAND_CLASS_PROTECTION[] = "COMMAND_CLASS_PROTECTION";
static const char __pyx_k_COMMAND_CLASS_SWITCH_ALL[] = "COMMAND_CLASS_SWITCH_ALL";
static const char __pyx_k_COMMAND_CLASS_ZIP_CLIENT[] = "COMMAND_CLASS_ZIP_CLIENT";
static const char __pyx_k_COMMAND_CLASS_ZIP_SERVER[] = "COMMAND_CLASS_ZIP_SERVER";
static const char __pyx_k_LibZWaveException___init[] = "LibZWaveException.__init__";
static const char __pyx_k_getAssociationsInstances[] = "getAssociationsInstances";
static const char __pyx_k_notif_callback_exception[] = "notif_callback exception";
static const char __pyx_k_COMMAND_CLASS_ASSOCIATION[] = "COMMAND_CLASS_ASSOCIATION";
static const char __pyx_k_COMMAND_CLASS_CHIMNEY_FAN[] = "COMMAND_CLASS_CHIMNEY_FAN";
static const char __pyx_k_COMMAND_CLASS_GARAGE_DOOR[] = "COMMAND_CLASS_GARAGE_DOOR";
static const char __pyx_k_COMMAND_CLASS_METER_PULSE[] = "COMMAND_CLASS_METER_PULSE";
static const char __pyx_k_COMMAND_CLASS_NODE_NAMING[] = "COMMAND_CLASS_NODE_NAMING";
static const char __pyx_k_COMMAND_CLASS_PROPRIETARY[] = "COMMAND_CLASS_PROPRIETARY";
static const char __pyx_k_Number_of_broadcasts_read[] = "Number of broadcasts read";
static const char __pyx_k_Number_of_broadcasts_sent[] = "Number of broadcasts sent";
static const char __pyx_k_RequestNodeNeighborUpdate[] = "RequestNodeNeighborUpdate";
static const char __pyx_k_The_command_was_cancelled[] = "The command was cancelled.";
static const char __pyx_k_addValueId_Notification_s[] = "addValueId : Notification : %s";
static const char __pyx_k_call_to_AddWatcher_failed[] = "call to AddWatcher failed";
static const char __pyx_k_getValueFromType_return_s[] = "getValueFromType return %s";
static const char __pyx_k_COMMAND_CLASS_CRC_16_ENCAP[] = "COMMAND_CLASS_CRC_16_ENCAP";
static const char __pyx_k_COMMAND_CLASS_NETWORK_STAT[] = "COMMAND_CLASS_NETWORK_STAT";
static const char __pyx_k_COMMAND_CLASS_NO_OPERATION[] = "COMMAND_CLASS_NO_OPERATION";
static const char __pyx_k_COMMAND_CLASS_SENSOR_ALARM[] = "COMMAND_CLASS_SENSOR_ALARM";
static const char __pyx_k_COMMAND_CLASS_ZIP_SERVICES[] = "COMMAND_CLASS_ZIP_SERVICES";
static const char __pyx_k_EnumWithDocType_setDocType[] = "EnumWithDocType.setDocType";
static const char __pyx_k_PY_OZWAVE_CONFIG_DIRECTORY[] = "PY_OZWAVE_CONFIG_DIRECTORY";
static const char __pyx_k_RequestNetworkUpdate_error[] = "RequestNetworkUpdate error.";
static const char __pyx_k_COMMAND_CLASS_AV_TAGGING_MD[] = "COMMAND_CLASS_AV_TAGGING_MD";
static const char __pyx_k_COMMAND_CLASS_CENTRAL_SCENE[] = "COMMAND_CLASS_CENTRAL_SCENE";
static const char __pyx_k_COMMAND_CLASS_CONFIGURATION[] = "COMMAND_CLASS_CONFIGURATION";
static const char __pyx_k_COMMAND_CLASS_GROUPING_NAME[] = "COMMAND_CLASS_GROUPING_NAME";
static const char __pyx_k_COMMAND_CLASS_SENSOR_BINARY[] = "COMMAND_CLASS_SENSOR_BINARY";
static const char __pyx_k_COMMAND_CLASS_SILENCE_ALARM[] = "COMMAND_CLASS_SILENCE_ALARM";
static const char __pyx_k_COMMAND_CLASS_SWITCH_BINARY[] = "COMMAND_CLASS_SWITCH_BINARY";
static const char __pyx_k_Can_t_find_options_xml_in_s[] = "Can't find options.xml in %s";
static const char __pyx_k_Can_t_find_user_directory_s[] = "Can't find user directory %s";
static const char __pyx_k_The_Driver_is_being_removed[] = "The Driver is being removed.";
static const char __pyx_k_python_openzwave_ozw_config[] = "python_openzwave.ozw_config";
static const char __pyx_k_COMMAND_CLASS_METER_TBL_PUSH[] = "COMMAND_CLASS_METER_TBL_PUSH";
static const char __pyx_k_COMMAND_CLASS_ZIP_ADV_CLIENT[] = "COMMAND_CLASS_ZIP_ADV_CLIENT";
static const char __pyx_k_EssentialNodeQueriesComplete[] = "EssentialNodeQueriesComplete";
static const char __pyx_k_Number_of_ACK_bytes_received[] = "Number of ACK bytes received";
static const char __pyx_k_Number_of_CAN_bytes_received[] = "Number of CAN bytes received";
static const char __pyx_k_Number_of_NAK_bytes_received[] = "Number of NAK bytes received";
static const char __pyx_k_Number_of_SOF_bytes_received[] = "Number of SOF bytes received";
static const char __pyx_k_call_to_RemoveWatcher_failed[] = "call to RemoveWatcher failed";
static const char __pyx_k_A_manager_notification_report[] = "A manager notification report.";
static const char __pyx_k_COMMAND_CLASS_THERMOSTAT_MODE[] = "COMMAND_CLASS_THERMOSTAT_MODE";
static const char __pyx_k_COMMAND_CLASS_TIME_PARAMETERS[] = "COMMAND_CLASS_TIME_PARAMETERS";
static const char __pyx_k_COMMAND_CLASS_ZWAVE_PLUS_INFO[] = "COMMAND_CLASS_ZWAVE_PLUS_INFO";
static const char __pyx_k_Can_t_find_config_directory_s[] = "Can't find config directory %s";
static const char __pyx_k_Report_when_a_node_is_revived[] = "Report when a node is revived.";
static const char __pyx_k_Scene_Activation_Set_received[] = "Scene Activation Set received.";
static const char __pyx_k_Send_a_node_information_frame[] = "Send a node information frame.";
static const char __pyx_k_COMMAND_CLASS_BARRIER_OPERATOR[] = "COMMAND_CLASS_BARRIER_OPERATOR";
static const char __pyx_k_COMMAND_CLASS_IP_CONFIGURATION[] = "COMMAND_CLASS_IP_CONFIGURATION";
static const char __pyx_k_COMMAND_CLASS_METER_TBL_CONFIG[] = "COMMAND_CLASS_METER_TBL_CONFIG";
static const char __pyx_k_COMMAND_CLASS_SCENE_ACTIVATION[] = "COMMAND_CLASS_SCENE_ACTIVATION";
static const char __pyx_k_COMMAND_CLASS_ZIP_ADV_SERVICES[] = "COMMAND_CLASS_ZIP_ADV_SERVICES";
static const char __pyx_k_LibOpenZwave_Generic_Exception[] = "LibOpenZwave Generic Exception";
static const char __pyx_k_Number_of_bytes_out_of_framing[] = "Number of bytes out of framing";
static const char __pyx_k_Number_of_unexpected_callbacks[] = "Number of unexpected callbacks";
static const char __pyx_k_Path_to_the_user_s_data_folder[] = "Path to the user's data folder.";
static const char __pyx_k_A_new_node_value_has_been_added[] = "A new node value has been added to OpenZWave's set. These notifications occur after a node has been discovered, and details of its command classes have been received.  Each command class may generate one or more values depending on the complexity of the item being represented.";
static const char __pyx_k_All_nodes_have_been_queried_but[] = "All nodes have been queried but some dead nodes found.";
static const char __pyx_k_Assume_Devices_that_Support_the[] = "Assume Devices that Support the Wakeup CC are awake when we first query them ...";
static const char __pyx_k_Basic_node_information_has_been[] = "Basic node information has been receievd, such as whether the node is a setening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description.";
static const char __pyx_k_COMMAND_CLASS_AV_CONTENT_SEARCH[] = "COMMAND_CLASS_AV_CONTENT_SEARCH_MD";
static const char __pyx_k_COMMAND_CLASS_DOOR_LOCK_LOGGING[] = "COMMAND_CLASS_DOOR_LOCK_LOGGING";
static const char __pyx_k_COMMAND_CLASS_ENERGY_PRODUCTION[] = "COMMAND_CLASS_ENERGY_PRODUCTION";
static const char __pyx_k_COMMAND_CLASS_METER_TBL_MONITOR[] = "COMMAND_CLASS_METER_TBL_MONITOR";
static const char __pyx_k_COMMAND_CLASS_NON_INTEROPERABLE[] = "COMMAND_CLASS_NON_INTEROPERABLE";
static const char __pyx_k_COMMAND_CLASS_SCREEN_ATTRIBUTES[] = "COMMAND_CLASS_SCREEN_ATTRIBUTES";
static const char __pyx_k_COMMAND_CLASS_SENSOR_MULTILEVEL[] = "COMMAND_CLASS_SENSOR_MULTILEVEL";
static const char __pyx_k_COMMAND_CLASS_SIMPLE_AV_CONTROL[] = "COMMAND_CLASS_SIMPLE_AV_CONTROL";
static const char __pyx_k_COMMAND_CLASS_SWITCH_MULTILEVEL[] = "COMMAND_CLASS_SWITCH_MULTILEVEL";
static const char __pyx_k_Can_t_retrieve_zwcfg_xsd_from_s[] = "Can't retrieve zwcfg.xsd from %s";
static const char __pyx_k_Can_t_write_in_user_directory_s[] = "Can't write in user directory %s";
static const char __pyx_k_Controller_interface_use_serial[] = "Controller interface use serial protocol.";
static const char __pyx_k_Delete_all_return_routes_from_a[] = "Delete all return routes from a device.";
static const char __pyx_k_Enable_automatic_association_of[] = "Enable automatic association of the controller with group one of every device.";
static const char __pyx_k_Everything_s_working_fine_these[] = "Everything's working fine...these messages provide streamlined feedback on each message";
static const char __pyx_k_Exception_class_for_LibOpenZWav[] = "\n    Exception class for LibOpenZWave\n    ";
static const char __pyx_k_List_from_which_one_item_can_be[] = "List from which one item can be selected";
static const char __pyx_k_Make_a_different_controller_the[] = "Make a different controller the primary.";
static const char __pyx_k_Messages_that_timeout_will_send[] = "Messages that timeout will send a Notification with this code.";
static const char __pyx_k_Move_a_node_to_the_controller_s[] = "Move a node to the controller's failed nodes list. This command will only work if the node cannot respond.";
static const char __pyx_k_Notification_Type_DriverRemoved[] = "Notification : Type_DriverRemoved received : clean all valueids";
static const char __pyx_k_NullHandler_logger_for_python_2[] = "NullHandler logger for python 2.6";
static const char __pyx_k_Number_of_messages_successfully[] = "Number of messages successfully read";
static const char __pyx_k_Save_the_XML_configuration_upon[] = "Save the XML configuration upon driver close.";
static const char __pyx_k_Save_to_file_log_messages_equal[] = "Save (to file) log messages equal to or above LogLevel_Detail.";
static const char __pyx_k_Should_we_encrypt_CC_s_that_are[] = "Should we encrypt CC's that are available via both clear text and Security CC?.";
static const char __pyx_k_The_controller_is_communicating[] = "The controller is communicating with the other device to carry out the command.";
static const char __pyx_k_These_messages_should_always_be[] = "These messages should always be shown";
static const char __pyx_k_home_sebastien_devel_python_ope[] = "/home/sebastien/devel/python-openzwave/src-lib/libopenzwave/libopenzwave.pyx";
static const char __pyx_k_module_libopenzwave_This_file_i[] = "\n.. module:: libopenzwave\n\nThis file is part of **python-openzwave** project https://github.com/OpenZWave/python-openzwave.\n\n:platform: Unix, Windows, MacOS X\n:sinopsis: openzwave C++\n\n.. moduleauthor: bibi21000 aka Sebastien GALLET <bibi21000@gmail.com>\n.. moduleauthor: Maarten Damen <m.damen@gmail.com>\n\nLicense : GPL(v3)\n\n**python-openzwave** is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\n**python-openzwave** is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details.\nYou should have received a copy of the GNU General Public License\nalong with python-openzwave. If not, see http://www.gnu.org/licenses.\n\n";
static const char __pyx_k_notif_callback_new_notification[] = "notif_callback : new notification";
static const char __pyx_k_30_seconds_can_easily_poll_30_va[] = "30 seconds (can easily poll 30 values in this time; ~120 values is the effective limit for 30 seconds).";
static const char __pyx_k_A_driver_for_a_PC_Z_Wave_control[] = "A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods.";
static const char __pyx_k_A_likely_fatal_issue_in_the_libr[] = "A likely fatal issue in the library";
static const char __pyx_k_A_minor_issue_from_which_the_lib[] = "A minor issue from which the library should be able to recover";
static const char __pyx_k_A_new_node_has_been_added_to_Ope[] = "A new node has been added to OpenZWave's set.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself.";
static const char __pyx_k_A_new_node_has_been_found_not_al[] = "A new node has been found (not already stored in zwcfg*.xml file).";
static const char __pyx_k_A_node_has_been_removed_from_Ope[] = "A node has been removed from OpenZWave's set.  This may be due to a device being removed from the Z-Wave network, or because the application is closing.";
static const char __pyx_k_A_node_has_been_reset_from_OpenZ[] = "A node has been reset from OpenZWave's set.  The Device has been reset and thus removed from the NodeList in OZW.";
static const char __pyx_k_A_node_has_triggered_an_event_Th[] = "A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification.";
static const char __pyx_k_A_node_value_has_been_removed_fr[] = "A node value has been removed from OpenZWave's set.  This only occurs when a node is removed.";
static const char __pyx_k_A_node_value_has_been_updated_fr[] = "A node value has been updated from the Z-Wave network and it is different from the previous value.";
static const char __pyx_k_A_serious_issue_with_the_library[] = "A serious issue with the library or the network";
static const char __pyx_k_A_write_only_value_that_is_the_e[] = "A write-only value that is the equivalent of pressing a button to send a command to a device";
static const char __pyx_k_Add_a_new_controller_to_the_Z_Wa[] = "Add a new controller to the Z-Wave network.  The new controller will be the primary, and the current primary will become a secondary controller.";
static const char __pyx_k_Add_a_new_device_but_not_a_contr[] = "Add a new device (but not a controller) to the Z-Wave network.";
static const char __pyx_k_All_awake_nodes_have_been_querie[] = "All awake nodes have been queried, so client application can expected complete data for these nodes.";
static const char __pyx_k_All_nodes_and_values_for_this_dr[] = "All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications.";
static const char __pyx_k_All_nodes_have_been_queried_so_c[] = "All nodes have been queried, so client application can expected complete data.";
static const char __pyx_k_All_the_initialisation_queries_o[] = "All the initialisation queries on a node have been completed.";
static const char __pyx_k_Append_new_session_logs_to_exist[] = "Append new session logs to existing log file (false = overwrite).";
static const char __pyx_k_Assign_a_network_return_routes_t[] = "Assign a network return routes to a device.";
static const char __pyx_k_Automatically_become_a_SUC_if_th[] = "Automatically become a SUC if there is no SUC on the network.";
static const char __pyx_k_Basic_values_an_ordinary_user_wo[] = "Basic values an ordinary user would be interested in.";
static const char __pyx_k_COMMAND_CLASS_ACTUATOR_MULTILEVE[] = "COMMAND_CLASS_ACTUATOR_MULTILEVEL";
static const char __pyx_k_COMMAND_CLASS_APPLICATION_STATUS[] = "COMMAND_CLASS_APPLICATION_STATUS";
static const char __pyx_k_COMMAND_CLASS_ASSOCIATION_COMMAN[] = "COMMAND_CLASS_ASSOCIATION_COMMAND_CONFIGURATION";
static const char __pyx_k_COMMAND_CLASS_AV_CONTENT_DIRECTO[] = "COMMAND_CLASS_AV_CONTENT_DIRECTORY_MD";
static const char __pyx_k_COMMAND_CLASS_AV_RENDERER_STATUS[] = "COMMAND_CLASS_AV_RENDERER_STATUS";
static const char __pyx_k_COMMAND_CLASS_BASIC_WINDOW_COVER[] = "COMMAND_CLASS_BASIC_WINDOW_COVERING";
static const char __pyx_k_COMMAND_CLASS_CLIMATE_CONTROL_SC[] = "COMMAND_CLASS_CLIMATE_CONTROL_SCHEDULE";
static const char __pyx_k_COMMAND_CLASS_CONTROLLER_REPLICA[] = "COMMAND_CLASS_CONTROLLER_REPLICATION";
static const char __pyx_k_COMMAND_CLASS_DEVICE_RESET_LOCAL[] = "COMMAND_CLASS_DEVICE_RESET_LOCALLY";
static const char __pyx_k_COMMAND_CLASS_FIRMWARE_UPDATE_MD[] = "COMMAND_CLASS_FIRMWARE_UPDATE_MD";
static const char __pyx_k_COMMAND_CLASS_GEOGRAPHIC_LOCATIO[] = "COMMAND_CLASS_GEOGRAPHIC_LOCATION";
static const char __pyx_k_COMMAND_CLASS_MANUFACTURER_PROPR[] = "COMMAND_CLASS_MANUFACTURER_PROPRIETARY";
static const char __pyx_k_COMMAND_CLASS_MANUFACTURER_SPECI[] = "COMMAND_CLASS_MANUFACTURER_SPECIFIC";
static const char __pyx_k_COMMAND_CLASS_MTP_WINDOW_COVERIN[] = "COMMAND_CLASS_MTP_WINDOW_COVERING";
static const char __pyx_k_COMMAND_CLASS_MULTI_CHANNEL_ASSO[] = "COMMAND_CLASS_MULTI_CHANNEL_ASSOCIATION";
static const char __pyx_k_COMMAND_CLASS_MULTI_INSTANCE_CHA[] = "COMMAND_CLASS_MULTI_INSTANCE/CHANNEL";
static const char __pyx_k_COMMAND_CLASS_REMOTE_ASSOCIATION[] = "COMMAND_CLASS_REMOTE_ASSOCIATION_ACTIVATE";
static const char __pyx_k_COMMAND_CLASS_SCENE_ACTUATOR_CON[] = "COMMAND_CLASS_SCENE_ACTUATOR_CONF";
static const char __pyx_k_COMMAND_CLASS_SCENE_CONTROLLER_C[] = "COMMAND_CLASS_SCENE_CONTROLLER_CONF";
static const char __pyx_k_COMMAND_CLASS_SCHEDULE_ENTRY_LOC[] = "COMMAND_CLASS_SCHEDULE_ENTRY_LOCK";
static const char __pyx_k_COMMAND_CLASS_SENSOR_CONFIGURATI[] = "COMMAND_CLASS_SENSOR_CONFIGURATION";
static const char __pyx_k_COMMAND_CLASS_SWITCH_TOGGLE_BINA[] = "COMMAND_CLASS_SWITCH_TOGGLE_BINARY";
static const char __pyx_k_COMMAND_CLASS_SWITCH_TOGGLE_MULT[] = "COMMAND_CLASS_SWITCH_TOGGLE_MULTILEVEL";
static const char __pyx_k_COMMAND_CLASS_THERMOSTAT_FAN_MOD[] = "COMMAND_CLASS_THERMOSTAT_FAN_MODE";
static const char __pyx_k_COMMAND_CLASS_THERMOSTAT_FAN_STA[] = "COMMAND_CLASS_THERMOSTAT_FAN_STATE";
static const char __pyx_k_COMMAND_CLASS_THERMOSTAT_HEATING[] = "COMMAND_CLASS_THERMOSTAT_HEATING";
static const char __pyx_k_COMMAND_CLASS_THERMOSTAT_OPERATI[] = "COMMAND_CLASS_THERMOSTAT_OPERATING_STATE";
static const char __pyx_k_COMMAND_CLASS_THERMOSTAT_SETBACK[] = "COMMAND_CLASS_THERMOSTAT_SETBACK";
static const char __pyx_k_COMMAND_CLASS_THERMOSTAT_SETPOIN[] = "COMMAND_CLASS_THERMOSTAT_SETPOINT";
static const char __pyx_k_Can_t_autoconfigure_path_to_conf[] = "Can't autoconfigure path to config";
static const char __pyx_k_Check_whether_a_node_is_in_the_c[] = "Check whether a node is in the controller's failed nodes list.";
static const char __pyx_k_Command_invocation_had_error_s_a[] = "Command invocation had error(s) and was aborted.";
static const char __pyx_k_Complex_type_used_with_the_Clima[] = "Complex type used with the Climate Control Schedule command class";
static const char __pyx_k_Controller_command_is_on_a_sleep[] = "Controller command is on a sleep queue wait for device.";
static const char __pyx_k_Controller_interface_use_human_i[] = "Controller interface use human interface device protocol.";
static const char __pyx_k_Controller_interface_use_unknown[] = "Controller interface use unknown protocol.";
static const char __pyx_k_Controller_is_waiting_for_a_user[] = "Controller is waiting for a user action.";
static const char __pyx_k_Create_an_id_that_tracks_handhel[] = "Create an id that tracks handheld button presses.";
static const char __pyx_k_Default_is_to_never_dump_RAM_sto[] = "Default is to never dump RAM-stored log messages.";
static const char __pyx_k_Delete_id_that_tracks_handheld_b[] = "Delete id that tracks handheld button presses.";
static const char __pyx_k_Detailed_information_on_the_prog[] = "Detailed information on the progress of each message";
static const char __pyx_k_Device_specific_configuration_pa[] = "Device-specific configuration parameters.  These cannot be automatically discovered via Z-Wave, and are usually described in the user manual instead.";
static const char __pyx_k_Display_log_information_on_conso[] = "Display log information on console (as well as save to disk).";
static const char __pyx_k_Enable_logging_of_library_activi[] = "Enable logging of library activity.";
static const char __pyx_k_Get_a_node_to_rebuild_its_neighb[] = "Get a node to rebuild its neighbour list.  This method also does ControllerCommand_RequestNodeNeighbors.";
static const char __pyx_k_Handheld_controller_button_event[] = "Handheld controller button event created.";
static const char __pyx_k_Handheld_controller_button_off_p[] = "Handheld controller button off pressed event.";
static const char __pyx_k_Handheld_controller_button_on_pr[] = "Handheld controller button on pressed event.";
static const char __pyx_k_How_long_do_we_wait_to_timeout_m[] = "How long do we wait to timeout messages sent.";
static const char __pyx_k_Identify_the_serial_port_to_be_a[] = "Identify the serial port to be accessed (TODO: change the code so more than one serial port can be specified and HID).";
static const char __pyx_k_If_false_try_to_execute_the_enti[] = "If false, try to execute the entire poll list within the PollInterval time frame. If true, wait for PollInterval milliseconds between polls.";
static const char __pyx_k_If_true_during_startup_we_refres[] = "If true, during startup, we refresh all the UserCodes the device reports it supports. If False, we stop after we get the first 'Available' slot (Some devices have 250+ usercode slots! - That makes our Session Stage Very Long ).";
static const char __pyx_k_If_true_notifications_for_refres[] = "If true, notifications for refreshed (but unchanged) values will not be sent.";
static const char __pyx_k_If_true_return_routes_will_be_up[] = "If true, return routes will be updated.";
static const char __pyx_k_If_we_recieve_a_clear_text_messa[] = "If we recieve a clear text message for a CC that is Secured, should we drop the message";
static const char __pyx_k_Key_used_to_negotiate_and_commun[] = "Key used to negotiate and communicate with devices that support Security Command Class";
static const char __pyx_k_Name_of_the_log_file_can_be_chan[] = "Name of the log file (can be changed via Log::SetLogFileName).";
static const char __pyx_k_Notification_Type_DriverReset_re[] = "Notification : Type_DriverReset received : clean all valueids";
static const char __pyx_k_Notifications_when_transaction_c[] = "Notifications when transaction complete is reported.";
static const char __pyx_k_Number_of_failed_messages_due_to[] = "Number of failed messages due to bad route response";
static const char __pyx_k_Number_of_messages_dropped_not_d[] = "Number of messages dropped & not delivered";
static const char __pyx_k_Number_of_messages_not_delivered[] = "Number of messages not delivered to network";
static const char __pyx_k_Number_of_messages_received_with[] = "Number of messages received with routed busy status";
static const char __pyx_k_Number_of_messages_retransmitted[] = "Number of messages retransmitted";
static const char __pyx_k_Number_of_network_busy_failure_m[] = "Number of network busy/failure messages";
static const char __pyx_k_Number_of_no_ACK_returned_errors[] = "Number of no ACK returned errors";
static const char __pyx_k_Number_of_times_read_were_aborte[] = "Number of times read were aborted due to timeouts";
static const char __pyx_k_Number_of_unsolicited_messages_w[] = "Number of unsolicited messages while waiting for an ACK";
static const char __pyx_k_One_of_the_node_names_has_change[] = "One of the node names has changed (name, manufacturer, product).";
static const char __pyx_k_Only_handle_the_specified_comman[] = "Only handle the specified command classes. The Exclude option is ignored if anything is listed here.";
static const char __pyx_k_Path_to_the_OpenZWave_config_fol[] = "Path to the OpenZWave config folder.";
static const char __pyx_k_Polling_of_a_node_has_been_succe[] = "Polling of a node has been successfully turned off by a call to Manager::DisablePoll.";
static const char __pyx_k_Receive_Z_Wave_network_configura[] = "Receive Z-Wave network configuration information from another controller.";
static const char __pyx_k_RemoveFailedNode_AddNodeToNetwor[] = "RemoveFailedNode, AddNodeToNetwork.";
static const char __pyx_k_RemoveFailedNode_RequestNetworkU[] = "RemoveFailedNode, RequestNetworkUpdate.";
static const char __pyx_k_Remove_a_new_device_but_not_a_co[] = "Remove a new device (but not a controller) from the Z-Wave network.";
static const char __pyx_k_Remove_support_for_the_listed_co[] = "Remove support for the listed command classes.";
static const char __pyx_k_Replace_a_non_responding_node_wi[] = "Replace a non-responding node with another. The node must be in the controller's list of failed nodes for this command to succeed.";
static const char __pyx_k_Report_on_NoOperation_message_se[] = "Report on NoOperation message sent completion.";
static const char __pyx_k_Report_when_a_node_goes_to_sleep[] = "Report when a node goes to sleep.";
static const char __pyx_k_Report_when_a_node_is_presumed_d[] = "Report when a node is presumed dead.";
static const char __pyx_k_Report_when_a_sleeping_node_wake[] = "Report when a sleeping node wakes.";
static const char __pyx_k_Represents_a_non_integer_value_a[] = "Represents a non-integer value as a string, to avoid floating point accuracy issues.";
static const char __pyx_k_Request_network_information_from[] = "Request network information from the SUC/SIS.";
static const char __pyx_k_Save_in_RAM_log_messages_equal_t[] = "Save (in RAM) log messages equal to or above LogLevel_Debug.";
static const char __pyx_k_Send_information_from_primary_to[] = "Send information from primary to secondary.";
static const char __pyx_k_Should_we_send_the_Node_Value_No[] = "Should we send the Node/Value Notifications on Driver Unloading - Read comments in Driver::~Driver() method about possible race conditions.";
static const char __pyx_k_Something_unexpected_by_the_libr[] = "Something unexpected by the library about which the controlling application should be aware";
static const char __pyx_k_The_associations_for_the_node_ha[] = "The associations for the node have changed. The application should rebuild any group information it holds about the node.";
static const char __pyx_k_The_command_has_completed_succes[] = "The command has completed successfully.";
static const char __pyx_k_The_level_as_controlled_by_basic[] = "The 'level' as controlled by basic commands.  Usually duplicated by another command class.";
static const char __pyx_k_The_queries_on_a_node_that_are_e[] = "The queries on a node that are essential to its operation have been completed. The node can now handle incoming messages.";
static const char __pyx_k_Used_only_with_ControllerCommand[] = "Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node is OK.";
static const char __pyx_k_Used_only_within_the_log_class_u[] = "Used only within the log class (uses existing timestamp, etc";
static const char __pyx_k_Values_of_significance_only_to_u[] = "Values of significance only to users who understand the Z-Wave protocol";
static const char __pyx_k_Very_detailed_information_on_pro[] = "Very detailed information on progress that will create a huge log file quickly but this level (as others) can be queued and sent to the log only on an error or warning";
static const char __pyx_k_What_List_of_Custom_CC_should_we[] = "What List of Custom CC should we always encrypt if SecurityStrategy is CUSTOM.";
static const char __pyx_k_When_Controller_Commands_are_exe[] = "When Controller Commands are executed, Notifications of Success/Failure etc are communicated via this Notification.";
static const char __pyx_k_Will_include_low_level_byte_tran[] = "Will include low-level byte transfers from controller to buffer to application and back";
static const char __pyx_k_addValueId_GetCommandClassId_s_G[] = "addValueId : GetCommandClassId : %s, GetType : %s";
static const char __pyx_k_notif_callback_Notification_type[] = "notif_callback : Notification type : %s, nodeId : %s";
static const char __pyx_k_notif_callback_call_callback_con[] = "notif_callback : call callback context";
static const char __pyx_k_notif_callback_exception_Type_Co[] = "notif_callback exception Type_ControllerCommand";
static const char __pyx_k_notif_callback_exception_Type_Cr[] = "notif_callback exception Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff";
static const char __pyx_k_notif_callback_exception_Type_Dr[] = "notif_callback exception Type_DriverRemoved";
static const char __pyx_k_notif_callback_exception_Type_Gr[] = "notif_callback exception Type_Group";
static const char __pyx_k_notif_callback_exception_Type_No[] = "notif_callback exception Type_NodeEvent";
static const char __pyx_k_notif_callback_exception_Type_Sc[] = "notif_callback exception Type_SceneEvent";
static const char __pyx_k_notif_callback_exception_Type_Va[] = "notif_callback exception Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed";
static const char __pyx_k_python_openzwave_version_s_s_s_s[] = "python_openzwave version %s (%s-%s / %s - %s)";
static const char __pyx_k_Number_of_messages_successfully_2[] = "Number of messages successfully sent";
static const char __pyx_k_A_node_value_has_been_updated_fr_2[] = "A node value has been updated from the Z-Wave network.";
static const char __pyx_k_COMMAND_CLASS_REMOTE_ASSOCIATION_2[] = "COMMAND_CLASS_REMOTE_ASSOCIATION";
static const char __pyx_k_Handheld_controller_button_event_2[] = "Handheld controller button event deleted.";
static const char __pyx_k_Polling_of_a_node_has_been_succe_2[] = "Polling of a node has been successfully turned on by a call to Manager::EnablePoll.";
static const char __pyx_k_Used_only_with_ControllerCommand_2[] = "Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node has failed.";
static const char __pyx_k_notif_callback_exception_Type_Dr_2[] = "notif_callback exception Type_DriverReset";
static const char __pyx_k_notif_callback_exception_Type_No_2[] = "notif_callback exception Type_Notification";
static const char __pyx_k_notif_callback_exception_Type_Va_2[] = "notif_callback exception Type_ValueRemoved";
static const char __pyx_k_notif_callback_exception_Type_Va_3[] = "notif_callback exception Type_ValueRemoved delete";
static PyObject *__pyx_kp_s_0x62_0x4c_0x63;
static PyObject *__pyx_kp_s_16_bit_signed_value;
static PyObject *__pyx_kp_s_30_seconds_can_easily_poll_30_va;
static PyObject *__pyx_kp_s_32_bit_signed_value;
static PyObject *__pyx_kp_s_8_bit_unsigned_value;
static PyObject *__pyx_n_s_ACKCnt;
static PyObject *__pyx_n_s_ACKWaiting;
static PyObject *__pyx_kp_s_A_driver_for_a_PC_Z_Wave_control;
static PyObject *__pyx_kp_s_A_likely_fatal_issue_in_the_libr;
static PyObject *__pyx_kp_s_A_manager_notification_report;
static PyObject *__pyx_kp_s_A_minor_issue_from_which_the_lib;
static PyObject *__pyx_kp_s_A_new_node_has_been_added_to_Ope;
static PyObject *__pyx_kp_s_A_new_node_has_been_found_not_al;
static PyObject *__pyx_kp_s_A_new_node_value_has_been_added;
static PyObject *__pyx_kp_s_A_node_has_been_removed_from_Ope;
static PyObject *__pyx_kp_s_A_node_has_been_reset_from_OpenZ;
static PyObject *__pyx_kp_s_A_node_has_triggered_an_event_Th;
static PyObject *__pyx_kp_s_A_node_value_has_been_removed_fr;
static PyObject *__pyx_kp_s_A_node_value_has_been_updated_fr;
static PyObject *__pyx_kp_s_A_node_value_has_been_updated_fr_2;
static PyObject *__pyx_kp_s_A_serious_issue_with_the_library;
static PyObject *__pyx_kp_s_A_write_only_value_that_is_the_e;
static PyObject *__pyx_n_s_AddDevice;
static PyObject *__pyx_kp_s_Add_a_new_controller_to_the_Z_Wa;
static PyObject *__pyx_kp_s_Add_a_new_device_but_not_a_contr;
static PyObject *__pyx_n_s_Alert;
static PyObject *__pyx_n_s_Alive;
static PyObject *__pyx_n_s_AllNodesQueried;
static PyObject *__pyx_n_s_AllNodesQueriedSomeDead;
static PyObject *__pyx_kp_s_All_awake_nodes_have_been_querie;
static PyObject *__pyx_kp_s_All_nodes_and_values_for_this_dr;
static PyObject *__pyx_kp_s_All_nodes_have_been_queried_but;
static PyObject *__pyx_kp_s_All_nodes_have_been_queried_so_c;
static PyObject *__pyx_kp_s_All_the_initialisation_queries_o;
static PyObject *__pyx_n_s_Always;
static PyObject *__pyx_n_s_AppendLogFile;
static PyObject *__pyx_kp_s_Append_new_session_logs_to_exist;
static PyObject *__pyx_n_s_AssignReturnRoute;
static PyObject *__pyx_kp_s_Assign_a_network_return_routes_t;
static PyObject *__pyx_n_s_Associate;
static PyObject *__pyx_n_s_Associations;
static PyObject *__pyx_n_s_AssumeAwake;
static PyObject *__pyx_kp_s_Assume_Devices_that_Support_the;
static PyObject *__pyx_n_s_AttributeError;
static PyObject *__pyx_kp_s_Automatically_become_a_SUC_if_th;
static PyObject *__pyx_n_s_Awake;
static PyObject *__pyx_n_s_AwakeNodesQueried;
static PyObject *__pyx_n_s_Basic;
static PyObject *__pyx_kp_s_Basic_node_information_has_been;
static PyObject *__pyx_kp_s_Basic_values_an_ordinary_user_wo;
static PyObject *__pyx_n_s_Bool;
static PyObject *__pyx_kp_s_Boolean;
static PyObject *__pyx_kp_s_Boolean_true_or_false;
static PyObject *__pyx_n_s_Busy;
static PyObject *__pyx_n_s_Button;
static PyObject *__pyx_n_s_ButtonNotFound;
static PyObject *__pyx_n_s_ButtonOff;
static PyObject *__pyx_n_s_ButtonOn;
static PyObject *__pyx_kp_s_Button_2;
static PyObject *__pyx_n_s_Byte;
static PyObject *__pyx_n_s_CALLBACK_DESC;
static PyObject *__pyx_n_s_CANCnt;
static PyObject *__pyx_n_s_COMMAND_CLASS_ACTUATOR_MULTILEVE;
static PyObject *__pyx_n_s_COMMAND_CLASS_ALARM;
static PyObject *__pyx_n_s_COMMAND_CLASS_APPLICATION_STATUS;
static PyObject *__pyx_n_s_COMMAND_CLASS_ASSOCIATION;
static PyObject *__pyx_n_s_COMMAND_CLASS_ASSOCIATION_COMMAN;
static PyObject *__pyx_n_s_COMMAND_CLASS_AV_CONTENT_DIRECTO;
static PyObject *__pyx_n_s_COMMAND_CLASS_AV_CONTENT_SEARCH;
static PyObject *__pyx_n_s_COMMAND_CLASS_AV_RENDERER_STATUS;
static PyObject *__pyx_n_s_COMMAND_CLASS_AV_TAGGING_MD;
static PyObject *__pyx_n_s_COMMAND_CLASS_BARRIER_OPERATOR;
static PyObject *__pyx_n_s_COMMAND_CLASS_BASIC;
static PyObject *__pyx_n_s_COMMAND_CLASS_BASIC_WINDOW_COVER;
static PyObject *__pyx_n_s_COMMAND_CLASS_BATTERY;
static PyObject *__pyx_n_s_COMMAND_CLASS_CENTRAL_SCENE;
static PyObject *__pyx_n_s_COMMAND_CLASS_CHIMNEY_FAN;
static PyObject *__pyx_n_s_COMMAND_CLASS_CLIMATE_CONTROL_SC;
static PyObject *__pyx_n_s_COMMAND_CLASS_CLOCK;
static PyObject *__pyx_n_s_COMMAND_CLASS_COLOR;
static PyObject *__pyx_n_s_COMMAND_CLASS_COMPOSITE;
static PyObject *__pyx_n_s_COMMAND_CLASS_CONFIGURATION;
static PyObject *__pyx_n_s_COMMAND_CLASS_CONTROLLER_REPLICA;
static PyObject *__pyx_n_s_COMMAND_CLASS_CRC_16_ENCAP;
static PyObject *__pyx_n_s_COMMAND_CLASS_DESC;
static PyObject *__pyx_n_s_COMMAND_CLASS_DEVICE_RESET_LOCAL;
static PyObject *__pyx_n_s_COMMAND_CLASS_DISPLAY;
static PyObject *__pyx_n_s_COMMAND_CLASS_DOOR_LOCK;
static PyObject *__pyx_n_s_COMMAND_CLASS_DOOR_LOCK_LOGGING;
static PyObject *__pyx_n_s_COMMAND_CLASS_ENERGY_PRODUCTION;
static PyObject *__pyx_n_s_COMMAND_CLASS_FIRMWARE_UPDATE_MD;
static PyObject *__pyx_n_s_COMMAND_CLASS_GARAGE_DOOR;
static PyObject *__pyx_n_s_COMMAND_CLASS_GEOGRAPHIC_LOCATIO;
static PyObject *__pyx_n_s_COMMAND_CLASS_GROUPING_NAME;
static PyObject *__pyx_n_s_COMMAND_CLASS_HAIL;
static PyObject *__pyx_n_s_COMMAND_CLASS_INDICATOR;
static PyObject *__pyx_n_s_COMMAND_CLASS_IP_CONFIGURATION;
static PyObject *__pyx_n_s_COMMAND_CLASS_KICK;
static PyObject *__pyx_n_s_COMMAND_CLASS_LANGUAGE;
static PyObject *__pyx_n_s_COMMAND_CLASS_LOCK;
static PyObject *__pyx_n_s_COMMAND_CLASS_MANUFACTURER_PROPR;
static PyObject *__pyx_n_s_COMMAND_CLASS_MANUFACTURER_SPECI;
static PyObject *__pyx_n_s_COMMAND_CLASS_MARK;
static PyObject *__pyx_n_s_COMMAND_CLASS_METER;
static PyObject *__pyx_n_s_COMMAND_CLASS_METER_PULSE;
static PyObject *__pyx_n_s_COMMAND_CLASS_METER_TBL_CONFIG;
static PyObject *__pyx_n_s_COMMAND_CLASS_METER_TBL_MONITOR;
static PyObject *__pyx_n_s_COMMAND_CLASS_METER_TBL_PUSH;
static PyObject *__pyx_n_s_COMMAND_CLASS_MTP_WINDOW_COVERIN;
static PyObject *__pyx_n_s_COMMAND_CLASS_MULTI_CHANNEL_ASSO;
static PyObject *__pyx_n_s_COMMAND_CLASS_MULTI_CMD;
static PyObject *__pyx_kp_s_COMMAND_CLASS_MULTI_INSTANCE_CHA;
static PyObject *__pyx_n_s_COMMAND_CLASS_NETWORK_STAT;
static PyObject *__pyx_n_s_COMMAND_CLASS_NODE_NAMING;
static PyObject *__pyx_n_s_COMMAND_CLASS_NON_INTEROPERABLE;
static PyObject *__pyx_n_s_COMMAND_CLASS_NO_OPERATION;
static PyObject *__pyx_n_s_COMMAND_CLASS_POWERLEVEL;
static PyObject *__pyx_n_s_COMMAND_CLASS_PROPRIETARY;
static PyObject *__pyx_n_s_COMMAND_CLASS_PROTECTION;
static PyObject *__pyx_n_s_COMMAND_CLASS_REMOTE_ASSOCIATION;
static PyObject *__pyx_n_s_COMMAND_CLASS_REMOTE_ASSOCIATION_2;
static PyObject *__pyx_n_s_COMMAND_CLASS_SCENE_ACTIVATION;
static PyObject *__pyx_n_s_COMMAND_CLASS_SCENE_ACTUATOR_CON;
static PyObject *__pyx_n_s_COMMAND_CLASS_SCENE_CONTROLLER_C;
static PyObject *__pyx_n_s_COMMAND_CLASS_SCHEDULE_ENTRY_LOC;
static PyObject *__pyx_n_s_COMMAND_CLASS_SCREEN_ATTRIBUTES;
static PyObject *__pyx_n_s_COMMAND_CLASS_SCREEN_MD;
static PyObject *__pyx_n_s_COMMAND_CLASS_SECURITY;
static PyObject *__pyx_n_s_COMMAND_CLASS_SENSOR_ALARM;
static PyObject *__pyx_n_s_COMMAND_CLASS_SENSOR_BINARY;
static PyObject *__pyx_n_s_COMMAND_CLASS_SENSOR_CONFIGURATI;
static PyObject *__pyx_n_s_COMMAND_CLASS_SENSOR_MULTILEVEL;
static PyObject *__pyx_n_s_COMMAND_CLASS_SILENCE_ALARM;
static PyObject *__pyx_n_s_COMMAND_CLASS_SIMPLE_AV_CONTROL;
static PyObject *__pyx_n_s_COMMAND_CLASS_SWITCH_ALL;
static PyObject *__pyx_n_s_COMMAND_CLASS_SWITCH_BINARY;
static PyObject *__pyx_n_s_COMMAND_CLASS_SWITCH_MULTILEVEL;
static PyObject *__pyx_n_s_COMMAND_CLASS_SWITCH_TOGGLE_BINA;
static PyObject *__pyx_n_s_COMMAND_CLASS_SWITCH_TOGGLE_MULT;
static PyObject *__pyx_n_s_COMMAND_CLASS_THERMOSTAT_FAN_MOD;
static PyObject *__pyx_n_s_COMMAND_CLASS_THERMOSTAT_FAN_STA;
static PyObject *__pyx_n_s_COMMAND_CLASS_THERMOSTAT_HEATING;
static PyObject *__pyx_n_s_COMMAND_CLASS_THERMOSTAT_MODE;
static PyObject *__pyx_n_s_COMMAND_CLASS_THERMOSTAT_OPERATI;
static PyObject *__pyx_n_s_COMMAND_CLASS_THERMOSTAT_SETBACK;
static PyObject *__pyx_n_s_COMMAND_CLASS_THERMOSTAT_SETPOIN;
static PyObject *__pyx_n_s_COMMAND_CLASS_TIME;
static PyObject *__pyx_n_s_COMMAND_CLASS_TIME_PARAMETERS;
static PyObject *__pyx_n_s_COMMAND_CLASS_USER_CODE;
static PyObject *__pyx_n_s_COMMAND_CLASS_VERSION;
static PyObject *__pyx_n_s_COMMAND_CLASS_WAKE_UP;
static PyObject *__pyx_n_s_COMMAND_CLASS_ZIP_ADV_CLIENT;
static PyObject *__pyx_n_s_COMMAND_CLASS_ZIP_ADV_SERVICES;
static PyObject *__pyx_n_s_COMMAND_CLASS_ZIP_CLIENT;
static PyObject *__pyx_n_s_COMMAND_CLASS_ZIP_SERVER;
static PyObject *__pyx_n_s_COMMAND_CLASS_ZIP_SERVICES;
static PyObject *__pyx_n_s_COMMAND_CLASS_ZWAVE_PLUS_INFO;
static PyObject *__pyx_n_s_CWD_CONFIG_DIRECTORY;
static PyObject *__pyx_kp_s_Can_t_autoconfigure_path_to_conf;
static PyObject *__pyx_kp_s_Can_t_find_config_directory_s;
static PyObject *__pyx_kp_s_Can_t_find_options_xml_in_s;
static PyObject *__pyx_kp_s_Can_t_find_user_directory_s;
static PyObject *__pyx_kp_s_Can_t_retrieve_zwcfg_xsd_from_s;
static PyObject *__pyx_kp_s_Can_t_write_in_user_directory_s;
static PyObject *__pyx_n_s_Cancel;
static PyObject *__pyx_kp_s_Check_whether_a_node_is_in_the_c;
static PyObject *__pyx_kp_s_Command_invocation_had_error_s_a;
static PyObject *__pyx_n_s_Complete;
static PyObject *__pyx_n_s_Completed;
static PyObject *__pyx_kp_s_Completed_messages;
static PyObject *__pyx_kp_s_Complex_type_used_with_the_Clima;
static PyObject *__pyx_n_s_Config;
static PyObject *__pyx_n_s_ConfigPath;
static PyObject *__pyx_n_s_Configuration;
static PyObject *__pyx_n_s_ConsoleOutput;
static PyObject *__pyx_n_s_ControllerCommand;
static PyObject *__pyx_kp_s_Controller_command_is_on_a_sleep;
static PyObject *__pyx_kp_s_Controller_interface_use_human_i;
static PyObject *__pyx_kp_s_Controller_interface_use_serial;
static PyObject *__pyx_kp_s_Controller_interface_use_unknown;
static PyObject *__pyx_kp_s_Controller_is_waiting_for_a_user;
static PyObject *__pyx_n_s_CreateButton;
static PyObject *__pyx_n_s_CreateNewPrimary;
static PyObject *__pyx_kp_s_CreateNewPrimary_2;
static PyObject *__pyx_kp_s_Create_an_id_that_tracks_handhel;
static PyObject *__pyx_n_s_CustomSecuredCC;
static PyObject *__pyx_n_s_Dead;
static PyObject *__pyx_n_s_Debug;
static PyObject *__pyx_n_s_Decimal;
static PyObject *__pyx_kp_s_Default_is_to_never_dump_RAM_sto;
static PyObject *__pyx_n_s_DeleteAllReturnRoutes;
static PyObject *__pyx_n_s_DeleteButton;
static PyObject *__pyx_kp_s_Delete_all_return_routes_from_a;
static PyObject *__pyx_kp_s_Delete_id_that_tracks_handheld_b;
static PyObject *__pyx_n_s_Detail;
static PyObject *__pyx_kp_s_Detailed_information_on_the_prog;
static PyObject *__pyx_kp_s_Device_specific_configuration_pa;
static PyObject *__pyx_kp_s_Disable_all_logging;
static PyObject *__pyx_n_s_Disabled;
static PyObject *__pyx_kp_s_Display_log_information_on_conso;
static PyObject *__pyx_n_s_DistributionNotFound;
static PyObject *__pyx_n_s_DriverFailed;
static PyObject *__pyx_n_s_DriverMaxAttempts;
static PyObject *__pyx_n_s_DriverReady;
static PyObject *__pyx_n_s_DriverRemoved;
static PyObject *__pyx_n_s_DriverReset;
static PyObject *__pyx_kp_s_Driver_failed_to_load;
static PyObject *__pyx_n_s_DumpTriggerLevel;
static PyObject *__pyx_n_s_Dynamic;
static PyObject *__pyx_n_s_EnableSIS;
static PyObject *__pyx_kp_s_Enable_automatic_association_of;
static PyObject *__pyx_kp_s_Enable_logging_of_library_activi;
static PyObject *__pyx_n_s_EnforceSecureReception;
static PyObject *__pyx_n_s_EnumWithDoc;
static PyObject *__pyx_n_s_EnumWithDocType;
static PyObject *__pyx_n_s_EnumWithDocType_setDocType;
static PyObject *__pyx_n_s_EnumWithDoc_setDoc;
static PyObject *__pyx_kp_s_Enum_helper;
static PyObject *__pyx_n_s_Error;
static PyObject *__pyx_n_s_EssentialNodeQueriesComplete;
static PyObject *__pyx_kp_s_Everything_s_working_fine_these;
static PyObject *__pyx_kp_s_Exception_class_for_LibOpenZWav;
static PyObject *__pyx_n_s_Exclude;
static PyObject *__pyx_n_s_Failed;
static PyObject *__pyx_n_s_Fatal;
static PyObject *__pyx_kp_s_Get_a_node_to_rebuild_its_neighb;
static PyObject *__pyx_n_s_Group;
static PyObject *__pyx_kp_s_Handheld_controller_button_event;
static PyObject *__pyx_kp_s_Handheld_controller_button_event_2;
static PyObject *__pyx_kp_s_Handheld_controller_button_off_p;
static PyObject *__pyx_kp_s_Handheld_controller_button_on_pr;
static PyObject *__pyx_n_s_Handler;
static PyObject *__pyx_n_s_HasNodeFailed;
static PyObject *__pyx_n_s_Hid;
static PyObject *__pyx_kp_s_How_long_do_we_wait_to_timeout_m;
static PyObject *__pyx_kp_s_Identify_the_serial_port_to_be_a;
static PyObject *__pyx_kp_s_If_false_try_to_execute_the_enti;
static PyObject *__pyx_kp_s_If_true_during_startup_we_refres;
static PyObject *__pyx_kp_s_If_true_notifications_for_refres;
static PyObject *__pyx_kp_s_If_true_return_routes_will_be_up;
static PyObject *__pyx_kp_s_If_we_recieve_a_clear_text_messa;
static PyObject *__pyx_n_s_ImportError;
static PyObject *__pyx_n_s_InProgress;
static PyObject *__pyx_n_s_Include;
static PyObject *__pyx_n_s_Info;
static PyObject *__pyx_n_s_Instances;
static PyObject *__pyx_n_s_Int;
static PyObject *__pyx_kp_s_Integer;
static PyObject *__pyx_n_s_Interface;
static PyObject *__pyx_n_s_Internal;
static PyObject *__pyx_n_s_IntervalBetweenPolls;
static PyObject *__pyx_n_s_Invalid;
static PyObject *__pyx_kp_s_Invalid_Log_Status;
static PyObject *__pyx_kp_s_Invalid_type;
static PyObject *__pyx_n_s_IsPrimary;
static PyObject *__pyx_kp_s_Key_used_to_negotiate_and_commun;
static PyObject *__pyx_kp_s_LibOpenZwave_Generic_Exception;
static PyObject *__pyx_n_s_LibZWaveException;
static PyObject *__pyx_n_s_LibZWaveException___init;
static PyObject *__pyx_n_s_LibZWaveException___str;
static PyObject *__pyx_n_s_List;
static PyObject *__pyx_kp_s_List_from_which_one_item_can_be;
static PyObject *__pyx_n_s_LogFileName;
static PyObject *__pyx_n_s_Logging;
static PyObject *__pyx_kp_s_Make_a_different_controller_the;
static PyObject *__pyx_n_s_ManufacturerSpecific1;
static PyObject *__pyx_n_s_ManufacturerSpecific2;
static PyObject *__pyx_kp_s_Messages_that_timeout_will_send;
static PyObject *__pyx_kp_s_Move_a_node_to_the_controller_s;
static PyObject *__pyx_n_s_MsgComplete;
static PyObject *__pyx_n_s_NAKCnt;
static PyObject *__pyx_kp_s_Name_of_the_log_file_can_be_chan;
static PyObject *__pyx_n_s_Neighbors;
static PyObject *__pyx_n_s_NetworkKey;
static PyObject *__pyx_n_s_NoOperation;
static PyObject *__pyx_kp_s_No_command;
static PyObject *__pyx_kp_s_No_command_in_progress;
static PyObject *__pyx_n_s_NodeAdded;
static PyObject *__pyx_n_s_NodeEvent;
static PyObject *__pyx_n_s_NodeFailed;
static PyObject *__pyx_n_s_NodeInfo;
static PyObject *__pyx_n_s_NodeNaming;
static PyObject *__pyx_n_s_NodeNew;
static PyObject *__pyx_n_s_NodeNotFound;
static PyObject *__pyx_n_s_NodeOK;
static PyObject *__pyx_n_s_NodeProtocolInfo;
static PyObject *__pyx_n_s_NodeQueriesComplete;
static PyObject *__pyx_n_s_NodeRemoved;
static PyObject *__pyx_n_s_NodeReset;
static PyObject *__pyx_n_s_None;
static PyObject *__pyx_kp_s_None_2;
static PyObject *__pyx_n_s_Normal;
static PyObject *__pyx_n_s_NotBridge;
static PyObject *__pyx_n_s_NotFound;
static PyObject *__pyx_n_s_NotPrimary;
static PyObject *__pyx_n_s_NotSUC;
static PyObject *__pyx_n_s_NotSecondary;
static PyObject *__pyx_n_s_Notification;
static PyObject *__pyx_kp_s_Notification_Type_DriverRemoved;
static PyObject *__pyx_kp_s_Notification_Type_DriverReset_re;
static PyObject *__pyx_kp_s_Notifications_when_transaction_c;
static PyObject *__pyx_n_s_NotifyOnDriverUnload;
static PyObject *__pyx_n_s_NotifyTransactions;
static PyObject *__pyx_n_s_NullHandler;
static PyObject *__pyx_n_s_NullHandler_emit;
static PyObject *__pyx_kp_s_NullHandler_logger_for_python_2;
static PyObject *__pyx_kp_s_Number_of_ACK_bytes_received;
static PyObject *__pyx_kp_s_Number_of_CAN_bytes_received;
static PyObject *__pyx_kp_s_Number_of_NAK_bytes_received;
static PyObject *__pyx_kp_s_Number_of_SOF_bytes_received;
static PyObject *__pyx_kp_s_Number_of_bad_checksums;
static PyObject *__pyx_kp_s_Number_of_broadcasts_read;
static PyObject *__pyx_kp_s_Number_of_broadcasts_sent;
static PyObject *__pyx_kp_s_Number_of_bytes_out_of_framing;
static PyObject *__pyx_kp_s_Number_of_failed_messages_due_to;
static PyObject *__pyx_kp_s_Number_of_messages_dropped_not_d;
static PyObject *__pyx_kp_s_Number_of_messages_not_delivered;
static PyObject *__pyx_kp_s_Number_of_messages_received_with;
static PyObject *__pyx_kp_s_Number_of_messages_retransmitted;
static PyObject *__pyx_kp_s_Number_of_messages_successfully;
static PyObject *__pyx_kp_s_Number_of_messages_successfully_2;
static PyObject *__pyx_kp_s_Number_of_network_busy_failure_m;
static PyObject *__pyx_kp_s_Number_of_no_ACK_returned_errors;
static PyObject *__pyx_kp_s_Number_of_times_read_were_aborte;
static PyObject *__pyx_kp_s_Number_of_unexpected_callbacks;
static PyObject *__pyx_kp_s_Number_of_unsolicited_messages_w;
static PyObject *__pyx_n_s_OOFCnt;
static PyObject *__pyx_n_s_OZWAVE_CONFIG_DIRECTORY;
static PyObject *__pyx_kp_s_One_of_the_node_names_has_change;
static PyObject *__pyx_kp_s_Only_handle_the_specified_comman;
static PyObject *__pyx_n_s_Overflow;
static PyObject *__pyx_n_s_PY3;
static PyObject *__pyx_n_s_PYLIBRARY;
static PyObject *__pyx_n_s_PY_OZWAVE_CONFIG_DIRECTORY;
static PyObject *__pyx_kp_s_Path_to_the_OpenZWave_config_fol;
static PyObject *__pyx_kp_s_Path_to_the_user_s_data_folder;
static PyObject *__pyx_n_s_PerformReturnRoutes;
static PyObject *__pyx_n_s_PollInterval;
static PyObject *__pyx_n_s_PollingDisabled;
static PyObject *__pyx_n_s_PollingEnabled;
static PyObject *__pyx_kp_s_Polling_of_a_node_has_been_succe;
static PyObject *__pyx_kp_s_Polling_of_a_node_has_been_succe_2;
static PyObject *__pyx_n_s_Probe;
static PyObject *__pyx_n_s_Probe1;
static PyObject *__pyx_n_s_ProtocolInfo;
static PyObject *__pyx_n_s_PyControllerCommand;
static PyObject *__pyx_n_s_PyControllerError;
static PyObject *__pyx_n_s_PyControllerInterface;
static PyObject *__pyx_n_s_PyControllerState;
static PyObject *__pyx_n_s_PyGenres;
static PyObject *__pyx_n_s_PyLogLevels;
static PyObject *__pyx_n_s_PyNotificationCodes;
static PyObject *__pyx_n_s_PyNotifications;
static PyObject *__pyx_n_s_PyOptionList;
static PyObject *__pyx_n_s_PyOptionType;
static PyObject *__pyx_n_s_PyStatDriver;
static PyObject *__pyx_n_s_PyValueTypes;
static PyObject *__pyx_n_s_QueueLogLevel;
static PyObject *__pyx_n_s_R_OK;
static PyObject *__pyx_n_s_Raw;
static PyObject *__pyx_kp_s_Raw_byte_values;
static PyObject *__pyx_n_s_ReceiveConfiguration;
static PyObject *__pyx_kp_s_ReceiveConfiguration_2;
static PyObject *__pyx_kp_s_Receive_Z_Wave_network_configura;
static PyObject *__pyx_n_s_RefreshAllUserCodes;
static PyObject *__pyx_n_s_RemoveDevice;
static PyObject *__pyx_n_s_RemoveFailedNode;
static PyObject *__pyx_kp_s_RemoveFailedNode_2;
static PyObject *__pyx_kp_s_RemoveFailedNode_AddNodeToNetwor;
static PyObject *__pyx_kp_s_RemoveFailedNode_RequestNetworkU;
static PyObject *__pyx_kp_s_Remove_a_new_device_but_not_a_co;
static PyObject *__pyx_kp_s_Remove_support_for_the_listed_co;
static PyObject *__pyx_n_s_ReplaceFailedNode;
static PyObject *__pyx_kp_s_Replace_a_non_responding_node_wi;
static PyObject *__pyx_n_s_ReplicationSend;
static PyObject *__pyx_kp_s_Report_on_NoOperation_message_se;
static PyObject *__pyx_kp_s_Report_when_a_node_goes_to_sleep;
static PyObject *__pyx_kp_s_Report_when_a_node_is_presumed_d;
static PyObject *__pyx_kp_s_Report_when_a_node_is_revived;
static PyObject *__pyx_kp_s_Report_when_a_sleeping_node_wake;
static PyObject *__pyx_kp_s_Represents_a_non_integer_value_a;
static PyObject *__pyx_n_s_RequestNetworkUpdate;
static PyObject *__pyx_kp_s_RequestNetworkUpdate_error;
static PyObject *__pyx_n_s_RequestNodeNeighborUpdate;
static PyObject *__pyx_kp_s_Request_network_information_from;
static PyObject *__pyx_n_s_RetryTimeout;
static PyObject *__pyx_n_s_SOFCnt;
static PyObject *__pyx_n_s_SUPPORTED;
static PyObject *__pyx_n_s_SaveConfiguration;
static PyObject *__pyx_n_s_SaveLogLevel;
static PyObject *__pyx_kp_s_Save_in_RAM_log_messages_equal_t;
static PyObject *__pyx_kp_s_Save_the_XML_configuration_upon;
static PyObject *__pyx_kp_s_Save_to_file_log_messages_equal;
static PyObject *__pyx_n_s_SceneEvent;
static PyObject *__pyx_kp_s_Scene_Activation_Set_received;
static PyObject *__pyx_n_s_Schedule;
static PyObject *__pyx_n_s_SecurityStrategy;
static PyObject *__pyx_n_s_SendNodeInformation;
static PyObject *__pyx_kp_s_Send_a_node_information_frame;
static PyObject *__pyx_kp_s_Send_information_from_primary_to;
static PyObject *__pyx_n_s_Serial;
static PyObject *__pyx_n_s_Session;
static PyObject *__pyx_kp_s_SetValueListSelection_s;
static PyObject *__pyx_n_s_Short;
static PyObject *__pyx_kp_s_Should_we_encrypt_CC_s_that_are;
static PyObject *__pyx_kp_s_Should_we_send_the_Node_Value_No;
static PyObject *__pyx_n_s_Sleep;
static PyObject *__pyx_n_s_Sleeping;
static PyObject *__pyx_kp_s_Something_unexpected_by_the_libr;
static PyObject *__pyx_n_s_Starting;
static PyObject *__pyx_n_s_Static;
static PyObject *__pyx_n_s_StreamDetail;
static PyObject *__pyx_n_s_String;
static PyObject *__pyx_kp_s_String_2;
static PyObject *__pyx_n_s_SuppressValueRefresh;
static PyObject *__pyx_n_s_System;
static PyObject *__pyx_kp_s_Text_string;
static PyObject *__pyx_kp_s_The_Driver_is_being_removed;
static PyObject *__pyx_kp_s_The_associations_for_the_node_ha;
static PyObject *__pyx_kp_s_The_command_has_completed_succes;
static PyObject *__pyx_kp_s_The_command_has_failed;
static PyObject *__pyx_kp_s_The_command_is_starting;
static PyObject *__pyx_kp_s_The_command_was_cancelled;
static PyObject *__pyx_kp_s_The_controller_is_communicating;
static PyObject *__pyx_kp_s_The_level_as_controlled_by_basic;
static PyObject *__pyx_kp_s_The_queries_on_a_node_that_are_e;
static PyObject *__pyx_kp_s_These_messages_should_always_be;
static PyObject *__pyx_n_s_Timeout;
static PyObject *__pyx_n_s_TransferPrimaryRole;
static PyObject *__pyx_n_s_Unknown;
static PyObject *__pyx_kp_s_Used_only_with_ControllerCommand;
static PyObject *__pyx_kp_s_Used_only_with_ControllerCommand_2;
static PyObject *__pyx_kp_s_Used_only_within_the_log_class_u;
static PyObject *__pyx_n_s_User;
static PyObject *__pyx_n_s_UserPath;
static PyObject *__pyx_n_s_ValueAdded;
static PyObject *__pyx_n_s_ValueChanged;
static PyObject *__pyx_n_s_ValueError;
static PyObject *__pyx_n_s_ValueRefreshed;
static PyObject *__pyx_n_s_ValueRemoved;
static PyObject *__pyx_kp_s_Values_of_significance_only_to_u;
static PyObject *__pyx_n_s_Versions;
static PyObject *__pyx_kp_s_Very_detailed_information_on_pro;
static PyObject *__pyx_n_s_W_OK;
static PyObject *__pyx_n_s_Waiting;
static PyObject *__pyx_n_s_WakeUp;
static PyObject *__pyx_n_s_Warning;
static PyObject *__pyx_kp_s_What_List_of_Custom_CC_should_we;
static PyObject *__pyx_kp_s_When_Controller_Commands_are_exe;
static PyObject *__pyx_kp_s_Will_include_low_level_byte_tran;
static PyObject *__pyx_kp_s__29;
static PyObject *__pyx_kp_s__5;
static PyObject *__pyx_kp_s__6;
static PyObject *__pyx_n_s_a;
static PyObject *__pyx_n_s_abspath;
static PyObject *__pyx_n_s_access;
static PyObject *__pyx_n_s_addHandler;
static PyObject *__pyx_n_s_addOptionBool;
static PyObject *__pyx_n_s_addOptionInt;
static PyObject *__pyx_n_s_addOptionString;
static PyObject *__pyx_kp_s_addValueId_GetCommandClassId_s_G;
static PyObject *__pyx_kp_s_addValueId_Notification_s;
static PyObject *__pyx_kp_s_addValueId_ValueID_s;
static PyObject *__pyx_kp_s_all_nodes_queried;
static PyObject *__pyx_n_s_append;
static PyObject *__pyx_n_s_arg;
static PyObject *__pyx_n_s_averageRequestRTT;
static PyObject *__pyx_n_s_averageResponseRTT;
static PyObject *__pyx_kp_s_awake_nodes_queried;
static PyObject *__pyx_n_s_b;
static PyObject *__pyx_n_s_bIntervalBetweenPolls;
static PyObject *__pyx_n_s_badChecksum;
static PyObject *__pyx_n_s_badroutes;
static PyObject *__pyx_n_s_broadcastReadCnt;
static PyObject *__pyx_n_s_broadcastWriteCnt;
static PyObject *__pyx_n_s_buttonId;
static PyObject *__pyx_n_s_buttonid;
static PyObject *__pyx_n_s_c;
static PyObject *__pyx_kp_s_call_to_AddWatcher_failed;
static PyObject *__pyx_kp_s_call_to_RemoveWatcher_failed;
static PyObject *__pyx_n_s_callbacks;
static PyObject *__pyx_n_s_ccData;
static PyObject *__pyx_n_s_chr;
static PyObject *__pyx_n_s_className;
static PyObject *__pyx_n_s_classVersion;
static PyObject *__pyx_n_s_cmd_line;
static PyObject *__pyx_n_s_command;
static PyObject *__pyx_n_s_commandClass;
static PyObject *__pyx_n_s_commandClassId;
static PyObject *__pyx_n_s_config;
static PyObject *__pyx_n_s_configPath;
static PyObject *__pyx_n_s_config_path;
static PyObject *__pyx_n_s_controllerError;
static PyObject *__pyx_n_s_controllerErrorDoc;
static PyObject *__pyx_n_s_controllerErrorInt;
static PyObject *__pyx_n_s_controllerState;
static PyObject *__pyx_n_s_controllerStateDoc;
static PyObject *__pyx_n_s_controllerStateInt;
static PyObject *__pyx_n_s_copyfile;
static PyObject *__pyx_n_s_count;
static PyObject *__pyx_n_s_create;
static PyObject *__pyx_kp_s_ctrl_callback_Message_s;
static PyObject *__pyx_n_s_debug;
static PyObject *__pyx_n_s_decode;
static PyObject *__pyx_kp_s_delValueId_ValueID_s;
static PyObject *__pyx_kp_s_device_classes_xml;
static PyObject *__pyx_n_s_dirn;
static PyObject *__pyx_n_s_dirname;
static PyObject *__pyx_n_s_dist;
static PyObject *__pyx_n_s_doSecurity;
static PyObject *__pyx_n_s_doc;
static PyObject *__pyx_n_s_doc_2;
static PyObject *__pyx_kp_s_driver_ready;
static PyObject *__pyx_kp_s_driver_reset;
static PyObject *__pyx_n_s_dropped;
static PyObject *__pyx_n_s_emit;
static PyObject *__pyx_n_s_encode;
static PyObject *__pyx_n_s_error;
static PyObject *__pyx_n_s_error_msg;
static PyObject *__pyx_kp_s_etc_openzwave;
static PyObject *__pyx_n_s_event;
static PyObject *__pyx_n_s_exception;
static PyObject *__pyx_n_s_exists;
static PyObject *__pyx_n_s_file;
static PyObject *__pyx_n_s_genre;
static PyObject *__pyx_n_s_getAssociationsInstances;
static PyObject *__pyx_n_s_getConfigPath;
static PyObject *__pyx_n_s_getLogger;
static PyObject *__pyx_n_s_getOptionAsBool;
static PyObject *__pyx_n_s_getOptionAsInt;
static PyObject *__pyx_n_s_getOptionAsString;
static PyObject *__pyx_kp_s_getValueFromType_return_s;
static PyObject *__pyx_n_s_get_distribution;
static PyObject *__pyx_n_s_getcwd;
static PyObject *__pyx_n_s_groupIdx;
static PyObject *__pyx_n_s_groupidx;
static PyObject *__pyx_kp_s_groups_changed;
static PyObject *__pyx_n_s_help;
static PyObject *__pyx_n_s_highPower;
static PyObject *__pyx_n_s_homeId;
static PyObject *__pyx_kp_s_home_sebastien_devel_python_ope;
static PyObject *__pyx_n_s_homeid;
static PyObject *__pyx_n_s_hours;
static PyObject *__pyx_n_s_id;
static PyObject *__pyx_n_s_idx;
static PyObject *__pyx_n_s_import;
static PyObject *__pyx_n_s_index;
static PyObject *__pyx_n_s_init;
static PyObject *__pyx_kp_s_init___py;
static PyObject *__pyx_n_s_instance;
static PyObject *__pyx_n_s_intensity;
static PyObject *__pyx_n_s_isdir;
static PyObject *__pyx_n_s_isfile;
static PyObject *__pyx_n_s_join;
static PyObject *__pyx_n_s_label;
static PyObject *__pyx_n_s_lastReceivedMessage;
static PyObject *__pyx_n_s_lastRequestRTT;
static PyObject *__pyx_n_s_lastResponseRTT;
static PyObject *__pyx_n_s_level;
static PyObject *__pyx_n_s_libopenzwave;
static PyObject *__pyx_n_s_libopenzwave_file;
static PyObject *__pyx_n_s_libopenzwave_location;
static PyObject *__pyx_n_s_location;
static PyObject *__pyx_n_s_logger;
static PyObject *__pyx_n_s_logging;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_n_s_manufacturerName;
static PyObject *__pyx_n_s_message;
static PyObject *__pyx_kp_s_message_complete;
static PyObject *__pyx_n_s_metaclass;
static PyObject *__pyx_n_s_milliseconds;
static PyObject *__pyx_n_s_minutes;
static PyObject *__pyx_n_s_module;
static PyObject *__pyx_n_s_msg;
static PyObject *__pyx_n_s_name;
static PyObject *__pyx_n_s_netbusy;
static PyObject *__pyx_kp_s_new_node;
static PyObject *__pyx_n_s_noack;
static PyObject *__pyx_n_s_nodeId;
static PyObject *__pyx_kp_s_node_added;
static PyObject *__pyx_kp_s_node_event;
static PyObject *__pyx_kp_s_node_naming;
static PyObject *__pyx_kp_s_node_protocol_info;
static PyObject *__pyx_kp_s_node_queries_complete;
static PyObject *__pyx_kp_s_node_removed;
static PyObject *__pyx_n_s_nodeid;
static PyObject *__pyx_n_s_nondelivery;
static PyObject *__pyx_n_s_not_installed;
static PyObject *__pyx_kp_s_notif_callback_Notification_type;
static PyObject *__pyx_kp_s_notif_callback_call_callback_con;
static PyObject *__pyx_kp_s_notif_callback_end;
static PyObject *__pyx_kp_s_notif_callback_exception;
static PyObject *__pyx_kp_s_notif_callback_exception_Type_Co;
static PyObject *__pyx_kp_s_notif_callback_exception_Type_Cr;
static PyObject *__pyx_kp_s_notif_callback_exception_Type_Dr;
static PyObject *__pyx_kp_s_notif_callback_exception_Type_Dr_2;
static PyObject *__pyx_kp_s_notif_callback_exception_Type_Gr;
static PyObject *__pyx_kp_s_notif_callback_exception_Type_No;
static PyObject *__pyx_kp_s_notif_callback_exception_Type_No_2;
static PyObject *__pyx_kp_s_notif_callback_exception_Type_Sc;
static PyObject *__pyx_kp_s_notif_callback_exception_Type_Va;
static PyObject *__pyx_kp_s_notif_callback_exception_Type_Va_2;
static PyObject *__pyx_kp_s_notif_callback_exception_Type_Va_3;
static PyObject *__pyx_kp_s_notif_callback_new_notification;
static PyObject *__pyx_n_s_notificationCode;
static PyObject *__pyx_n_s_notificationType;
static PyObject *__pyx_kp_s_openzwave_config;
static PyObject *__pyx_kp_s_options_xml;
static PyObject *__pyx_n_s_os;
static PyObject *__pyx_n_s_param;
static PyObject *__pyx_n_s_path;
static PyObject *__pyx_n_s_pkg_resources;
static PyObject *__pyx_kp_s_polling_disabled;
static PyObject *__pyx_kp_s_polling_enabled;
static PyObject *__pyx_n_s_prepare;
static PyObject *__pyx_n_s_productName;
static PyObject *__pyx_kp_s_python_openzwave_ozw_config;
static PyObject *__pyx_kp_s_python_openzwave_version_s_s_s_s;
static PyObject *__pyx_n_s_pythonfunc;
static PyObject *__pyx_n_s_quality;
static PyObject *__pyx_n_s_qualname;
static PyObject *__pyx_n_s_range;
static PyObject *__pyx_n_s_readAborts;
static PyObject *__pyx_n_s_readCnt;
static PyObject *__pyx_n_s_readOnly;
static PyObject *__pyx_n_s_receivedCnt;
static PyObject *__pyx_n_s_receivedDups;
static PyObject *__pyx_n_s_receivedTS;
static PyObject *__pyx_n_s_receivedUnsolicited;
static PyObject *__pyx_n_s_record;
static PyObject *__pyx_n_s_resource_filename;
static PyObject *__pyx_n_s_retries;
static PyObject *__pyx_n_s_routedbusy;
static PyObject *__pyx_n_s_sceneId;
static PyObject *__pyx_n_s_sceneid;
static PyObject *__pyx_n_s_self;
static PyObject *__pyx_n_s_sentCnt;
static PyObject *__pyx_n_s_sentFailed;
static PyObject *__pyx_n_s_sentTS;
static PyObject *__pyx_n_s_setDoc;
static PyObject *__pyx_n_s_setDocType;
static PyObject *__pyx_n_s_setback;
static PyObject *__pyx_kp_s_share_openzwave_config;
static PyObject *__pyx_n_s_shutil;
static PyObject *__pyx_n_s_six;
static PyObject *__pyx_n_s_siz;
static PyObject *__pyx_n_s_size;
static PyObject *__pyx_n_s_state;
static PyObject *__pyx_n_s_str;
static PyObject *__pyx_n_s_stype;
static PyObject *__pyx_n_s_sys;
static PyObject *__pyx_n_s_targetnodeid;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_n_s_type;
static PyObject *__pyx_n_s_unit;
static PyObject *__pyx_n_s_units;
static PyObject *__pyx_n_s_upNodeRoute;
static PyObject *__pyx_n_s_user_path;
static PyObject *__pyx_kp_s_usr;
static PyObject *__pyx_kp_s_usr_local;
static PyObject *__pyx_kp_s_usr_local_etc_openzwave;
static PyObject *__pyx_kp_s_utf_8;
static PyObject *__pyx_n_s_value;
static PyObject *__pyx_n_s_valueId;
static PyObject *__pyx_kp_s_value_added;
static PyObject *__pyx_kp_s_value_changed;
static PyObject *__pyx_kp_s_value_removed;
static PyObject *__pyx_n_s_verify;
static PyObject *__pyx_n_s_version;
static PyObject *__pyx_n_s_warning;
static PyObject *__pyx_n_s_warnings;
static PyObject *__pyx_n_s_writeCnt;
static PyObject *__pyx_kp_s_zwcfg_xsd;
static PyObject *__pyx_pf_12libopenzwave_11NullHandler_emit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_record); /* proto */
static PyObject *__pyx_pf_12libopenzwave_17LibZWaveException___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_12libopenzwave_17LibZWaveException_2__str__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_11EnumWithDoc_setDoc(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_doc); /* proto */
static PyObject *__pyx_pf_12libopenzwave_15EnumWithDocType_setDocType(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_doc, PyObject *__pyx_v_stype); /* proto */
static PyObject *__pyx_pf_12libopenzwave_driverData(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_2configPath(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static int __pyx_pf_12libopenzwave_9PyOptions___init__(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_config_path, PyObject *__pyx_v_user_path, PyObject *__pyx_v_cmd_line); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyOptions_2create(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyOptions_4destroy(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyOptions_6lock(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyOptions_8areLocked(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyOptions_10addOptionBool(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyOptions_12addOptionInt(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyOptions_14addOptionString(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name, PyObject *__pyx_v_value, PyObject *__pyx_v_append); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyOptions_16addOption(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyOptions_18getOption(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyOptions_20getOptionAsBool(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyOptions_22getOptionAsInt(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyOptions_24getOptionAsString(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyOptions_26getConfigPath(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self); /* proto */
static int __pyx_pf_12libopenzwave_8RetAlloc___cinit__(struct __pyx_obj_12libopenzwave_RetAlloc *__pyx_v_self, uint32_t __pyx_v_siz); /* proto */
static void __pyx_pf_12libopenzwave_8RetAlloc_2__dealloc__(struct __pyx_obj_12libopenzwave_RetAlloc *__pyx_v_self); /* proto */
static int __pyx_pf_12libopenzwave_24InstanceAssociationAlloc___cinit__(struct __pyx_obj_12libopenzwave_InstanceAssociationAlloc *__pyx_v_self, uint32_t __pyx_v_siz); /* proto */
static void __pyx_pf_12libopenzwave_24InstanceAssociationAlloc_2__dealloc__(struct __pyx_obj_12libopenzwave_InstanceAssociationAlloc *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_create(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_2destroy(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_4writeConfig(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_6addDriver(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_serialport); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_8removeDriver(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_serialport); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_10getControllerInterfaceType(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_12getControllerPath(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_14getControllerNodeId(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_16getSUCNodeId(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_18isPrimaryController(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_20isStaticUpdateController(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_22isBridgeController(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_24getLibraryVersion(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_26getPythonLibraryVersion(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_28getPythonLibraryVersionNumber(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_30getOzwLibraryVersion(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_32getOzwLibraryLongVersion(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_34getOzwLibraryVersionNumber(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_36getLibraryTypeName(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_38getSendQueueCount(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_40logDriverStatistics(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_42getDriverStatistics(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_44testNetworkNode(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_count); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_46testNetwork(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_count); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_48healNetworkNode(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_upNodeRoute); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_50healNetwork(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_upNodeRoute); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_52getPollInterval(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_54setPollInterval(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_milliseconds, PyObject *__pyx_v_bIntervalBetweenPolls); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_56enablePoll(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_intensity); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_58disablePoll(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_60isPolled(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_62getPollIntensity(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_64setPollIntensity(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_intensity); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_66getNodeStatistics(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_68requestNodeDynamic(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_70refreshNodeInfo(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_72requestNodeState(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_74isNodeBeamingDevice(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_76isNodeListeningDevice(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_78isNodeFrequentListeningDevice(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_80isNodeSecurityDevice(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_82isNodeRoutingDevice(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_84getNodeMaxBaudRate(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_86getNodeVersion(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_88getNodeSecurity(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_90getNodeBasic(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_92getNodeGeneric(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_94getNodeSpecific(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_96getNodeType(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_98getNodeNeighbors(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_100getNodeManufacturerName(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_102getNodeProductName(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_104getNodeName(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_106getNodeLocation(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_108getNodeManufacturerId(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_110getNodeProductType(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_112getNodeProductId(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_114setNodeManufacturerName(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_manufacturerName); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_116setNodeProductName(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_productName); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_118setNodeName(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_name); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_120setNodeLocation(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_location); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_122setNodeOn(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_124setNodeOff(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_126setNodeLevel(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_level); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_128isNodeInfoReceived(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_130getNodeRole(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_132getNodeRoleString(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_134getNodeDeviceType(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_136getNodeDeviceTypeString(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_138getNodePlusType(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_140getNodePlusTypeString(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_142getNodeClassInformation(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_commandClassId, CYTHON_UNUSED PyObject *__pyx_v_className, CYTHON_UNUSED PyObject *__pyx_v_classVersion); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_144isNodeAwake(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_146isNodeFailed(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_148isNodeZWavePlus(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_150getNodeQueryStage(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_152getNodeQueryStageCode(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_queryStage); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_154setValue(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_156refreshValue(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_158getValueLabel(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_160setValueLabel(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_label); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_162getValueUnits(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_164setValueUnits(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_unit); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_166getValueHelp(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_168setValueHelp(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_help); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_170getValueMin(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_172getValueMax(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_174isValueReadOnly(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_176isValueWriteOnly(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_178isValueSet(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_180isValuePolled(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_182getValueGenre(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_184getValueCommandClass(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_186getValueInstance(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_188getValueIndex(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_190getValueType(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_192getValue(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_194getValueAsBool(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_196getValueAsByte(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_198getValueAsFloat(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_200getValueAsShort(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_202getValueAsInt(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_204getValueAsString(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_206getValueAsRaw(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_208getValueListSelectionStr(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_210getValueListSelectionNum(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_212getValueListItems(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_214getValueListValues(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_216pressButton(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_218releaseButton(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_220getValueFloatPrecision(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_222getChangeVerified(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_224setChangeVerified(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_verify); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_226setSwitchPoint(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_hours, PyObject *__pyx_v_minutes, PyObject *__pyx_v_setback); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_228removeSwitchPoint(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_hours, PyObject *__pyx_v_minutes); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_230clearSwitchPoints(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_232getSwitchPoint(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_idx, CYTHON_UNUSED PyObject *__pyx_v_hours, CYTHON_UNUSED PyObject *__pyx_v_minutes, CYTHON_UNUSED PyObject *__pyx_v_setback); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_234getNumSwitchPoints(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_236switchAllOn(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_238switchAllOff(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_240setConfigParam(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_param, PyObject *__pyx_v_value, PyObject *__pyx_v_size); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_242requestConfigParam(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_param); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_244requestAllConfigParams(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_246getNumGroups(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_248getAssociations(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_groupidx); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_250getAssociationsInstances(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_groupidx); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_252getMaxAssociations(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_groupidx); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_254getGroupLabel(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_groupidx); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_256addAssociation(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_groupidx, PyObject *__pyx_v_targetnodeid, PyObject *__pyx_v_instance); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_258removeAssociation(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_groupidx, PyObject *__pyx_v_targetnodeid, PyObject *__pyx_v_instance); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_260addWatcher(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_pythonfunc); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_262removeWatcher(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_pythonfunc); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_264resetController(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_266softResetController(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_268cancelControllerCommand(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_270beginControllerCommand(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_command, PyObject *__pyx_v_pythonfunc, PyObject *__pyx_v_highPower, PyObject *__pyx_v_nodeId, PyObject *__pyx_v_arg); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_272createNewPrimary(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_274transferPrimaryRole(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_276receiveConfiguration(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_278addNode(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_doSecurity); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_280removeNode(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_282removeFailedNode(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_284hasNodeFailed(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_286requestNodeNeighborUpdate(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_288assignReturnRoute(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_290deleteAllReturnRoutes(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_292sendNodeInformation(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_294replaceFailedNode(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_296requestNetworkUpdate(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_298replicationSend(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_300createButton(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_buttonid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_302deleteButton(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_buttonid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_304getNumScenes(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_306getAllScenes(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_308removeAllScenes(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_310removeScene(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_sceneId); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_312createScene(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_314sceneGetValues(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, uint8_t __pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_316addSceneValue(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, uint8_t __pyx_v_sceneid, PyObject *__pyx_v_id, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_318removeSceneValue(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, uint8_t __pyx_v_sceneid, PyObject *__pyx_v_id); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_320setSceneValue(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, uint8_t __pyx_v_sceneid, PyObject *__pyx_v_id, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_322getSceneLabel(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_sceneid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_324setSceneLabel(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_sceneid, PyObject *__pyx_v_label); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_326sceneExists(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_sceneid); /* proto */
static PyObject *__pyx_pf_12libopenzwave_9PyManager_328activateScene(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_sceneid); /* proto */
static PyObject *__pyx_tp_new_12libopenzwave_PyOptions(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_12libopenzwave_RetAlloc(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_12libopenzwave_InstanceAssociationAlloc(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_12libopenzwave_PyManager(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_int_0;
static PyObject *__pyx_int_1;
static PyObject *__pyx_int_2;
static PyObject *__pyx_int_3;
static PyObject *__pyx_int_4;
static PyObject *__pyx_int_5;
static PyObject *__pyx_int_6;
static PyObject *__pyx_int_7;
static PyObject *__pyx_int_8;
static PyObject *__pyx_int_9;
static PyObject *__pyx_int_10;
static PyObject *__pyx_int_11;
static PyObject *__pyx_int_12;
static PyObject *__pyx_int_13;
static PyObject *__pyx_int_14;
static PyObject *__pyx_int_15;
static PyObject *__pyx_int_16;
static PyObject *__pyx_int_32;
static PyObject *__pyx_int_33;
static PyObject *__pyx_int_34;
static PyObject *__pyx_int_35;
static PyObject *__pyx_int_36;
static PyObject *__pyx_int_37;
static PyObject *__pyx_int_38;
static PyObject *__pyx_int_39;
static PyObject *__pyx_int_40;
static PyObject *__pyx_int_41;
static PyObject *__pyx_int_42;
static PyObject *__pyx_int_43;
static PyObject *__pyx_int_44;
static PyObject *__pyx_int_45;
static PyObject *__pyx_int_46;
static PyObject *__pyx_int_47;
static PyObject *__pyx_int_48;
static PyObject *__pyx_int_49;
static PyObject *__pyx_int_50;
static PyObject *__pyx_int_51;
static PyObject *__pyx_int_52;
static PyObject *__pyx_int_53;
static PyObject *__pyx_int_56;
static PyObject *__pyx_int_60;
static PyObject *__pyx_int_61;
static PyObject *__pyx_int_62;
static PyObject *__pyx_int_64;
static PyObject *__pyx_int_66;
static PyObject *__pyx_int_67;
static PyObject *__pyx_int_68;
static PyObject *__pyx_int_69;
static PyObject *__pyx_int_70;
static PyObject *__pyx_int_71;
static PyObject *__pyx_int_76;
static PyObject *__pyx_int_78;
static PyObject *__pyx_int_80;
static PyObject *__pyx_int_81;
static PyObject *__pyx_int_86;
static PyObject *__pyx_int_90;
static PyObject *__pyx_int_91;
static PyObject *__pyx_int_94;
static PyObject *__pyx_int_96;
static PyObject *__pyx_int_97;
static PyObject *__pyx_int_98;
static PyObject *__pyx_int_99;
static PyObject *__pyx_int_100;
static PyObject *__pyx_int_102;
static PyObject *__pyx_int_112;
static PyObject *__pyx_int_113;
static PyObject *__pyx_int_114;
static PyObject *__pyx_int_115;
static PyObject *__pyx_int_117;
static PyObject *__pyx_int_118;
static PyObject *__pyx_int_119;
static PyObject *__pyx_int_120;
static PyObject *__pyx_int_121;
static PyObject *__pyx_int_122;
static PyObject *__pyx_int_123;
static PyObject *__pyx_int_124;
static PyObject *__pyx_int_125;
static PyObject *__pyx_int_128;
static PyObject *__pyx_int_129;
static PyObject *__pyx_int_130;
static PyObject *__pyx_int_131;
static PyObject *__pyx_int_132;
static PyObject *__pyx_int_133;
static PyObject *__pyx_int_134;
static PyObject *__pyx_int_135;
static PyObject *__pyx_int_136;
static PyObject *__pyx_int_137;
static PyObject *__pyx_int_138;
static PyObject *__pyx_int_139;
static PyObject *__pyx_int_140;
static PyObject *__pyx_int_141;
static PyObject *__pyx_int_142;
static PyObject *__pyx_int_143;
static PyObject *__pyx_int_144;
static PyObject *__pyx_int_145;
static PyObject *__pyx_int_146;
static PyObject *__pyx_int_147;
static PyObject *__pyx_int_148;
static PyObject *__pyx_int_149;
static PyObject *__pyx_int_150;
static PyObject *__pyx_int_151;
static PyObject *__pyx_int_152;
static PyObject *__pyx_int_153;
static PyObject *__pyx_int_154;
static PyObject *__pyx_int_155;
static PyObject *__pyx_int_156;
static PyObject *__pyx_int_157;
static PyObject *__pyx_int_158;
static PyObject *__pyx_int_239;
static PyObject *__pyx_int_240;
static PyObject *__pyx_int_255;
static PyObject *__pyx_tuple_;
static PyObject *__pyx_tuple__2;
static PyObject *__pyx_tuple__3;
static PyObject *__pyx_tuple__4;
static PyObject *__pyx_tuple__7;
static PyObject *__pyx_tuple__8;
static PyObject *__pyx_tuple__9;
static PyObject *__pyx_tuple__10;
static PyObject *__pyx_tuple__11;
static PyObject *__pyx_tuple__12;
static PyObject *__pyx_tuple__13;
static PyObject *__pyx_tuple__14;
static PyObject *__pyx_tuple__15;
static PyObject *__pyx_tuple__16;
static PyObject *__pyx_tuple__17;
static PyObject *__pyx_tuple__18;
static PyObject *__pyx_tuple__19;
static PyObject *__pyx_tuple__20;
static PyObject *__pyx_tuple__21;
static PyObject *__pyx_tuple__22;
static PyObject *__pyx_tuple__23;
static PyObject *__pyx_tuple__24;
static PyObject *__pyx_tuple__25;
static PyObject *__pyx_tuple__26;
static PyObject *__pyx_tuple__27;
static PyObject *__pyx_tuple__28;
static PyObject *__pyx_tuple__30;
static PyObject *__pyx_tuple__31;
static PyObject *__pyx_tuple__32;
static PyObject *__pyx_tuple__33;
static PyObject *__pyx_tuple__35;
static PyObject *__pyx_tuple__36;
static PyObject *__pyx_tuple__37;
static PyObject *__pyx_tuple__38;
static PyObject *__pyx_tuple__40;
static PyObject *__pyx_tuple__42;
static PyObject *__pyx_tuple__44;
static PyObject *__pyx_tuple__45;
static PyObject *__pyx_tuple__46;
static PyObject *__pyx_tuple__47;
static PyObject *__pyx_tuple__48;
static PyObject *__pyx_tuple__49;
static PyObject *__pyx_tuple__50;
static PyObject *__pyx_tuple__51;
static PyObject *__pyx_tuple__52;
static PyObject *__pyx_tuple__53;
static PyObject *__pyx_tuple__54;
static PyObject *__pyx_tuple__55;
static PyObject *__pyx_tuple__56;
static PyObject *__pyx_tuple__57;
static PyObject *__pyx_tuple__58;
static PyObject *__pyx_tuple__59;
static PyObject *__pyx_tuple__60;
static PyObject *__pyx_tuple__61;
static PyObject *__pyx_tuple__62;
static PyObject *__pyx_tuple__63;
static PyObject *__pyx_tuple__64;
static PyObject *__pyx_tuple__65;
static PyObject *__pyx_tuple__66;
static PyObject *__pyx_tuple__67;
static PyObject *__pyx_tuple__68;
static PyObject *__pyx_tuple__69;
static PyObject *__pyx_tuple__70;
static PyObject *__pyx_tuple__71;
static PyObject *__pyx_tuple__72;
static PyObject *__pyx_tuple__73;
static PyObject *__pyx_tuple__74;
static PyObject *__pyx_tuple__75;
static PyObject *__pyx_tuple__76;
static PyObject *__pyx_tuple__77;
static PyObject *__pyx_tuple__78;
static PyObject *__pyx_tuple__79;
static PyObject *__pyx_tuple__80;
static PyObject *__pyx_tuple__81;
static PyObject *__pyx_tuple__82;
static PyObject *__pyx_tuple__83;
static PyObject *__pyx_tuple__84;
static PyObject *__pyx_tuple__85;
static PyObject *__pyx_tuple__86;
static PyObject *__pyx_tuple__87;
static PyObject *__pyx_tuple__88;
static PyObject *__pyx_tuple__89;
static PyObject *__pyx_tuple__90;
static PyObject *__pyx_tuple__91;
static PyObject *__pyx_tuple__92;
static PyObject *__pyx_tuple__93;
static PyObject *__pyx_tuple__94;
static PyObject *__pyx_tuple__95;
static PyObject *__pyx_tuple__96;
static PyObject *__pyx_tuple__97;
static PyObject *__pyx_tuple__98;
static PyObject *__pyx_tuple__99;
static PyObject *__pyx_tuple__100;
static PyObject *__pyx_tuple__101;
static PyObject *__pyx_tuple__102;
static PyObject *__pyx_tuple__103;
static PyObject *__pyx_tuple__104;
static PyObject *__pyx_tuple__105;
static PyObject *__pyx_tuple__106;
static PyObject *__pyx_tuple__107;
static PyObject *__pyx_tuple__108;
static PyObject *__pyx_tuple__109;
static PyObject *__pyx_tuple__110;
static PyObject *__pyx_tuple__111;
static PyObject *__pyx_tuple__112;
static PyObject *__pyx_tuple__113;
static PyObject *__pyx_tuple__114;
static PyObject *__pyx_tuple__115;
static PyObject *__pyx_tuple__116;
static PyObject *__pyx_tuple__117;
static PyObject *__pyx_tuple__118;
static PyObject *__pyx_tuple__119;
static PyObject *__pyx_tuple__120;
static PyObject *__pyx_tuple__121;
static PyObject *__pyx_tuple__122;
static PyObject *__pyx_tuple__123;
static PyObject *__pyx_tuple__124;
static PyObject *__pyx_tuple__125;
static PyObject *__pyx_tuple__126;
static PyObject *__pyx_tuple__127;
static PyObject *__pyx_tuple__128;
static PyObject *__pyx_tuple__129;
static PyObject *__pyx_tuple__130;
static PyObject *__pyx_tuple__131;
static PyObject *__pyx_tuple__132;
static PyObject *__pyx_tuple__133;
static PyObject *__pyx_tuple__134;
static PyObject *__pyx_tuple__135;
static PyObject *__pyx_tuple__136;
static PyObject *__pyx_tuple__137;
static PyObject *__pyx_tuple__138;
static PyObject *__pyx_tuple__139;
static PyObject *__pyx_tuple__140;
static PyObject *__pyx_tuple__141;
static PyObject *__pyx_tuple__142;
static PyObject *__pyx_tuple__143;
static PyObject *__pyx_tuple__144;
static PyObject *__pyx_tuple__145;
static PyObject *__pyx_tuple__146;
static PyObject *__pyx_tuple__147;
static PyObject *__pyx_tuple__148;
static PyObject *__pyx_tuple__149;
static PyObject *__pyx_tuple__150;
static PyObject *__pyx_tuple__151;
static PyObject *__pyx_tuple__152;
static PyObject *__pyx_tuple__153;
static PyObject *__pyx_tuple__154;
static PyObject *__pyx_tuple__155;
static PyObject *__pyx_tuple__156;
static PyObject *__pyx_tuple__157;
static PyObject *__pyx_tuple__158;
static PyObject *__pyx_tuple__159;
static PyObject *__pyx_tuple__160;
static PyObject *__pyx_tuple__161;
static PyObject *__pyx_tuple__162;
static PyObject *__pyx_tuple__163;
static PyObject *__pyx_tuple__164;
static PyObject *__pyx_tuple__165;
static PyObject *__pyx_tuple__166;
static PyObject *__pyx_tuple__167;
static PyObject *__pyx_tuple__168;
static PyObject *__pyx_tuple__169;
static PyObject *__pyx_tuple__170;
static PyObject *__pyx_tuple__171;
static PyObject *__pyx_tuple__172;
static PyObject *__pyx_tuple__173;
static PyObject *__pyx_tuple__174;
static PyObject *__pyx_tuple__175;
static PyObject *__pyx_tuple__176;
static PyObject *__pyx_tuple__177;
static PyObject *__pyx_tuple__178;
static PyObject *__pyx_tuple__179;
static PyObject *__pyx_tuple__180;
static PyObject *__pyx_tuple__181;
static PyObject *__pyx_tuple__182;
static PyObject *__pyx_tuple__183;
static PyObject *__pyx_tuple__184;
static PyObject *__pyx_tuple__185;
static PyObject *__pyx_tuple__186;
static PyObject *__pyx_tuple__187;
static PyObject *__pyx_tuple__188;
static PyObject *__pyx_tuple__189;
static PyObject *__pyx_tuple__190;
static PyObject *__pyx_tuple__191;
static PyObject *__pyx_tuple__192;
static PyObject *__pyx_tuple__193;
static PyObject *__pyx_tuple__194;
static PyObject *__pyx_tuple__195;
static PyObject *__pyx_tuple__196;
static PyObject *__pyx_tuple__197;
static PyObject *__pyx_tuple__198;
static PyObject *__pyx_tuple__199;
static PyObject *__pyx_tuple__200;
static PyObject *__pyx_tuple__201;
static PyObject *__pyx_tuple__202;
static PyObject *__pyx_tuple__203;
static PyObject *__pyx_tuple__204;
static PyObject *__pyx_tuple__205;
static PyObject *__pyx_tuple__206;
static PyObject *__pyx_tuple__207;
static PyObject *__pyx_tuple__208;
static PyObject *__pyx_tuple__209;
static PyObject *__pyx_tuple__210;
static PyObject *__pyx_tuple__211;
static PyObject *__pyx_tuple__212;
static PyObject *__pyx_tuple__213;
static PyObject *__pyx_tuple__214;
static PyObject *__pyx_tuple__215;
static PyObject *__pyx_tuple__216;
static PyObject *__pyx_tuple__217;
static PyObject *__pyx_tuple__218;
static PyObject *__pyx_tuple__219;
static PyObject *__pyx_tuple__220;
static PyObject *__pyx_tuple__221;
static PyObject *__pyx_tuple__222;
static PyObject *__pyx_tuple__223;
static PyObject *__pyx_tuple__224;
static PyObject *__pyx_tuple__225;
static PyObject *__pyx_tuple__226;
static PyObject *__pyx_tuple__227;
static PyObject *__pyx_tuple__228;
static PyObject *__pyx_tuple__229;
static PyObject *__pyx_tuple__230;
static PyObject *__pyx_tuple__231;
static PyObject *__pyx_tuple__232;
static PyObject *__pyx_tuple__233;
static PyObject *__pyx_tuple__234;
static PyObject *__pyx_tuple__235;
static PyObject *__pyx_tuple__236;
static PyObject *__pyx_tuple__237;
static PyObject *__pyx_tuple__238;
static PyObject *__pyx_tuple__239;
static PyObject *__pyx_tuple__240;
static PyObject *__pyx_tuple__241;
static PyObject *__pyx_tuple__242;
static PyObject *__pyx_tuple__244;
static PyObject *__pyx_tuple__246;
static PyObject *__pyx_codeobj__34;
static PyObject *__pyx_codeobj__39;
static PyObject *__pyx_codeobj__41;
static PyObject *__pyx_codeobj__43;
static PyObject *__pyx_codeobj__243;
static PyObject *__pyx_codeobj__245;

/* "libopenzwave.pyx":70
 *     class NullHandler(logging.Handler):
 *         """NullHandler logger for python 2.6"""
 *         def emit(self, record):             # <<<<<<<<<<<<<<
 *             pass
 * logger = logging.getLogger('libopenzwave')
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_11NullHandler_1emit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_12libopenzwave_11NullHandler_1emit = {"emit", (PyCFunction)__pyx_pw_12libopenzwave_11NullHandler_1emit, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_12libopenzwave_11NullHandler_1emit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_self = 0;
  CYTHON_UNUSED PyObject *__pyx_v_record = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("emit (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_record,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_record)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("emit", 1, 2, 2, 1); __PYX_ERR(0, 70, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "emit") < 0)) __PYX_ERR(0, 70, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_record = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("emit", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 70, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.NullHandler.emit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_11NullHandler_emit(__pyx_self, __pyx_v_self, __pyx_v_record);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_11NullHandler_emit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_record) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("emit", 0);

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":104
 *         libopenzwave_file = 'not_installed'
 * 
 * cdef string str_to_cppstr(str s):             # <<<<<<<<<<<<<<
 *     if isinstance(s, unicode):
 *         b = s.encode('utf-8')
 */

static std::string __pyx_f_12libopenzwave_str_to_cppstr(PyObject *__pyx_v_s) {
  PyObject *__pyx_v_b = NULL;
  std::string __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  char *__pyx_t_5;
  __Pyx_RefNannySetupContext("str_to_cppstr", 0);

  /* "libopenzwave.pyx":105
 * 
 * cdef string str_to_cppstr(str s):
 *     if isinstance(s, unicode):             # <<<<<<<<<<<<<<
 *         b = s.encode('utf-8')
 *     else:
 */
  __pyx_t_1 = PyUnicode_Check(__pyx_v_s); 
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":106
 * cdef string str_to_cppstr(str s):
 *     if isinstance(s, unicode):
 *         b = s.encode('utf-8')             # <<<<<<<<<<<<<<
 *     else:
 *         b = s
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_encode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 106, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 106, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_v_b = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "libopenzwave.pyx":105
 * 
 * cdef string str_to_cppstr(str s):
 *     if isinstance(s, unicode):             # <<<<<<<<<<<<<<
 *         b = s.encode('utf-8')
 *     else:
 */
    goto __pyx_L3;
  }

  /* "libopenzwave.pyx":108
 *         b = s.encode('utf-8')
 *     else:
 *         b = s             # <<<<<<<<<<<<<<
 *     return string(b)
 * 
 */
  /*else*/ {
    __Pyx_INCREF(__pyx_v_s);
    __pyx_v_b = __pyx_v_s;
  }
  __pyx_L3:;

  /* "libopenzwave.pyx":109
 *     else:
 *         b = s
 *     return string(b)             # <<<<<<<<<<<<<<
 * 
 * cdef cstr_to_str(s):
 */
  __pyx_t_5 = __Pyx_PyObject_AsString(__pyx_v_b); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 109, __pyx_L1_error)
  __pyx_r = std::string(__pyx_t_5);
  goto __pyx_L0;

  /* "libopenzwave.pyx":104
 *         libopenzwave_file = 'not_installed'
 * 
 * cdef string str_to_cppstr(str s):             # <<<<<<<<<<<<<<
 *     if isinstance(s, unicode):
 *         b = s.encode('utf-8')
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("libopenzwave.str_to_cppstr", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_b);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":111
 *     return string(b)
 * 
 * cdef cstr_to_str(s):             # <<<<<<<<<<<<<<
 *     if six.PY3 and not isinstance(s, str):
 *         return s.decode('utf-8')
 */

static PyObject *__pyx_f_12libopenzwave_cstr_to_str(PyObject *__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  __Pyx_RefNannySetupContext("cstr_to_str", 0);

  /* "libopenzwave.pyx":112
 * 
 * cdef cstr_to_str(s):
 *     if six.PY3 and not isinstance(s, str):             # <<<<<<<<<<<<<<
 *         return s.decode('utf-8')
 *     elif six.PY3:
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_six); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 112, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_PY3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 112, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 112, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_4) {
  } else {
    __pyx_t_1 = __pyx_t_4;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_4 = PyString_Check(__pyx_v_s); 
  __pyx_t_5 = ((!(__pyx_t_4 != 0)) != 0);
  __pyx_t_1 = __pyx_t_5;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":113
 * cdef cstr_to_str(s):
 *     if six.PY3 and not isinstance(s, str):
 *         return s.decode('utf-8')             # <<<<<<<<<<<<<<
 *     elif six.PY3:
 *         return s
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_decode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 113, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 113, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":112
 * 
 * cdef cstr_to_str(s):
 *     if six.PY3 and not isinstance(s, str):             # <<<<<<<<<<<<<<
 *         return s.decode('utf-8')
 *     elif six.PY3:
 */
  }

  /* "libopenzwave.pyx":114
 *     if six.PY3 and not isinstance(s, str):
 *         return s.decode('utf-8')
 *     elif six.PY3:             # <<<<<<<<<<<<<<
 *         return s
 *     else:
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_six); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 114, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_PY3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 114, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 114, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":115
 *         return s.decode('utf-8')
 *     elif six.PY3:
 *         return s             # <<<<<<<<<<<<<<
 *     else:
 *         try:
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_s);
    __pyx_r = __pyx_v_s;
    goto __pyx_L0;

    /* "libopenzwave.pyx":114
 *     if six.PY3 and not isinstance(s, str):
 *         return s.decode('utf-8')
 *     elif six.PY3:             # <<<<<<<<<<<<<<
 *         return s
 *     else:
 */
  }

  /* "libopenzwave.pyx":117
 *         return s
 *     else:
 *         try:             # <<<<<<<<<<<<<<
 *             return s.encode('utf-8')
 *         except:
 */
  /*else*/ {
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_6, &__pyx_t_7, &__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_6);
      __Pyx_XGOTREF(__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_8);
      /*try:*/ {

        /* "libopenzwave.pyx":118
 *     else:
 *         try:
 *             return s.encode('utf-8')             # <<<<<<<<<<<<<<
 *         except:
 *             try:
 */
        __Pyx_XDECREF(__pyx_r);
        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_encode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 118, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 118, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_r = __pyx_t_2;
        __pyx_t_2 = 0;
        goto __pyx_L10_try_return;

        /* "libopenzwave.pyx":117
 *         return s
 *     else:
 *         try:             # <<<<<<<<<<<<<<
 *             return s.encode('utf-8')
 *         except:
 */
      }
      __pyx_L6_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;

      /* "libopenzwave.pyx":119
 *         try:
 *             return s.encode('utf-8')
 *         except:             # <<<<<<<<<<<<<<
 *             try:
 *                 return s.decode('utf-8')
 */
      /*except:*/ {
        __Pyx_AddTraceback("libopenzwave.cstr_to_str", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_3, &__pyx_t_9) < 0) __PYX_ERR(0, 119, __pyx_L8_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_GOTREF(__pyx_t_9);

        /* "libopenzwave.pyx":120
 *             return s.encode('utf-8')
 *         except:
 *             try:             # <<<<<<<<<<<<<<
 *                 return s.decode('utf-8')
 *             except:
 */
        {
          __Pyx_PyThreadState_declare
          __Pyx_PyThreadState_assign
          __Pyx_ExceptionSave(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12);
          __Pyx_XGOTREF(__pyx_t_10);
          __Pyx_XGOTREF(__pyx_t_11);
          __Pyx_XGOTREF(__pyx_t_12);
          /*try:*/ {

            /* "libopenzwave.pyx":121
 *         except:
 *             try:
 *                 return s.decode('utf-8')             # <<<<<<<<<<<<<<
 *             except:
 *                 return s
 */
            __Pyx_XDECREF(__pyx_r);
            __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_decode); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 121, __pyx_L16_error)
            __Pyx_GOTREF(__pyx_t_13);
            __pyx_t_14 = __Pyx_PyObject_Call(__pyx_t_13, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 121, __pyx_L16_error)
            __Pyx_GOTREF(__pyx_t_14);
            __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
            __pyx_r = __pyx_t_14;
            __pyx_t_14 = 0;
            __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
            __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
            __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
            goto __pyx_L20_try_return;

            /* "libopenzwave.pyx":120
 *             return s.encode('utf-8')
 *         except:
 *             try:             # <<<<<<<<<<<<<<
 *                 return s.decode('utf-8')
 *             except:
 */
          }
          __pyx_L16_error:;
          __Pyx_PyThreadState_assign
          __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
          __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;

          /* "libopenzwave.pyx":122
 *             try:
 *                 return s.decode('utf-8')
 *             except:             # <<<<<<<<<<<<<<
 *                 return s
 * 
 */
          /*except:*/ {
            __Pyx_AddTraceback("libopenzwave.cstr_to_str", __pyx_clineno, __pyx_lineno, __pyx_filename);
            if (__Pyx_GetException(&__pyx_t_14, &__pyx_t_13, &__pyx_t_15) < 0) __PYX_ERR(0, 122, __pyx_L18_except_error)
            __Pyx_GOTREF(__pyx_t_14);
            __Pyx_GOTREF(__pyx_t_13);
            __Pyx_GOTREF(__pyx_t_15);

            /* "libopenzwave.pyx":123
 *                 return s.decode('utf-8')
 *             except:
 *                 return s             # <<<<<<<<<<<<<<
 * 
 * class LibZWaveException(Exception):
 */
            __Pyx_XDECREF(__pyx_r);
            __Pyx_INCREF(__pyx_v_s);
            __pyx_r = __pyx_v_s;
            __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
            __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
            __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
            __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
            __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
            __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
            goto __pyx_L19_except_return;
          }
          __pyx_L18_except_error:;

          /* "libopenzwave.pyx":120
 *             return s.encode('utf-8')
 *         except:
 *             try:             # <<<<<<<<<<<<<<
 *                 return s.decode('utf-8')
 *             except:
 */
          __Pyx_PyThreadState_assign
          __Pyx_XGIVEREF(__pyx_t_10);
          __Pyx_XGIVEREF(__pyx_t_11);
          __Pyx_XGIVEREF(__pyx_t_12);
          __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
          goto __pyx_L8_except_error;
          __pyx_L20_try_return:;
          __Pyx_PyThreadState_assign
          __Pyx_XGIVEREF(__pyx_t_10);
          __Pyx_XGIVEREF(__pyx_t_11);
          __Pyx_XGIVEREF(__pyx_t_12);
          __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
          goto __pyx_L9_except_return;
          __pyx_L19_except_return:;
          __Pyx_PyThreadState_assign
          __Pyx_XGIVEREF(__pyx_t_10);
          __Pyx_XGIVEREF(__pyx_t_11);
          __Pyx_XGIVEREF(__pyx_t_12);
          __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
          goto __pyx_L9_except_return;
        }
      }
      __pyx_L8_except_error:;

      /* "libopenzwave.pyx":117
 *         return s
 *     else:
 *         try:             # <<<<<<<<<<<<<<
 *             return s.encode('utf-8')
 *         except:
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_6);
      __Pyx_XGIVEREF(__pyx_t_7);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_ExceptionReset(__pyx_t_6, __pyx_t_7, __pyx_t_8);
      goto __pyx_L1_error;
      __pyx_L10_try_return:;
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_6);
      __Pyx_XGIVEREF(__pyx_t_7);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_ExceptionReset(__pyx_t_6, __pyx_t_7, __pyx_t_8);
      goto __pyx_L0;
      __pyx_L9_except_return:;
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_6);
      __Pyx_XGIVEREF(__pyx_t_7);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_ExceptionReset(__pyx_t_6, __pyx_t_7, __pyx_t_8);
      goto __pyx_L0;
    }
  }

  /* "libopenzwave.pyx":111
 *     return string(b)
 * 
 * cdef cstr_to_str(s):             # <<<<<<<<<<<<<<
 *     if six.PY3 and not isinstance(s, str):
 *         return s.decode('utf-8')
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_XDECREF(__pyx_t_14);
  __Pyx_XDECREF(__pyx_t_15);
  __Pyx_AddTraceback("libopenzwave.cstr_to_str", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":129
 *     Exception class for LibOpenZWave
 *     """
 *     def __init__(self, value):             # <<<<<<<<<<<<<<
 *         Exception.__init__(self)
 *         self.msg = "LibOpenZwave Generic Exception"
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_17LibZWaveException_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_12libopenzwave_17LibZWaveException_1__init__ = {"__init__", (PyCFunction)__pyx_pw_12libopenzwave_17LibZWaveException_1__init__, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_12libopenzwave_17LibZWaveException_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_value,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); __PYX_ERR(0, 129, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 129, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_value = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 129, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.LibZWaveException.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_17LibZWaveException___init__(__pyx_self, __pyx_v_self, __pyx_v_value);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_17LibZWaveException___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "libopenzwave.pyx":130
 *     """
 *     def __init__(self, value):
 *         Exception.__init__(self)             # <<<<<<<<<<<<<<
 *         self.msg = "LibOpenZwave Generic Exception"
 *         self.value = value
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 130, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 130, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_v_self};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 130, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_v_self};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 130, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 130, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3); __pyx_t_3 = NULL;
      __Pyx_INCREF(__pyx_v_self);
      __Pyx_GIVEREF(__pyx_v_self);
      PyTuple_SET_ITEM(__pyx_t_4, 0+1, __pyx_v_self);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 130, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":131
 *     def __init__(self, value):
 *         Exception.__init__(self)
 *         self.msg = "LibOpenZwave Generic Exception"             # <<<<<<<<<<<<<<
 *         self.value = value
 * 
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_msg, __pyx_kp_s_LibOpenZwave_Generic_Exception) < 0) __PYX_ERR(0, 131, __pyx_L1_error)

  /* "libopenzwave.pyx":132
 *         Exception.__init__(self)
 *         self.msg = "LibOpenZwave Generic Exception"
 *         self.value = value             # <<<<<<<<<<<<<<
 * 
 *     def __str__(self):
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_value, __pyx_v_value) < 0) __PYX_ERR(0, 132, __pyx_L1_error)

  /* "libopenzwave.pyx":129
 *     Exception class for LibOpenZWave
 *     """
 *     def __init__(self, value):             # <<<<<<<<<<<<<<
 *         Exception.__init__(self)
 *         self.msg = "LibOpenZwave Generic Exception"
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.LibZWaveException.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":134
 *         self.value = value
 * 
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         return repr(self.msg+' : '+self.value)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_17LibZWaveException_3__str__(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static PyMethodDef __pyx_mdef_12libopenzwave_17LibZWaveException_3__str__ = {"__str__", (PyCFunction)__pyx_pw_12libopenzwave_17LibZWaveException_3__str__, METH_O, 0};
static PyObject *__pyx_pw_12libopenzwave_17LibZWaveException_3__str__(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__str__ (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_17LibZWaveException_2__str__(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_17LibZWaveException_2__str__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("__str__", 0);

  /* "libopenzwave.pyx":135
 * 
 *     def __str__(self):
 *         return repr(self.msg+' : '+self.value)             # <<<<<<<<<<<<<<
 * 
 * # See http://www.electricmonk.nl/log/2011/08/14/redirect-stdout-and-stderr-to-a-logger-in-python/ for capturing console output of the c++ library
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_msg); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 135, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyNumber_Add(__pyx_t_1, __pyx_kp_s__5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 135, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 135, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = PyNumber_Add(__pyx_t_2, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 135, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyObject_Repr(__pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 135, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":134
 *         self.value = value
 * 
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         return repr(self.msg+' : '+self.value)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.LibZWaveException.__str__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":165
 * class EnumWithDoc(str):
 *     """Enum helper"""
 *     def setDoc(self, doc):             # <<<<<<<<<<<<<<
 *         self.doc = doc
 *         return self
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_11EnumWithDoc_1setDoc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_12libopenzwave_11EnumWithDoc_1setDoc = {"setDoc", (PyCFunction)__pyx_pw_12libopenzwave_11EnumWithDoc_1setDoc, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_12libopenzwave_11EnumWithDoc_1setDoc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_doc = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setDoc (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_doc,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_doc)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setDoc", 1, 2, 2, 1); __PYX_ERR(0, 165, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setDoc") < 0)) __PYX_ERR(0, 165, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_doc = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setDoc", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 165, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.EnumWithDoc.setDoc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_11EnumWithDoc_setDoc(__pyx_self, __pyx_v_self, __pyx_v_doc);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_11EnumWithDoc_setDoc(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_doc) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setDoc", 0);

  /* "libopenzwave.pyx":166
 *     """Enum helper"""
 *     def setDoc(self, doc):
 *         self.doc = doc             # <<<<<<<<<<<<<<
 *         return self
 * 
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_doc, __pyx_v_doc) < 0) __PYX_ERR(0, 166, __pyx_L1_error)

  /* "libopenzwave.pyx":167
 *     def setDoc(self, doc):
 *         self.doc = doc
 *         return self             # <<<<<<<<<<<<<<
 * 
 * PyNotifications = [
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  /* "libopenzwave.pyx":165
 * class EnumWithDoc(str):
 *     """Enum helper"""
 *     def setDoc(self, doc):             # <<<<<<<<<<<<<<
 *         self.doc = doc
 *         return self
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.EnumWithDoc.setDoc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":297
 * class EnumWithDocType(str):
 *     """Enum helper"""
 *     def setDocType(self, doc, stype):             # <<<<<<<<<<<<<<
 *         self.doc = doc
 *         self.type = stype
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_15EnumWithDocType_1setDocType(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_12libopenzwave_15EnumWithDocType_1setDocType = {"setDocType", (PyCFunction)__pyx_pw_12libopenzwave_15EnumWithDocType_1setDocType, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_12libopenzwave_15EnumWithDocType_1setDocType(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_doc = 0;
  PyObject *__pyx_v_stype = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setDocType (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_doc,&__pyx_n_s_stype,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_doc)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setDocType", 1, 3, 3, 1); __PYX_ERR(0, 297, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_stype)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setDocType", 1, 3, 3, 2); __PYX_ERR(0, 297, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setDocType") < 0)) __PYX_ERR(0, 297, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_self = values[0];
    __pyx_v_doc = values[1];
    __pyx_v_stype = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setDocType", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 297, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.EnumWithDocType.setDocType", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_15EnumWithDocType_setDocType(__pyx_self, __pyx_v_self, __pyx_v_doc, __pyx_v_stype);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_15EnumWithDocType_setDocType(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_doc, PyObject *__pyx_v_stype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setDocType", 0);

  /* "libopenzwave.pyx":298
 *     """Enum helper"""
 *     def setDocType(self, doc, stype):
 *         self.doc = doc             # <<<<<<<<<<<<<<
 *         self.type = stype
 *         return self
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_doc, __pyx_v_doc) < 0) __PYX_ERR(0, 298, __pyx_L1_error)

  /* "libopenzwave.pyx":299
 *     def setDocType(self, doc, stype):
 *         self.doc = doc
 *         self.type = stype             # <<<<<<<<<<<<<<
 *         return self
 * 
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_type, __pyx_v_stype) < 0) __PYX_ERR(0, 299, __pyx_L1_error)

  /* "libopenzwave.pyx":300
 *         self.doc = doc
 *         self.type = stype
 *         return self             # <<<<<<<<<<<<<<
 * 
 * PyOptionList = {
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  /* "libopenzwave.pyx":297
 * class EnumWithDocType(str):
 *     """Enum helper"""
 *     def setDocType(self, doc, stype):             # <<<<<<<<<<<<<<
 *         self.doc = doc
 *         self.type = stype
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.EnumWithDocType.setDocType", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":374
 * cdef map[uint64_t, ValueID] values_map
 * 
 * cdef getValueFromType(Manager *manager, valueId):             # <<<<<<<<<<<<<<
 *     """
 *     Translate a value in the right type
 */

static PyObject *__pyx_f_12libopenzwave_getValueFromType(OpenZWave::Manager *__pyx_v_manager, PyObject *__pyx_v_valueId) {
  float __pyx_v_type_float;
  bool __pyx_v_type_bool;
  uint8_t __pyx_v_type_byte;
  int32_t __pyx_v_type_int;
  int16_t __pyx_v_type_short;
  std::string __pyx_v_type_string;
  uint8_t *__pyx_v_vectraw;
  uint8_t __pyx_v_size;
  PyObject *__pyx_v_c = NULL;
  PyObject *__pyx_v_ret = NULL;
  PyObject *__pyx_v_datatype = NULL;
  bool __pyx_v_cret;
  long __pyx_v_x;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_7;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_8;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_9;
  uint8_t __pyx_t_10;
  long __pyx_t_11;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_12;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_13;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_14;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_15;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_16;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_17;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_18;
  int __pyx_t_19;
  PyObject *__pyx_t_20 = NULL;
  __Pyx_RefNannySetupContext("getValueFromType", 0);

  /* "libopenzwave.pyx":385
 *     cdef string type_string
 *     cdef vector[string] vect
 *     cdef uint8_t* vectraw = NULL             # <<<<<<<<<<<<<<
 *     cdef uint8_t size
 *     cdef string s
 */
  __pyx_v_vectraw = NULL;

  /* "libopenzwave.pyx":388
 *     cdef uint8_t size
 *     cdef string s
 *     c = ""             # <<<<<<<<<<<<<<
 *     ret = None
 *     if values_map.find(valueId) != values_map.end():
 */
  __Pyx_INCREF(__pyx_kp_s__6);
  __pyx_v_c = __pyx_kp_s__6;

  /* "libopenzwave.pyx":389
 *     cdef string s
 *     c = ""
 *     ret = None             # <<<<<<<<<<<<<<
 *     if values_map.find(valueId) != values_map.end():
 *         datatype = PyValueTypes[values_map.at(valueId).GetType()]
 */
  __Pyx_INCREF(Py_None);
  __pyx_v_ret = Py_None;

  /* "libopenzwave.pyx":390
 *     c = ""
 *     ret = None
 *     if values_map.find(valueId) != values_map.end():             # <<<<<<<<<<<<<<
 *         datatype = PyValueTypes[values_map.at(valueId).GetType()]
 *         if datatype == "Bool":
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_valueId); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 390, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":391
 *     ret = None
 *     if values_map.find(valueId) != values_map.end():
 *         datatype = PyValueTypes[values_map.at(valueId).GetType()]             # <<<<<<<<<<<<<<
 *         if datatype == "Bool":
 *             cret = manager.GetValueAsBool(values_map.at(valueId), &type_bool)
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyValueTypes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 391, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_valueId); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 391, __pyx_L1_error)
    try {
      __pyx_t_4 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 391, __pyx_L1_error)
    }
    __pyx_t_5 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueType(__pyx_t_4->GetType()); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 391, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = PyObject_GetItem(__pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 391, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_v_datatype = __pyx_t_6;
    __pyx_t_6 = 0;

    /* "libopenzwave.pyx":392
 *     if values_map.find(valueId) != values_map.end():
 *         datatype = PyValueTypes[values_map.at(valueId).GetType()]
 *         if datatype == "Bool":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsBool(values_map.at(valueId), &type_bool)
 *             ret = type_bool if cret else None
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Bool, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 392, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":393
 *         datatype = PyValueTypes[values_map.at(valueId).GetType()]
 *         if datatype == "Bool":
 *             cret = manager.GetValueAsBool(values_map.at(valueId), &type_bool)             # <<<<<<<<<<<<<<
 *             ret = type_bool if cret else None
 *             return ret
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_valueId); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 393, __pyx_L1_error)
      try {
        __pyx_t_7 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 393, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_manager->GetValueAsBool(__pyx_t_7, (&__pyx_v_type_bool));

      /* "libopenzwave.pyx":394
 *         if datatype == "Bool":
 *             cret = manager.GetValueAsBool(values_map.at(valueId), &type_bool)
 *             ret = type_bool if cret else None             # <<<<<<<<<<<<<<
 *             return ret
 *         elif datatype == "Byte":
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_5 = __Pyx_PyBool_FromLong(__pyx_v_type_bool); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 394, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __pyx_t_6 = __pyx_t_5;
        __pyx_t_5 = 0;
      } else {
        __Pyx_INCREF(Py_None);
        __pyx_t_6 = Py_None;
      }
      __Pyx_DECREF_SET(__pyx_v_ret, __pyx_t_6);
      __pyx_t_6 = 0;

      /* "libopenzwave.pyx":395
 *             cret = manager.GetValueAsBool(values_map.at(valueId), &type_bool)
 *             ret = type_bool if cret else None
 *             return ret             # <<<<<<<<<<<<<<
 *         elif datatype == "Byte":
 *             cret = manager.GetValueAsByte(values_map.at(valueId), &type_byte)
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_v_ret);
      __pyx_r = __pyx_v_ret;
      goto __pyx_L0;

      /* "libopenzwave.pyx":392
 *     if values_map.find(valueId) != values_map.end():
 *         datatype = PyValueTypes[values_map.at(valueId).GetType()]
 *         if datatype == "Bool":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsBool(values_map.at(valueId), &type_bool)
 *             ret = type_bool if cret else None
 */
    }

    /* "libopenzwave.pyx":396
 *             ret = type_bool if cret else None
 *             return ret
 *         elif datatype == "Byte":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsByte(values_map.at(valueId), &type_byte)
 *             ret = type_byte if cret else None
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Byte, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 396, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":397
 *             return ret
 *         elif datatype == "Byte":
 *             cret = manager.GetValueAsByte(values_map.at(valueId), &type_byte)             # <<<<<<<<<<<<<<
 *             ret = type_byte if cret else None
 *             return ret
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_valueId); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 397, __pyx_L1_error)
      try {
        __pyx_t_8 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 397, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_manager->GetValueAsByte(__pyx_t_8, (&__pyx_v_type_byte));

      /* "libopenzwave.pyx":398
 *         elif datatype == "Byte":
 *             cret = manager.GetValueAsByte(values_map.at(valueId), &type_byte)
 *             ret = type_byte if cret else None             # <<<<<<<<<<<<<<
 *             return ret
 *         elif datatype == "Raw":
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_5 = __Pyx_PyInt_From_uint8_t(__pyx_v_type_byte); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 398, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __pyx_t_6 = __pyx_t_5;
        __pyx_t_5 = 0;
      } else {
        __Pyx_INCREF(Py_None);
        __pyx_t_6 = Py_None;
      }
      __Pyx_DECREF_SET(__pyx_v_ret, __pyx_t_6);
      __pyx_t_6 = 0;

      /* "libopenzwave.pyx":399
 *             cret = manager.GetValueAsByte(values_map.at(valueId), &type_byte)
 *             ret = type_byte if cret else None
 *             return ret             # <<<<<<<<<<<<<<
 *         elif datatype == "Raw":
 *             cret = manager.GetValueAsRaw(values_map.at(valueId), &vectraw, &size)
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_v_ret);
      __pyx_r = __pyx_v_ret;
      goto __pyx_L0;

      /* "libopenzwave.pyx":396
 *             ret = type_bool if cret else None
 *             return ret
 *         elif datatype == "Byte":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsByte(values_map.at(valueId), &type_byte)
 *             ret = type_byte if cret else None
 */
    }

    /* "libopenzwave.pyx":400
 *             ret = type_byte if cret else None
 *             return ret
 *         elif datatype == "Raw":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsRaw(values_map.at(valueId), &vectraw, &size)
 *             if cret:
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Raw, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 400, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":401
 *             return ret
 *         elif datatype == "Raw":
 *             cret = manager.GetValueAsRaw(values_map.at(valueId), &vectraw, &size)             # <<<<<<<<<<<<<<
 *             if cret:
 *                 for x in range (0, size):
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_valueId); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 401, __pyx_L1_error)
      try {
        __pyx_t_9 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 401, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_manager->GetValueAsRaw(__pyx_t_9, (&__pyx_v_vectraw), (&__pyx_v_size));

      /* "libopenzwave.pyx":402
 *         elif datatype == "Raw":
 *             cret = manager.GetValueAsRaw(values_map.at(valueId), &vectraw, &size)
 *             if cret:             # <<<<<<<<<<<<<<
 *                 for x in range (0, size):
 *                     c += chr(vectraw[x])
 */
      __pyx_t_2 = (__pyx_v_cret != 0);
      if (__pyx_t_2) {

        /* "libopenzwave.pyx":403
 *             cret = manager.GetValueAsRaw(values_map.at(valueId), &vectraw, &size)
 *             if cret:
 *                 for x in range (0, size):             # <<<<<<<<<<<<<<
 *                     c += chr(vectraw[x])
 *             ret = c if cret else None
 */
        __pyx_t_10 = __pyx_v_size;
        for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_10; __pyx_t_11+=1) {
          __pyx_v_x = __pyx_t_11;

          /* "libopenzwave.pyx":404
 *             if cret:
 *                 for x in range (0, size):
 *                     c += chr(vectraw[x])             # <<<<<<<<<<<<<<
 *             ret = c if cret else None
 *             free(vectraw)
 */
          __pyx_t_6 = __Pyx_PyInt_From_uint8_t((__pyx_v_vectraw[__pyx_v_x])); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 404, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_6);
          __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 404, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_GIVEREF(__pyx_t_6);
          PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_6);
          __pyx_t_6 = 0;
          __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_chr, __pyx_t_5, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 404, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_6);
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
          __pyx_t_5 = PyNumber_InPlaceAdd(__pyx_v_c, __pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 404, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          __Pyx_DECREF_SET(__pyx_v_c, __pyx_t_5);
          __pyx_t_5 = 0;
        }

        /* "libopenzwave.pyx":402
 *         elif datatype == "Raw":
 *             cret = manager.GetValueAsRaw(values_map.at(valueId), &vectraw, &size)
 *             if cret:             # <<<<<<<<<<<<<<
 *                 for x in range (0, size):
 *                     c += chr(vectraw[x])
 */
      }

      /* "libopenzwave.pyx":405
 *                 for x in range (0, size):
 *                     c += chr(vectraw[x])
 *             ret = c if cret else None             # <<<<<<<<<<<<<<
 *             free(vectraw)
 *             return ret
 */
      if ((__pyx_v_cret != 0)) {
        __Pyx_INCREF(__pyx_v_c);
        __pyx_t_5 = __pyx_v_c;
      } else {
        __Pyx_INCREF(Py_None);
        __pyx_t_5 = Py_None;
      }
      __Pyx_DECREF_SET(__pyx_v_ret, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "libopenzwave.pyx":406
 *                     c += chr(vectraw[x])
 *             ret = c if cret else None
 *             free(vectraw)             # <<<<<<<<<<<<<<
 *             return ret
 *         elif datatype == "Decimal":
 */
      free(__pyx_v_vectraw);

      /* "libopenzwave.pyx":407
 *             ret = c if cret else None
 *             free(vectraw)
 *             return ret             # <<<<<<<<<<<<<<
 *         elif datatype == "Decimal":
 *             cret = manager.GetValueAsFloat(values_map.at(valueId), &type_float)
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_v_ret);
      __pyx_r = __pyx_v_ret;
      goto __pyx_L0;

      /* "libopenzwave.pyx":400
 *             ret = type_byte if cret else None
 *             return ret
 *         elif datatype == "Raw":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsRaw(values_map.at(valueId), &vectraw, &size)
 *             if cret:
 */
    }

    /* "libopenzwave.pyx":408
 *             free(vectraw)
 *             return ret
 *         elif datatype == "Decimal":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsFloat(values_map.at(valueId), &type_float)
 *             ret = type_float if cret else None
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Decimal, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 408, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":409
 *             return ret
 *         elif datatype == "Decimal":
 *             cret = manager.GetValueAsFloat(values_map.at(valueId), &type_float)             # <<<<<<<<<<<<<<
 *             ret = type_float if cret else None
 *             return ret
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_valueId); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 409, __pyx_L1_error)
      try {
        __pyx_t_12 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 409, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_manager->GetValueAsFloat(__pyx_t_12, (&__pyx_v_type_float));

      /* "libopenzwave.pyx":410
 *         elif datatype == "Decimal":
 *             cret = manager.GetValueAsFloat(values_map.at(valueId), &type_float)
 *             ret = type_float if cret else None             # <<<<<<<<<<<<<<
 *             return ret
 *         elif datatype == "Int":
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_6 = PyFloat_FromDouble(__pyx_v_type_float); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 410, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_5 = __pyx_t_6;
        __pyx_t_6 = 0;
      } else {
        __Pyx_INCREF(Py_None);
        __pyx_t_5 = Py_None;
      }
      __Pyx_DECREF_SET(__pyx_v_ret, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "libopenzwave.pyx":411
 *             cret = manager.GetValueAsFloat(values_map.at(valueId), &type_float)
 *             ret = type_float if cret else None
 *             return ret             # <<<<<<<<<<<<<<
 *         elif datatype == "Int":
 *             cret = manager.GetValueAsInt(values_map.at(valueId), &type_int)
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_v_ret);
      __pyx_r = __pyx_v_ret;
      goto __pyx_L0;

      /* "libopenzwave.pyx":408
 *             free(vectraw)
 *             return ret
 *         elif datatype == "Decimal":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsFloat(values_map.at(valueId), &type_float)
 *             ret = type_float if cret else None
 */
    }

    /* "libopenzwave.pyx":412
 *             ret = type_float if cret else None
 *             return ret
 *         elif datatype == "Int":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsInt(values_map.at(valueId), &type_int)
 *             ret = type_int if cret else None
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Int, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 412, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":413
 *             return ret
 *         elif datatype == "Int":
 *             cret = manager.GetValueAsInt(values_map.at(valueId), &type_int)             # <<<<<<<<<<<<<<
 *             ret = type_int if cret else None
 *             return ret
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_valueId); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 413, __pyx_L1_error)
      try {
        __pyx_t_13 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 413, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_manager->GetValueAsInt(__pyx_t_13, (&__pyx_v_type_int));

      /* "libopenzwave.pyx":414
 *         elif datatype == "Int":
 *             cret = manager.GetValueAsInt(values_map.at(valueId), &type_int)
 *             ret = type_int if cret else None             # <<<<<<<<<<<<<<
 *             return ret
 *         elif datatype == "Short":
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_6 = __Pyx_PyInt_From_int32_t(__pyx_v_type_int); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 414, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_5 = __pyx_t_6;
        __pyx_t_6 = 0;
      } else {
        __Pyx_INCREF(Py_None);
        __pyx_t_5 = Py_None;
      }
      __Pyx_DECREF_SET(__pyx_v_ret, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "libopenzwave.pyx":415
 *             cret = manager.GetValueAsInt(values_map.at(valueId), &type_int)
 *             ret = type_int if cret else None
 *             return ret             # <<<<<<<<<<<<<<
 *         elif datatype == "Short":
 *             cret = manager.GetValueAsShort(values_map.at(valueId), &type_short)
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_v_ret);
      __pyx_r = __pyx_v_ret;
      goto __pyx_L0;

      /* "libopenzwave.pyx":412
 *             ret = type_float if cret else None
 *             return ret
 *         elif datatype == "Int":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsInt(values_map.at(valueId), &type_int)
 *             ret = type_int if cret else None
 */
    }

    /* "libopenzwave.pyx":416
 *             ret = type_int if cret else None
 *             return ret
 *         elif datatype == "Short":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsShort(values_map.at(valueId), &type_short)
 *             ret = type_short if cret else None
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Short, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 416, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":417
 *             return ret
 *         elif datatype == "Short":
 *             cret = manager.GetValueAsShort(values_map.at(valueId), &type_short)             # <<<<<<<<<<<<<<
 *             ret = type_short if cret else None
 *             return ret
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_valueId); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 417, __pyx_L1_error)
      try {
        __pyx_t_14 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 417, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_manager->GetValueAsShort(__pyx_t_14, (&__pyx_v_type_short));

      /* "libopenzwave.pyx":418
 *         elif datatype == "Short":
 *             cret = manager.GetValueAsShort(values_map.at(valueId), &type_short)
 *             ret = type_short if cret else None             # <<<<<<<<<<<<<<
 *             return ret
 *         elif datatype == "String":
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_6 = __Pyx_PyInt_From_int16_t(__pyx_v_type_short); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 418, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_5 = __pyx_t_6;
        __pyx_t_6 = 0;
      } else {
        __Pyx_INCREF(Py_None);
        __pyx_t_5 = Py_None;
      }
      __Pyx_DECREF_SET(__pyx_v_ret, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "libopenzwave.pyx":419
 *             cret = manager.GetValueAsShort(values_map.at(valueId), &type_short)
 *             ret = type_short if cret else None
 *             return ret             # <<<<<<<<<<<<<<
 *         elif datatype == "String":
 *             cret = manager.GetValueAsString(values_map.at(valueId), &type_string)
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_v_ret);
      __pyx_r = __pyx_v_ret;
      goto __pyx_L0;

      /* "libopenzwave.pyx":416
 *             ret = type_int if cret else None
 *             return ret
 *         elif datatype == "Short":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsShort(values_map.at(valueId), &type_short)
 *             ret = type_short if cret else None
 */
    }

    /* "libopenzwave.pyx":420
 *             ret = type_short if cret else None
 *             return ret
 *         elif datatype == "String":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsString(values_map.at(valueId), &type_string)
 *             ret = type_string.c_str() if cret else None
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_String, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 420, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":421
 *             return ret
 *         elif datatype == "String":
 *             cret = manager.GetValueAsString(values_map.at(valueId), &type_string)             # <<<<<<<<<<<<<<
 *             ret = type_string.c_str() if cret else None
 *             return ret
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_valueId); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 421, __pyx_L1_error)
      try {
        __pyx_t_15 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 421, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_manager->GetValueAsString(__pyx_t_15, (&__pyx_v_type_string));

      /* "libopenzwave.pyx":422
 *         elif datatype == "String":
 *             cret = manager.GetValueAsString(values_map.at(valueId), &type_string)
 *             ret = type_string.c_str() if cret else None             # <<<<<<<<<<<<<<
 *             return ret
 *         elif datatype == "Button":
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_6 = __Pyx_PyUnicode_FromString(__pyx_v_type_string.c_str()); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 422, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_5 = __pyx_t_6;
        __pyx_t_6 = 0;
      } else {
        __Pyx_INCREF(Py_None);
        __pyx_t_5 = Py_None;
      }
      __Pyx_DECREF_SET(__pyx_v_ret, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "libopenzwave.pyx":423
 *             cret = manager.GetValueAsString(values_map.at(valueId), &type_string)
 *             ret = type_string.c_str() if cret else None
 *             return ret             # <<<<<<<<<<<<<<
 *         elif datatype == "Button":
 *             cret = manager.GetValueAsBool(values_map.at(valueId), &type_bool)
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_v_ret);
      __pyx_r = __pyx_v_ret;
      goto __pyx_L0;

      /* "libopenzwave.pyx":420
 *             ret = type_short if cret else None
 *             return ret
 *         elif datatype == "String":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsString(values_map.at(valueId), &type_string)
 *             ret = type_string.c_str() if cret else None
 */
    }

    /* "libopenzwave.pyx":424
 *             ret = type_string.c_str() if cret else None
 *             return ret
 *         elif datatype == "Button":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsBool(values_map.at(valueId), &type_bool)
 *             ret = type_bool if cret else None
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Button, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 424, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":425
 *             return ret
 *         elif datatype == "Button":
 *             cret = manager.GetValueAsBool(values_map.at(valueId), &type_bool)             # <<<<<<<<<<<<<<
 *             ret = type_bool if cret else None
 *             return ret
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_valueId); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 425, __pyx_L1_error)
      try {
        __pyx_t_16 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 425, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_manager->GetValueAsBool(__pyx_t_16, (&__pyx_v_type_bool));

      /* "libopenzwave.pyx":426
 *         elif datatype == "Button":
 *             cret = manager.GetValueAsBool(values_map.at(valueId), &type_bool)
 *             ret = type_bool if cret else None             # <<<<<<<<<<<<<<
 *             return ret
 *         elif datatype == "List":
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_6 = __Pyx_PyBool_FromLong(__pyx_v_type_bool); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 426, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_5 = __pyx_t_6;
        __pyx_t_6 = 0;
      } else {
        __Pyx_INCREF(Py_None);
        __pyx_t_5 = Py_None;
      }
      __Pyx_DECREF_SET(__pyx_v_ret, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "libopenzwave.pyx":427
 *             cret = manager.GetValueAsBool(values_map.at(valueId), &type_bool)
 *             ret = type_bool if cret else None
 *             return ret             # <<<<<<<<<<<<<<
 *         elif datatype == "List":
 *             cret = manager.GetValueListSelection(values_map.at(valueId), &type_string)
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_v_ret);
      __pyx_r = __pyx_v_ret;
      goto __pyx_L0;

      /* "libopenzwave.pyx":424
 *             ret = type_string.c_str() if cret else None
 *             return ret
 *         elif datatype == "Button":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueAsBool(values_map.at(valueId), &type_bool)
 *             ret = type_bool if cret else None
 */
    }

    /* "libopenzwave.pyx":428
 *             ret = type_bool if cret else None
 *             return ret
 *         elif datatype == "List":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueListSelection(values_map.at(valueId), &type_string)
 *             ret = type_string.c_str() if cret else None
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_List, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 428, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":429
 *             return ret
 *         elif datatype == "List":
 *             cret = manager.GetValueListSelection(values_map.at(valueId), &type_string)             # <<<<<<<<<<<<<<
 *             ret = type_string.c_str() if cret else None
 *             return ret
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_valueId); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 429, __pyx_L1_error)
      try {
        __pyx_t_17 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 429, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_manager->GetValueListSelection(__pyx_t_17, (&__pyx_v_type_string));

      /* "libopenzwave.pyx":430
 *         elif datatype == "List":
 *             cret = manager.GetValueListSelection(values_map.at(valueId), &type_string)
 *             ret = type_string.c_str() if cret else None             # <<<<<<<<<<<<<<
 *             return ret
 *         else :
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_6 = __Pyx_PyUnicode_FromString(__pyx_v_type_string.c_str()); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 430, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_5 = __pyx_t_6;
        __pyx_t_6 = 0;
      } else {
        __Pyx_INCREF(Py_None);
        __pyx_t_5 = Py_None;
      }
      __Pyx_DECREF_SET(__pyx_v_ret, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "libopenzwave.pyx":431
 *             cret = manager.GetValueListSelection(values_map.at(valueId), &type_string)
 *             ret = type_string.c_str() if cret else None
 *             return ret             # <<<<<<<<<<<<<<
 *         else :
 *             cret = manager.GetValueAsString(values_map.at(valueId), &type_string)
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_v_ret);
      __pyx_r = __pyx_v_ret;
      goto __pyx_L0;

      /* "libopenzwave.pyx":428
 *             ret = type_bool if cret else None
 *             return ret
 *         elif datatype == "List":             # <<<<<<<<<<<<<<
 *             cret = manager.GetValueListSelection(values_map.at(valueId), &type_string)
 *             ret = type_string.c_str() if cret else None
 */
    }

    /* "libopenzwave.pyx":433
 *             return ret
 *         else :
 *             cret = manager.GetValueAsString(values_map.at(valueId), &type_string)             # <<<<<<<<<<<<<<
 *             ret = type_string.c_str() if cret else None
 *     logger.debug("getValueFromType return %s", ret)
 */
    /*else*/ {
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_valueId); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 433, __pyx_L1_error)
      try {
        __pyx_t_18 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 433, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_manager->GetValueAsString(__pyx_t_18, (&__pyx_v_type_string));

      /* "libopenzwave.pyx":434
 *         else :
 *             cret = manager.GetValueAsString(values_map.at(valueId), &type_string)
 *             ret = type_string.c_str() if cret else None             # <<<<<<<<<<<<<<
 *     logger.debug("getValueFromType return %s", ret)
 *     return ret
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_6 = __Pyx_PyUnicode_FromString(__pyx_v_type_string.c_str()); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 434, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_5 = __pyx_t_6;
        __pyx_t_6 = 0;
      } else {
        __Pyx_INCREF(Py_None);
        __pyx_t_5 = Py_None;
      }
      __Pyx_DECREF_SET(__pyx_v_ret, __pyx_t_5);
      __pyx_t_5 = 0;
    }

    /* "libopenzwave.pyx":390
 *     c = ""
 *     ret = None
 *     if values_map.find(valueId) != values_map.end():             # <<<<<<<<<<<<<<
 *         datatype = PyValueTypes[values_map.at(valueId).GetType()]
 *         if datatype == "Bool":
 */
  }

  /* "libopenzwave.pyx":435
 *             cret = manager.GetValueAsString(values_map.at(valueId), &type_string)
 *             ret = type_string.c_str() if cret else None
 *     logger.debug("getValueFromType return %s", ret)             # <<<<<<<<<<<<<<
 *     return ret
 * 
 */
  __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 435, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_debug); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 435, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_6 = NULL;
  __pyx_t_19 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
      __pyx_t_19 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_kp_s_getValueFromType_return_s, __pyx_v_ret};
    __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_19, 2+__pyx_t_19); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 435, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GOTREF(__pyx_t_5);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_kp_s_getValueFromType_return_s, __pyx_v_ret};
    __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_19, 2+__pyx_t_19); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 435, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GOTREF(__pyx_t_5);
  } else
  #endif
  {
    __pyx_t_20 = PyTuple_New(2+__pyx_t_19); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 435, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_20);
    if (__pyx_t_6) {
      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_20, 0, __pyx_t_6); __pyx_t_6 = NULL;
    }
    __Pyx_INCREF(__pyx_kp_s_getValueFromType_return_s);
    __Pyx_GIVEREF(__pyx_kp_s_getValueFromType_return_s);
    PyTuple_SET_ITEM(__pyx_t_20, 0+__pyx_t_19, __pyx_kp_s_getValueFromType_return_s);
    __Pyx_INCREF(__pyx_v_ret);
    __Pyx_GIVEREF(__pyx_v_ret);
    PyTuple_SET_ITEM(__pyx_t_20, 1+__pyx_t_19, __pyx_v_ret);
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_20, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 435, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "libopenzwave.pyx":436
 *             ret = type_string.c_str() if cret else None
 *     logger.debug("getValueFromType return %s", ret)
 *     return ret             # <<<<<<<<<<<<<<
 * 
 * cdef delValueId(ValueID v, n):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "libopenzwave.pyx":374
 * cdef map[uint64_t, ValueID] values_map
 * 
 * cdef getValueFromType(Manager *manager, valueId):             # <<<<<<<<<<<<<<
 *     """
 *     Translate a value in the right type
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_20);
  __Pyx_AddTraceback("libopenzwave.getValueFromType", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_c);
  __Pyx_XDECREF(__pyx_v_ret);
  __Pyx_XDECREF(__pyx_v_datatype);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":438
 *     return ret
 * 
 * cdef delValueId(ValueID v, n):             # <<<<<<<<<<<<<<
 *     logger.debug("delValueId : ValueID : %s", v.GetId())
 *     if values_map.find(v.GetId()) != values_map.end():
 */

static PyObject *__pyx_f_12libopenzwave_delValueId(OpenZWave::ValueID __pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_n) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  __Pyx_RefNannySetupContext("delValueId", 0);

  /* "libopenzwave.pyx":439
 * 
 * cdef delValueId(ValueID v, n):
 *     logger.debug("delValueId : ValueID : %s", v.GetId())             # <<<<<<<<<<<<<<
 *     if values_map.find(v.GetId()) != values_map.end():
 *         values_map.erase(values_map.find(v.GetId()))
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 439, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_debug); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 439, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyInt_From_uint64_t(__pyx_v_v.GetId()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 439, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = NULL;
  __pyx_t_5 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
      __pyx_t_5 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_kp_s_delValueId_ValueID_s, __pyx_t_2};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 439, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_kp_s_delValueId_ValueID_s, __pyx_t_2};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 439, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else
  #endif
  {
    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 439, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (__pyx_t_4) {
      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
    }
    __Pyx_INCREF(__pyx_kp_s_delValueId_ValueID_s);
    __Pyx_GIVEREF(__pyx_kp_s_delValueId_ValueID_s);
    PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_kp_s_delValueId_ValueID_s);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_t_2);
    __pyx_t_2 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 439, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":440
 * cdef delValueId(ValueID v, n):
 *     logger.debug("delValueId : ValueID : %s", v.GetId())
 *     if values_map.find(v.GetId()) != values_map.end():             # <<<<<<<<<<<<<<
 *         values_map.erase(values_map.find(v.GetId()))
 * 
 */
  __pyx_t_7 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_v_v.GetId()) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_7) {

    /* "libopenzwave.pyx":441
 *     logger.debug("delValueId : ValueID : %s", v.GetId())
 *     if values_map.find(v.GetId()) != values_map.end():
 *         values_map.erase(values_map.find(v.GetId()))             # <<<<<<<<<<<<<<
 * 
 * cdef addValueId(ValueID v, n):
 */
    __pyx_v_12libopenzwave_values_map.erase(__pyx_v_12libopenzwave_values_map.find(__pyx_v_v.GetId()));

    /* "libopenzwave.pyx":440
 * cdef delValueId(ValueID v, n):
 *     logger.debug("delValueId : ValueID : %s", v.GetId())
 *     if values_map.find(v.GetId()) != values_map.end():             # <<<<<<<<<<<<<<
 *         values_map.erase(values_map.find(v.GetId()))
 * 
 */
  }

  /* "libopenzwave.pyx":438
 *     return ret
 * 
 * cdef delValueId(ValueID v, n):             # <<<<<<<<<<<<<<
 *     logger.debug("delValueId : ValueID : %s", v.GetId())
 *     if values_map.find(v.GetId()) != values_map.end():
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("libopenzwave.delValueId", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":443
 *         values_map.erase(values_map.find(v.GetId()))
 * 
 * cdef addValueId(ValueID v, n):             # <<<<<<<<<<<<<<
 *     logger.debug("addValueId : ValueID : %s", v.GetId())
 *     #check is a valid value
 */

static PyObject *__pyx_f_12libopenzwave_addValueId(OpenZWave::ValueID __pyx_v_v, PyObject *__pyx_v_n) {
  OpenZWave::Manager *__pyx_v_manager;
  std::pair<uint64_t,OpenZWave::ValueID>  *__pyx_v_item;
  PyObject *__pyx_v_genre = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  std::pair<uint64_t,OpenZWave::ValueID>  *__pyx_t_9;
  uint8_t __pyx_t_10;
  __Pyx_RefNannySetupContext("addValueId", 0);

  /* "libopenzwave.pyx":444
 * 
 * cdef addValueId(ValueID v, n):
 *     logger.debug("addValueId : ValueID : %s", v.GetId())             # <<<<<<<<<<<<<<
 *     #check is a valid value
 *     if v.GetInstance() == 0:
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 444, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_debug); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 444, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyInt_From_uint64_t(__pyx_v_v.GetId()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 444, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = NULL;
  __pyx_t_5 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
      __pyx_t_5 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_kp_s_addValueId_ValueID_s, __pyx_t_2};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 444, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_kp_s_addValueId_ValueID_s, __pyx_t_2};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 444, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else
  #endif
  {
    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 444, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (__pyx_t_4) {
      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
    }
    __Pyx_INCREF(__pyx_kp_s_addValueId_ValueID_s);
    __Pyx_GIVEREF(__pyx_kp_s_addValueId_ValueID_s);
    PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_kp_s_addValueId_ValueID_s);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_t_2);
    __pyx_t_2 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 444, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":446
 *     logger.debug("addValueId : ValueID : %s", v.GetId())
 *     #check is a valid value
 *     if v.GetInstance() == 0:             # <<<<<<<<<<<<<<
 *         return
 *     logger.debug("addValueId : GetCommandClassId : %s, GetType : %s", v.GetCommandClassId(), v.GetType())
 */
  __pyx_t_7 = ((__pyx_v_v.GetInstance() == 0) != 0);
  if (__pyx_t_7) {

    /* "libopenzwave.pyx":447
 *     #check is a valid value
 *     if v.GetInstance() == 0:
 *         return             # <<<<<<<<<<<<<<
 *     logger.debug("addValueId : GetCommandClassId : %s, GetType : %s", v.GetCommandClassId(), v.GetType())
 *     cdef Manager *manager = GetManager()
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_r = Py_None; __Pyx_INCREF(Py_None);
    goto __pyx_L0;

    /* "libopenzwave.pyx":446
 *     logger.debug("addValueId : ValueID : %s", v.GetId())
 *     #check is a valid value
 *     if v.GetInstance() == 0:             # <<<<<<<<<<<<<<
 *         return
 *     logger.debug("addValueId : GetCommandClassId : %s, GetType : %s", v.GetCommandClassId(), v.GetType())
 */
  }

  /* "libopenzwave.pyx":448
 *     if v.GetInstance() == 0:
 *         return
 *     logger.debug("addValueId : GetCommandClassId : %s, GetType : %s", v.GetCommandClassId(), v.GetType())             # <<<<<<<<<<<<<<
 *     cdef Manager *manager = GetManager()
 *     item = new pair[uint64_t, ValueID](v.GetId(), v)
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 448, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_debug); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 448, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyInt_From_uint8_t(__pyx_v_v.GetCommandClassId()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 448, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueType(__pyx_v_v.GetType()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 448, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = NULL;
  __pyx_t_5 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_6);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_6, function);
      __pyx_t_5 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_6)) {
    PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_kp_s_addValueId_GetCommandClassId_s_G, __pyx_t_3, __pyx_t_2};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_5, 3+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 448, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
    PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_kp_s_addValueId_GetCommandClassId_s_G, __pyx_t_3, __pyx_t_2};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_5, 3+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 448, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else
  #endif
  {
    __pyx_t_8 = PyTuple_New(3+__pyx_t_5); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 448, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    if (__pyx_t_4) {
      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_4); __pyx_t_4 = NULL;
    }
    __Pyx_INCREF(__pyx_kp_s_addValueId_GetCommandClassId_s_G);
    __Pyx_GIVEREF(__pyx_kp_s_addValueId_GetCommandClassId_s_G);
    PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_5, __pyx_kp_s_addValueId_GetCommandClassId_s_G);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_5, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_8, 2+__pyx_t_5, __pyx_t_2);
    __pyx_t_3 = 0;
    __pyx_t_2 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 448, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  }
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":449
 *         return
 *     logger.debug("addValueId : GetCommandClassId : %s, GetType : %s", v.GetCommandClassId(), v.GetType())
 *     cdef Manager *manager = GetManager()             # <<<<<<<<<<<<<<
 *     item = new pair[uint64_t, ValueID](v.GetId(), v)
 *     values_map.insert(deref(item))
 */
  __pyx_v_manager = OpenZWave::Manager::Get();

  /* "libopenzwave.pyx":450
 *     logger.debug("addValueId : GetCommandClassId : %s, GetType : %s", v.GetCommandClassId(), v.GetType())
 *     cdef Manager *manager = GetManager()
 *     item = new pair[uint64_t, ValueID](v.GetId(), v)             # <<<<<<<<<<<<<<
 *     values_map.insert(deref(item))
 *     del item
 */
  try {
    __pyx_t_9 = new std::pair<uint64_t,OpenZWave::ValueID> (__pyx_v_v.GetId(), __pyx_v_v);
  } catch(...) {
    __Pyx_CppExn2PyErr();
    __PYX_ERR(0, 450, __pyx_L1_error)
  }
  __pyx_v_item = __pyx_t_9;

  /* "libopenzwave.pyx":451
 *     cdef Manager *manager = GetManager()
 *     item = new pair[uint64_t, ValueID](v.GetId(), v)
 *     values_map.insert(deref(item))             # <<<<<<<<<<<<<<
 *     del item
 *     genre = PyGenres[v.GetGenre()]
 */
  try {
    __pyx_v_12libopenzwave_values_map.insert((*__pyx_v_item));
  } catch(...) {
    __Pyx_CppExn2PyErr();
    __PYX_ERR(0, 451, __pyx_L1_error)
  }

  /* "libopenzwave.pyx":452
 *     item = new pair[uint64_t, ValueID](v.GetId(), v)
 *     values_map.insert(deref(item))
 *     del item             # <<<<<<<<<<<<<<
 *     genre = PyGenres[v.GetGenre()]
 *     #handle basic value in different way
 */
  delete __pyx_v_item;

  /* "libopenzwave.pyx":453
 *     values_map.insert(deref(item))
 *     del item
 *     genre = PyGenres[v.GetGenre()]             # <<<<<<<<<<<<<<
 *     #handle basic value in different way
 *     if genre =="Basic":
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyGenres); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 453, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_6 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueGenre(__pyx_v_v.GetGenre()); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 453, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_8 = PyObject_GetItem(__pyx_t_1, __pyx_t_6); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 453, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_v_genre = __pyx_t_8;
  __pyx_t_8 = 0;

  /* "libopenzwave.pyx":455
 *     genre = PyGenres[v.GetGenre()]
 *     #handle basic value in different way
 *     if genre =="Basic":             # <<<<<<<<<<<<<<
 *         n['valueId'] = {'homeId' : v.GetHomeId(),
 *                     'nodeId' : v.GetNodeId(),
 */
  __pyx_t_7 = (__Pyx_PyString_Equals(__pyx_v_genre, __pyx_n_s_Basic, Py_EQ)); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 455, __pyx_L1_error)
  if (__pyx_t_7) {

    /* "libopenzwave.pyx":456
 *     #handle basic value in different way
 *     if genre =="Basic":
 *         n['valueId'] = {'homeId' : v.GetHomeId(),             # <<<<<<<<<<<<<<
 *                     'nodeId' : v.GetNodeId(),
 *                     'commandClass' : PyManager.COMMAND_CLASS_DESC[v.GetCommandClassId()],
 */
    __pyx_t_8 = PyDict_New(); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 456, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_6 = __Pyx_PyInt_From_uint32_t(__pyx_v_v.GetHomeId()); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 456, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_homeId, __pyx_t_6) < 0) __PYX_ERR(0, 456, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "libopenzwave.pyx":457
 *     if genre =="Basic":
 *         n['valueId'] = {'homeId' : v.GetHomeId(),
 *                     'nodeId' : v.GetNodeId(),             # <<<<<<<<<<<<<<
 *                     'commandClass' : PyManager.COMMAND_CLASS_DESC[v.GetCommandClassId()],
 *                     'instance' : v.GetInstance(),
 */
    __pyx_t_6 = __Pyx_PyInt_From_uint8_t(__pyx_v_v.GetNodeId()); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 457, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_nodeId, __pyx_t_6) < 0) __PYX_ERR(0, 456, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "libopenzwave.pyx":458
 *         n['valueId'] = {'homeId' : v.GetHomeId(),
 *                     'nodeId' : v.GetNodeId(),
 *                     'commandClass' : PyManager.COMMAND_CLASS_DESC[v.GetCommandClassId()],             # <<<<<<<<<<<<<<
 *                     'instance' : v.GetInstance(),
 *                     'index' : v.GetIndex(),
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_12libopenzwave_PyManager), __pyx_n_s_COMMAND_CLASS_DESC); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 458, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_10 = __pyx_v_v.GetCommandClassId();
    __pyx_t_1 = __Pyx_GetItemInt(__pyx_t_6, __pyx_t_10, uint8_t, 0, __Pyx_PyInt_From_uint8_t, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 458, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_commandClass, __pyx_t_1) < 0) __PYX_ERR(0, 456, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "libopenzwave.pyx":459
 *                     'nodeId' : v.GetNodeId(),
 *                     'commandClass' : PyManager.COMMAND_CLASS_DESC[v.GetCommandClassId()],
 *                     'instance' : v.GetInstance(),             # <<<<<<<<<<<<<<
 *                     'index' : v.GetIndex(),
 *                     'id' : v.GetId(),
 */
    __pyx_t_1 = __Pyx_PyInt_From_uint8_t(__pyx_v_v.GetInstance()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 459, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_instance, __pyx_t_1) < 0) __PYX_ERR(0, 456, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "libopenzwave.pyx":460
 *                     'commandClass' : PyManager.COMMAND_CLASS_DESC[v.GetCommandClassId()],
 *                     'instance' : v.GetInstance(),
 *                     'index' : v.GetIndex(),             # <<<<<<<<<<<<<<
 *                     'id' : v.GetId(),
 *                     'genre' : '',
 */
    __pyx_t_1 = __Pyx_PyInt_From_uint8_t(__pyx_v_v.GetIndex()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 460, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_index, __pyx_t_1) < 0) __PYX_ERR(0, 456, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "libopenzwave.pyx":461
 *                     'instance' : v.GetInstance(),
 *                     'index' : v.GetIndex(),
 *                     'id' : v.GetId(),             # <<<<<<<<<<<<<<
 *                     'genre' : '',
 *                     'type' : PyValueTypes[v.GetType()],
 */
    __pyx_t_1 = __Pyx_PyInt_From_uint64_t(__pyx_v_v.GetId()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 461, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_id, __pyx_t_1) < 0) __PYX_ERR(0, 456, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_genre, __pyx_kp_s__6) < 0) __PYX_ERR(0, 456, __pyx_L1_error)

    /* "libopenzwave.pyx":463
 *                     'id' : v.GetId(),
 *                     'genre' : '',
 *                     'type' : PyValueTypes[v.GetType()],             # <<<<<<<<<<<<<<
 *                     'value' : None,
 *                     'label' : None,
 */
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyValueTypes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 463, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_6 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueType(__pyx_v_v.GetType()); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 463, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_2 = PyObject_GetItem(__pyx_t_1, __pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 463, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_type, __pyx_t_2) < 0) __PYX_ERR(0, 456, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "libopenzwave.pyx":464
 *                     'genre' : '',
 *                     'type' : PyValueTypes[v.GetType()],
 *                     'value' : None,             # <<<<<<<<<<<<<<
 *                     'label' : None,
 *                     'units' : None,
 */
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_value, Py_None) < 0) __PYX_ERR(0, 456, __pyx_L1_error)

    /* "libopenzwave.pyx":465
 *                     'type' : PyValueTypes[v.GetType()],
 *                     'value' : None,
 *                     'label' : None,             # <<<<<<<<<<<<<<
 *                     'units' : None,
 *                     'readOnly': False,
 */
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_label, Py_None) < 0) __PYX_ERR(0, 456, __pyx_L1_error)

    /* "libopenzwave.pyx":466
 *                     'value' : None,
 *                     'label' : None,
 *                     'units' : None,             # <<<<<<<<<<<<<<
 *                     'readOnly': False,
 *                     }
 */
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_units, Py_None) < 0) __PYX_ERR(0, 456, __pyx_L1_error)

    /* "libopenzwave.pyx":467
 *                     'label' : None,
 *                     'units' : None,
 *                     'readOnly': False,             # <<<<<<<<<<<<<<
 *                     }
 *     else:
 */
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_readOnly, Py_False) < 0) __PYX_ERR(0, 456, __pyx_L1_error)

    /* "libopenzwave.pyx":456
 *     #handle basic value in different way
 *     if genre =="Basic":
 *         n['valueId'] = {'homeId' : v.GetHomeId(),             # <<<<<<<<<<<<<<
 *                     'nodeId' : v.GetNodeId(),
 *                     'commandClass' : PyManager.COMMAND_CLASS_DESC[v.GetCommandClassId()],
 */
    if (unlikely(PyObject_SetItem(__pyx_v_n, __pyx_n_s_valueId, __pyx_t_8) < 0)) __PYX_ERR(0, 456, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

    /* "libopenzwave.pyx":455
 *     genre = PyGenres[v.GetGenre()]
 *     #handle basic value in different way
 *     if genre =="Basic":             # <<<<<<<<<<<<<<
 *         n['valueId'] = {'homeId' : v.GetHomeId(),
 *                     'nodeId' : v.GetNodeId(),
 */
    goto __pyx_L4;
  }

  /* "libopenzwave.pyx":470
 *                     }
 *     else:
 *         n['valueId'] = {'homeId' : v.GetHomeId(),             # <<<<<<<<<<<<<<
 *                         'nodeId' : v.GetNodeId(),
 *                         'commandClass' : PyManager.COMMAND_CLASS_DESC[v.GetCommandClassId()],
 */
  /*else*/ {
    __pyx_t_8 = PyDict_New(); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 470, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_v.GetHomeId()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 470, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_homeId, __pyx_t_2) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "libopenzwave.pyx":471
 *     else:
 *         n['valueId'] = {'homeId' : v.GetHomeId(),
 *                         'nodeId' : v.GetNodeId(),             # <<<<<<<<<<<<<<
 *                         'commandClass' : PyManager.COMMAND_CLASS_DESC[v.GetCommandClassId()],
 *                         'instance' : v.GetInstance(),
 */
    __pyx_t_2 = __Pyx_PyInt_From_uint8_t(__pyx_v_v.GetNodeId()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 471, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_nodeId, __pyx_t_2) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "libopenzwave.pyx":472
 *         n['valueId'] = {'homeId' : v.GetHomeId(),
 *                         'nodeId' : v.GetNodeId(),
 *                         'commandClass' : PyManager.COMMAND_CLASS_DESC[v.GetCommandClassId()],             # <<<<<<<<<<<<<<
 *                         'instance' : v.GetInstance(),
 *                         'index' : v.GetIndex(),
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_12libopenzwave_PyManager), __pyx_n_s_COMMAND_CLASS_DESC); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 472, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_10 = __pyx_v_v.GetCommandClassId();
    __pyx_t_6 = __Pyx_GetItemInt(__pyx_t_2, __pyx_t_10, uint8_t, 0, __Pyx_PyInt_From_uint8_t, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 472, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_commandClass, __pyx_t_6) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "libopenzwave.pyx":473
 *                         'nodeId' : v.GetNodeId(),
 *                         'commandClass' : PyManager.COMMAND_CLASS_DESC[v.GetCommandClassId()],
 *                         'instance' : v.GetInstance(),             # <<<<<<<<<<<<<<
 *                         'index' : v.GetIndex(),
 *                         'id' : v.GetId(),
 */
    __pyx_t_6 = __Pyx_PyInt_From_uint8_t(__pyx_v_v.GetInstance()); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 473, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_instance, __pyx_t_6) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "libopenzwave.pyx":474
 *                         'commandClass' : PyManager.COMMAND_CLASS_DESC[v.GetCommandClassId()],
 *                         'instance' : v.GetInstance(),
 *                         'index' : v.GetIndex(),             # <<<<<<<<<<<<<<
 *                         'id' : v.GetId(),
 *                         'genre' : genre,
 */
    __pyx_t_6 = __Pyx_PyInt_From_uint8_t(__pyx_v_v.GetIndex()); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 474, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_index, __pyx_t_6) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "libopenzwave.pyx":475
 *                         'instance' : v.GetInstance(),
 *                         'index' : v.GetIndex(),
 *                         'id' : v.GetId(),             # <<<<<<<<<<<<<<
 *                         'genre' : genre,
 *                         'type' : PyValueTypes[v.GetType()],
 */
    __pyx_t_6 = __Pyx_PyInt_From_uint64_t(__pyx_v_v.GetId()); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 475, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_id, __pyx_t_6) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "libopenzwave.pyx":476
 *                         'index' : v.GetIndex(),
 *                         'id' : v.GetId(),
 *                         'genre' : genre,             # <<<<<<<<<<<<<<
 *                         'type' : PyValueTypes[v.GetType()],
 *                         'value' : getValueFromType(manager,v.GetId()),
 */
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_genre, __pyx_v_genre) < 0) __PYX_ERR(0, 470, __pyx_L1_error)

    /* "libopenzwave.pyx":477
 *                         'id' : v.GetId(),
 *                         'genre' : genre,
 *                         'type' : PyValueTypes[v.GetType()],             # <<<<<<<<<<<<<<
 *                         'value' : getValueFromType(manager,v.GetId()),
 *                         'label' : manager.GetValueLabel(v).c_str(),
 */
    __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyValueTypes); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 477, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_2 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueType(__pyx_v_v.GetType()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 477, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = PyObject_GetItem(__pyx_t_6, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 477, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_type, __pyx_t_1) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "libopenzwave.pyx":478
 *                         'genre' : genre,
 *                         'type' : PyValueTypes[v.GetType()],
 *                         'value' : getValueFromType(manager,v.GetId()),             # <<<<<<<<<<<<<<
 *                         'label' : manager.GetValueLabel(v).c_str(),
 *                         'units' : manager.GetValueUnits(v).c_str(),
 */
    __pyx_t_1 = __Pyx_PyInt_From_uint64_t(__pyx_v_v.GetId()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 478, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __pyx_f_12libopenzwave_getValueFromType(__pyx_v_manager, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 478, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_value, __pyx_t_2) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "libopenzwave.pyx":479
 *                         'type' : PyValueTypes[v.GetType()],
 *                         'value' : getValueFromType(manager,v.GetId()),
 *                         'label' : manager.GetValueLabel(v).c_str(),             # <<<<<<<<<<<<<<
 *                         'units' : manager.GetValueUnits(v).c_str(),
 *                         'readOnly': manager.IsValueReadOnly(v),
 */
    __pyx_t_2 = __Pyx_PyUnicode_FromString(__pyx_v_manager->GetValueLabel(__pyx_v_v).c_str()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 479, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_label, __pyx_t_2) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "libopenzwave.pyx":480
 *                         'value' : getValueFromType(manager,v.GetId()),
 *                         'label' : manager.GetValueLabel(v).c_str(),
 *                         'units' : manager.GetValueUnits(v).c_str(),             # <<<<<<<<<<<<<<
 *                         'readOnly': manager.IsValueReadOnly(v),
 *                         }
 */
    __pyx_t_2 = __Pyx_PyUnicode_FromString(__pyx_v_manager->GetValueUnits(__pyx_v_v).c_str()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 480, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_units, __pyx_t_2) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "libopenzwave.pyx":481
 *                         'label' : manager.GetValueLabel(v).c_str(),
 *                         'units' : manager.GetValueUnits(v).c_str(),
 *                         'readOnly': manager.IsValueReadOnly(v),             # <<<<<<<<<<<<<<
 *                         }
 *     logger.debug("addValueId : Notification : %s", n)
 */
    __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_manager->IsValueReadOnly(__pyx_v_v)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 481, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_readOnly, __pyx_t_2) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "libopenzwave.pyx":470
 *                     }
 *     else:
 *         n['valueId'] = {'homeId' : v.GetHomeId(),             # <<<<<<<<<<<<<<
 *                         'nodeId' : v.GetNodeId(),
 *                         'commandClass' : PyManager.COMMAND_CLASS_DESC[v.GetCommandClassId()],
 */
    if (unlikely(PyObject_SetItem(__pyx_v_n, __pyx_n_s_valueId, __pyx_t_8) < 0)) __PYX_ERR(0, 470, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  }
  __pyx_L4:;

  /* "libopenzwave.pyx":483
 *                         'readOnly': manager.IsValueReadOnly(v),
 *                         }
 *     logger.debug("addValueId : Notification : %s", n)             # <<<<<<<<<<<<<<
 * 
 * cdef void notif_callback(const_notification _notification, void* _context) with gil:
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 483, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_debug); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 483, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  __pyx_t_5 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
      __pyx_t_5 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_1)) {
    PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_kp_s_addValueId_Notification_s, __pyx_v_n};
    __pyx_t_8 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 483, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_8);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
    PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_kp_s_addValueId_Notification_s, __pyx_v_n};
    __pyx_t_8 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 483, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_8);
  } else
  #endif
  {
    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 483, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (__pyx_t_2) {
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_2); __pyx_t_2 = NULL;
    }
    __Pyx_INCREF(__pyx_kp_s_addValueId_Notification_s);
    __Pyx_GIVEREF(__pyx_kp_s_addValueId_Notification_s);
    PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_kp_s_addValueId_Notification_s);
    __Pyx_INCREF(__pyx_v_n);
    __Pyx_GIVEREF(__pyx_v_n);
    PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_v_n);
    __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 483, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

  /* "libopenzwave.pyx":443
 *         values_map.erase(values_map.find(v.GetId()))
 * 
 * cdef addValueId(ValueID v, n):             # <<<<<<<<<<<<<<
 *     logger.debug("addValueId : ValueID : %s", v.GetId())
 *     #check is a valid value
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("libopenzwave.addValueId", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_genre);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":485
 *     logger.debug("addValueId : Notification : %s", n)
 * 
 * cdef void notif_callback(const_notification _notification, void* _context) with gil:             # <<<<<<<<<<<<<<
 *     """
 *     Notification callback to the C++ library
 */

static void __pyx_f_12libopenzwave_notif_callback(OpenZWave::Notification const* __pyx_v__notification, void *__pyx_v__context) {
  OpenZWave::Notification *__pyx_v_notification;
  PyObject *__pyx_v_n = NULL;
  uint8_t __pyx_v_state;
  uint8_t __pyx_v_error;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_t_11;
  enum OpenZWave::Notification::NotificationType __pyx_t_12;
  int __pyx_t_13;
  #ifdef WITH_THREAD
  PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
  #endif
  __Pyx_RefNannySetupContext("notif_callback", 0);

  /* "libopenzwave.pyx":490
 * 
 *     """
 *     logger.debug("notif_callback : new notification")             # <<<<<<<<<<<<<<
 *     cdef Notification* notification = <Notification*>_notification
 *     logger.debug("notif_callback : Notification type : %s, nodeId : %s", notification.GetType(), notification.GetNodeId())
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 490, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_debug); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 490, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 490, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":491
 *     """
 *     logger.debug("notif_callback : new notification")
 *     cdef Notification* notification = <Notification*>_notification             # <<<<<<<<<<<<<<
 *     logger.debug("notif_callback : Notification type : %s, nodeId : %s", notification.GetType(), notification.GetNodeId())
 *     try:
 */
  __pyx_v_notification = ((OpenZWave::Notification *)__pyx_v__notification);

  /* "libopenzwave.pyx":492
 *     logger.debug("notif_callback : new notification")
 *     cdef Notification* notification = <Notification*>_notification
 *     logger.debug("notif_callback : Notification type : %s, nodeId : %s", notification.GetType(), notification.GetNodeId())             # <<<<<<<<<<<<<<
 *     try:
 *         n = {'notificationType' : PyNotifications[notification.GetType()],
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 492, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_debug); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 492, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Notification_3a__3a_NotificationType(__pyx_v_notification->GetType()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 492, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = __Pyx_PyInt_From_uint8_t(__pyx_v_notification->GetNodeId()); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 492, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = NULL;
  __pyx_t_6 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
      __pyx_t_6 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[4] = {__pyx_t_5, __pyx_kp_s_notif_callback_Notification_type, __pyx_t_2, __pyx_t_4};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 492, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[4] = {__pyx_t_5, __pyx_kp_s_notif_callback_Notification_type, __pyx_t_2, __pyx_t_4};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 492, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  } else
  #endif
  {
    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 492, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    if (__pyx_t_5) {
      __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __pyx_t_5 = NULL;
    }
    __Pyx_INCREF(__pyx_kp_s_notif_callback_Notification_type);
    __Pyx_GIVEREF(__pyx_kp_s_notif_callback_Notification_type);
    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_kp_s_notif_callback_Notification_type);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_t_4);
    __pyx_t_2 = 0;
    __pyx_t_4 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 492, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":493
 *     cdef Notification* notification = <Notification*>_notification
 *     logger.debug("notif_callback : Notification type : %s, nodeId : %s", notification.GetType(), notification.GetNodeId())
 *     try:             # <<<<<<<<<<<<<<
 *         n = {'notificationType' : PyNotifications[notification.GetType()],
 *              'homeId' : notification.GetHomeId(),
 */
  {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ExceptionSave(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10);
    __Pyx_XGOTREF(__pyx_t_8);
    __Pyx_XGOTREF(__pyx_t_9);
    __Pyx_XGOTREF(__pyx_t_10);
    /*try:*/ {

      /* "libopenzwave.pyx":494
 *     logger.debug("notif_callback : Notification type : %s, nodeId : %s", notification.GetType(), notification.GetNodeId())
 *     try:
 *         n = {'notificationType' : PyNotifications[notification.GetType()],             # <<<<<<<<<<<<<<
 *              'homeId' : notification.GetHomeId(),
 *              'nodeId' : notification.GetNodeId(),
 */
      __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 494, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyNotifications); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 494, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_7 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Notification_3a__3a_NotificationType(__pyx_v_notification->GetType()); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 494, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_4 = PyObject_GetItem(__pyx_t_3, __pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 494, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_notificationType, __pyx_t_4) < 0) __PYX_ERR(0, 494, __pyx_L3_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

      /* "libopenzwave.pyx":495
 *     try:
 *         n = {'notificationType' : PyNotifications[notification.GetType()],
 *              'homeId' : notification.GetHomeId(),             # <<<<<<<<<<<<<<
 *              'nodeId' : notification.GetNodeId(),
 *             }
 */
      __pyx_t_4 = __Pyx_PyInt_From_uint32_t(__pyx_v_notification->GetHomeId()); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 495, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_4);
      if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_homeId, __pyx_t_4) < 0) __PYX_ERR(0, 494, __pyx_L3_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

      /* "libopenzwave.pyx":496
 *         n = {'notificationType' : PyNotifications[notification.GetType()],
 *              'homeId' : notification.GetHomeId(),
 *              'nodeId' : notification.GetNodeId(),             # <<<<<<<<<<<<<<
 *             }
 *     except:
 */
      __pyx_t_4 = __Pyx_PyInt_From_uint8_t(__pyx_v_notification->GetNodeId()); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 496, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_4);
      if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_nodeId, __pyx_t_4) < 0) __PYX_ERR(0, 494, __pyx_L3_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_v_n = ((PyObject*)__pyx_t_1);
      __pyx_t_1 = 0;

      /* "libopenzwave.pyx":493
 *     cdef Notification* notification = <Notification*>_notification
 *     logger.debug("notif_callback : Notification type : %s, nodeId : %s", notification.GetType(), notification.GetNodeId())
 *     try:             # <<<<<<<<<<<<<<
 *         n = {'notificationType' : PyNotifications[notification.GetType()],
 *              'homeId' : notification.GetHomeId(),
 */
    }
    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
    goto __pyx_L10_try_end;
    __pyx_L3_error:;
    __Pyx_PyThreadState_assign
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "libopenzwave.pyx":498
 *              'nodeId' : notification.GetNodeId(),
 *             }
 *     except:             # <<<<<<<<<<<<<<
 *         logger.exception("notif_callback exception")
 *     if notification.GetType() == Type_Group:
 */
    /*except:*/ {
      __Pyx_AddTraceback("libopenzwave.notif_callback", __pyx_clineno, __pyx_lineno, __pyx_filename);
      if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_4, &__pyx_t_7) < 0) __PYX_ERR(0, 498, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_GOTREF(__pyx_t_7);

      /* "libopenzwave.pyx":499
 *             }
 *     except:
 *         logger.exception("notif_callback exception")             # <<<<<<<<<<<<<<
 *     if notification.GetType() == Type_Group:
 *         try:
 */
      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 499, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_exception); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 499, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 499, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      goto __pyx_L4_exception_handled;
    }
    __pyx_L5_except_error:;

    /* "libopenzwave.pyx":493
 *     cdef Notification* notification = <Notification*>_notification
 *     logger.debug("notif_callback : Notification type : %s, nodeId : %s", notification.GetType(), notification.GetNodeId())
 *     try:             # <<<<<<<<<<<<<<
 *         n = {'notificationType' : PyNotifications[notification.GetType()],
 *              'homeId' : notification.GetHomeId(),
 */
    __Pyx_PyThreadState_assign
    __Pyx_XGIVEREF(__pyx_t_8);
    __Pyx_XGIVEREF(__pyx_t_9);
    __Pyx_XGIVEREF(__pyx_t_10);
    __Pyx_ExceptionReset(__pyx_t_8, __pyx_t_9, __pyx_t_10);
    goto __pyx_L1_error;
    __pyx_L4_exception_handled:;
    __Pyx_PyThreadState_assign
    __Pyx_XGIVEREF(__pyx_t_8);
    __Pyx_XGIVEREF(__pyx_t_9);
    __Pyx_XGIVEREF(__pyx_t_10);
    __Pyx_ExceptionReset(__pyx_t_8, __pyx_t_9, __pyx_t_10);
    __pyx_L10_try_end:;
  }

  /* "libopenzwave.pyx":500
 *     except:
 *         logger.exception("notif_callback exception")
 *     if notification.GetType() == Type_Group:             # <<<<<<<<<<<<<<
 *         try:
 *             n['groupIdx'] = notification.GetGroupIdx()
 */
  __pyx_t_11 = ((__pyx_v_notification->GetType() == OpenZWave::Notification::Type_Group) != 0);
  if (__pyx_t_11) {

    /* "libopenzwave.pyx":501
 *         logger.exception("notif_callback exception")
 *     if notification.GetType() == Type_Group:
 *         try:             # <<<<<<<<<<<<<<
 *             n['groupIdx'] = notification.GetGroupIdx()
 *         except:
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_10, &__pyx_t_9, &__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_8);
      /*try:*/ {

        /* "libopenzwave.pyx":502
 *     if notification.GetType() == Type_Group:
 *         try:
 *             n['groupIdx'] = notification.GetGroupIdx()             # <<<<<<<<<<<<<<
 *         except:
 *             logger.exception("notif_callback exception Type_Group")
 */
        __pyx_t_7 = __Pyx_PyInt_From_uint8_t(__pyx_v_notification->GetGroupIdx()); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 502, __pyx_L14_error)
        __Pyx_GOTREF(__pyx_t_7);
        if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 502, __pyx_L14_error) }
        if (unlikely(PyDict_SetItem(__pyx_v_n, __pyx_n_s_groupIdx, __pyx_t_7) < 0)) __PYX_ERR(0, 502, __pyx_L14_error)
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

        /* "libopenzwave.pyx":501
 *         logger.exception("notif_callback exception")
 *     if notification.GetType() == Type_Group:
 *         try:             # <<<<<<<<<<<<<<
 *             n['groupIdx'] = notification.GetGroupIdx()
 *         except:
 */
      }
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      goto __pyx_L21_try_end;
      __pyx_L14_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;

      /* "libopenzwave.pyx":503
 *         try:
 *             n['groupIdx'] = notification.GetGroupIdx()
 *         except:             # <<<<<<<<<<<<<<
 *             logger.exception("notif_callback exception Type_Group")
 *     elif notification.GetType() == Type_NodeEvent:
 */
      /*except:*/ {
        __Pyx_AddTraceback("libopenzwave.notif_callback", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_4, &__pyx_t_1) < 0) __PYX_ERR(0, 503, __pyx_L16_except_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_GOTREF(__pyx_t_1);

        /* "libopenzwave.pyx":504
 *             n['groupIdx'] = notification.GetGroupIdx()
 *         except:
 *             logger.exception("notif_callback exception Type_Group")             # <<<<<<<<<<<<<<
 *     elif notification.GetType() == Type_NodeEvent:
 *         try:
 */
        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 504, __pyx_L16_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_exception); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 504, __pyx_L16_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 504, __pyx_L16_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L15_exception_handled;
      }
      __pyx_L16_except_error:;

      /* "libopenzwave.pyx":501
 *         logger.exception("notif_callback exception")
 *     if notification.GetType() == Type_Group:
 *         try:             # <<<<<<<<<<<<<<
 *             n['groupIdx'] = notification.GetGroupIdx()
 *         except:
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_9, __pyx_t_8);
      goto __pyx_L1_error;
      __pyx_L15_exception_handled:;
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_9, __pyx_t_8);
      __pyx_L21_try_end:;
    }

    /* "libopenzwave.pyx":500
 *     except:
 *         logger.exception("notif_callback exception")
 *     if notification.GetType() == Type_Group:             # <<<<<<<<<<<<<<
 *         try:
 *             n['groupIdx'] = notification.GetGroupIdx()
 */
    goto __pyx_L13;
  }

  /* "libopenzwave.pyx":505
 *         except:
 *             logger.exception("notif_callback exception Type_Group")
 *     elif notification.GetType() == Type_NodeEvent:             # <<<<<<<<<<<<<<
 *         try:
 *             n['event'] = notification.GetEvent()
 */
  __pyx_t_11 = ((__pyx_v_notification->GetType() == OpenZWave::Notification::Type_NodeEvent) != 0);
  if (__pyx_t_11) {

    /* "libopenzwave.pyx":506
 *             logger.exception("notif_callback exception Type_Group")
 *     elif notification.GetType() == Type_NodeEvent:
 *         try:             # <<<<<<<<<<<<<<
 *             n['event'] = notification.GetEvent()
 *         except:
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_10);
      /*try:*/ {

        /* "libopenzwave.pyx":507
 *     elif notification.GetType() == Type_NodeEvent:
 *         try:
 *             n['event'] = notification.GetEvent()             # <<<<<<<<<<<<<<
 *         except:
 *             logger.exception("notif_callback exception Type_NodeEvent")
 */
        __pyx_t_1 = __Pyx_PyInt_From_uint8_t(__pyx_v_notification->GetEvent()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 507, __pyx_L24_error)
        __Pyx_GOTREF(__pyx_t_1);
        if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 507, __pyx_L24_error) }
        if (unlikely(PyDict_SetItem(__pyx_v_n, __pyx_n_s_event, __pyx_t_1) < 0)) __PYX_ERR(0, 507, __pyx_L24_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "libopenzwave.pyx":506
 *             logger.exception("notif_callback exception Type_Group")
 *     elif notification.GetType() == Type_NodeEvent:
 *         try:             # <<<<<<<<<<<<<<
 *             n['event'] = notification.GetEvent()
 *         except:
 */
      }
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      goto __pyx_L31_try_end;
      __pyx_L24_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "libopenzwave.pyx":508
 *         try:
 *             n['event'] = notification.GetEvent()
 *         except:             # <<<<<<<<<<<<<<
 *             logger.exception("notif_callback exception Type_NodeEvent")
 *             raise
 */
      /*except:*/ {
        __Pyx_AddTraceback("libopenzwave.notif_callback", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_4, &__pyx_t_7) < 0) __PYX_ERR(0, 508, __pyx_L26_except_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_GOTREF(__pyx_t_7);

        /* "libopenzwave.pyx":509
 *             n['event'] = notification.GetEvent()
 *         except:
 *             logger.exception("notif_callback exception Type_NodeEvent")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() == Type_Notification:
 */
        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 509, __pyx_L26_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_exception); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 509, __pyx_L26_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 509, __pyx_L26_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

        /* "libopenzwave.pyx":510
 *         except:
 *             logger.exception("notif_callback exception Type_NodeEvent")
 *             raise             # <<<<<<<<<<<<<<
 *     elif notification.GetType() == Type_Notification:
 *         try:
 */
        __Pyx_GIVEREF(__pyx_t_1);
        __Pyx_GIVEREF(__pyx_t_4);
        __Pyx_XGIVEREF(__pyx_t_7);
        __Pyx_ErrRestoreWithState(__pyx_t_1, __pyx_t_4, __pyx_t_7);
        __pyx_t_1 = 0; __pyx_t_4 = 0; __pyx_t_7 = 0; 
        __PYX_ERR(0, 510, __pyx_L26_except_error)
      }
      __pyx_L26_except_error:;

      /* "libopenzwave.pyx":506
 *             logger.exception("notif_callback exception Type_Group")
 *     elif notification.GetType() == Type_NodeEvent:
 *         try:             # <<<<<<<<<<<<<<
 *             n['event'] = notification.GetEvent()
 *         except:
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_ExceptionReset(__pyx_t_8, __pyx_t_9, __pyx_t_10);
      goto __pyx_L1_error;
      __pyx_L31_try_end:;
    }

    /* "libopenzwave.pyx":505
 *         except:
 *             logger.exception("notif_callback exception Type_Group")
 *     elif notification.GetType() == Type_NodeEvent:             # <<<<<<<<<<<<<<
 *         try:
 *             n['event'] = notification.GetEvent()
 */
    goto __pyx_L13;
  }

  /* "libopenzwave.pyx":511
 *             logger.exception("notif_callback exception Type_NodeEvent")
 *             raise
 *     elif notification.GetType() == Type_Notification:             # <<<<<<<<<<<<<<
 *         try:
 *             n['notificationCode'] = notification.GetNotification()
 */
  __pyx_t_11 = ((__pyx_v_notification->GetType() == OpenZWave::Notification::Type_Notification) != 0);
  if (__pyx_t_11) {

    /* "libopenzwave.pyx":512
 *             raise
 *     elif notification.GetType() == Type_Notification:
 *         try:             # <<<<<<<<<<<<<<
 *             n['notificationCode'] = notification.GetNotification()
 *         except:
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_10, &__pyx_t_9, &__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_8);
      /*try:*/ {

        /* "libopenzwave.pyx":513
 *     elif notification.GetType() == Type_Notification:
 *         try:
 *             n['notificationCode'] = notification.GetNotification()             # <<<<<<<<<<<<<<
 *         except:
 *             logger.exception("notif_callback exception Type_Notification")
 */
        __pyx_t_7 = __Pyx_PyInt_From_uint8_t(__pyx_v_notification->GetNotification()); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 513, __pyx_L34_error)
        __Pyx_GOTREF(__pyx_t_7);
        if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 513, __pyx_L34_error) }
        if (unlikely(PyDict_SetItem(__pyx_v_n, __pyx_n_s_notificationCode, __pyx_t_7) < 0)) __PYX_ERR(0, 513, __pyx_L34_error)
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

        /* "libopenzwave.pyx":512
 *             raise
 *     elif notification.GetType() == Type_Notification:
 *         try:             # <<<<<<<<<<<<<<
 *             n['notificationCode'] = notification.GetNotification()
 *         except:
 */
      }
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      goto __pyx_L41_try_end;
      __pyx_L34_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;

      /* "libopenzwave.pyx":514
 *         try:
 *             n['notificationCode'] = notification.GetNotification()
 *         except:             # <<<<<<<<<<<<<<
 *             logger.exception("notif_callback exception Type_Notification")
 *             raise
 */
      /*except:*/ {
        __Pyx_AddTraceback("libopenzwave.notif_callback", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_4, &__pyx_t_1) < 0) __PYX_ERR(0, 514, __pyx_L36_except_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_GOTREF(__pyx_t_1);

        /* "libopenzwave.pyx":515
 *             n['notificationCode'] = notification.GetNotification()
 *         except:
 *             logger.exception("notif_callback exception Type_Notification")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() == Type_ControllerCommand:
 */
        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 515, __pyx_L36_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_exception); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 515, __pyx_L36_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 515, __pyx_L36_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

        /* "libopenzwave.pyx":516
 *         except:
 *             logger.exception("notif_callback exception Type_Notification")
 *             raise             # <<<<<<<<<<<<<<
 *     elif notification.GetType() == Type_ControllerCommand:
 *         try:
 */
        __Pyx_GIVEREF(__pyx_t_7);
        __Pyx_GIVEREF(__pyx_t_4);
        __Pyx_XGIVEREF(__pyx_t_1);
        __Pyx_ErrRestoreWithState(__pyx_t_7, __pyx_t_4, __pyx_t_1);
        __pyx_t_7 = 0; __pyx_t_4 = 0; __pyx_t_1 = 0; 
        __PYX_ERR(0, 516, __pyx_L36_except_error)
      }
      __pyx_L36_except_error:;

      /* "libopenzwave.pyx":512
 *             raise
 *     elif notification.GetType() == Type_Notification:
 *         try:             # <<<<<<<<<<<<<<
 *             n['notificationCode'] = notification.GetNotification()
 *         except:
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_9, __pyx_t_8);
      goto __pyx_L1_error;
      __pyx_L41_try_end:;
    }

    /* "libopenzwave.pyx":511
 *             logger.exception("notif_callback exception Type_NodeEvent")
 *             raise
 *     elif notification.GetType() == Type_Notification:             # <<<<<<<<<<<<<<
 *         try:
 *             n['notificationCode'] = notification.GetNotification()
 */
    goto __pyx_L13;
  }

  /* "libopenzwave.pyx":517
 *             logger.exception("notif_callback exception Type_Notification")
 *             raise
 *     elif notification.GetType() == Type_ControllerCommand:             # <<<<<<<<<<<<<<
 *         try:
 *             state = notification.GetEvent()
 */
  __pyx_t_11 = ((__pyx_v_notification->GetType() == OpenZWave::Notification::Type_ControllerCommand) != 0);
  if (__pyx_t_11) {

    /* "libopenzwave.pyx":518
 *             raise
 *     elif notification.GetType() == Type_ControllerCommand:
 *         try:             # <<<<<<<<<<<<<<
 *             state = notification.GetEvent()
 *             n['controllerStateInt'] = state
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_10);
      /*try:*/ {

        /* "libopenzwave.pyx":519
 *     elif notification.GetType() == Type_ControllerCommand:
 *         try:
 *             state = notification.GetEvent()             # <<<<<<<<<<<<<<
 *             n['controllerStateInt'] = state
 *             n['controllerState'] = PyControllerState[state]
 */
        __pyx_v_state = __pyx_v_notification->GetEvent();

        /* "libopenzwave.pyx":520
 *         try:
 *             state = notification.GetEvent()
 *             n['controllerStateInt'] = state             # <<<<<<<<<<<<<<
 *             n['controllerState'] = PyControllerState[state]
 *             n['controllerStateDoc'] = PyControllerState[state].doc
 */
        __pyx_t_1 = __Pyx_PyInt_From_uint8_t(__pyx_v_state); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 520, __pyx_L44_error)
        __Pyx_GOTREF(__pyx_t_1);
        if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 520, __pyx_L44_error) }
        if (unlikely(PyDict_SetItem(__pyx_v_n, __pyx_n_s_controllerStateInt, __pyx_t_1) < 0)) __PYX_ERR(0, 520, __pyx_L44_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "libopenzwave.pyx":521
 *             state = notification.GetEvent()
 *             n['controllerStateInt'] = state
 *             n['controllerState'] = PyControllerState[state]             # <<<<<<<<<<<<<<
 *             n['controllerStateDoc'] = PyControllerState[state].doc
 *             #Notification is filled with error
 */
        __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyControllerState); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 521, __pyx_L44_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_1, __pyx_v_state, uint8_t, 0, __Pyx_PyInt_From_uint8_t, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 521, __pyx_L44_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 521, __pyx_L44_error) }
        if (unlikely(PyDict_SetItem(__pyx_v_n, __pyx_n_s_controllerState, __pyx_t_4) < 0)) __PYX_ERR(0, 521, __pyx_L44_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

        /* "libopenzwave.pyx":522
 *             n['controllerStateInt'] = state
 *             n['controllerState'] = PyControllerState[state]
 *             n['controllerStateDoc'] = PyControllerState[state].doc             # <<<<<<<<<<<<<<
 *             #Notification is filled with error
 *             error = notification.GetNotification()
 */
        __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyControllerState); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 522, __pyx_L44_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_1 = __Pyx_GetItemInt(__pyx_t_4, __pyx_v_state, uint8_t, 0, __Pyx_PyInt_From_uint8_t, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 522, __pyx_L44_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_doc); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 522, __pyx_L44_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 522, __pyx_L44_error) }
        if (unlikely(PyDict_SetItem(__pyx_v_n, __pyx_n_s_controllerStateDoc, __pyx_t_4) < 0)) __PYX_ERR(0, 522, __pyx_L44_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

        /* "libopenzwave.pyx":524
 *             n['controllerStateDoc'] = PyControllerState[state].doc
 *             #Notification is filled with error
 *             error = notification.GetNotification()             # <<<<<<<<<<<<<<
 *             n['controllerErrorInt'] = error
 *             n['controllerError'] = PyControllerError[error]
 */
        __pyx_v_error = __pyx_v_notification->GetNotification();

        /* "libopenzwave.pyx":525
 *             #Notification is filled with error
 *             error = notification.GetNotification()
 *             n['controllerErrorInt'] = error             # <<<<<<<<<<<<<<
 *             n['controllerError'] = PyControllerError[error]
 *             n['controllerErrorDoc'] = PyControllerError[error].doc
 */
        __pyx_t_4 = __Pyx_PyInt_From_uint8_t(__pyx_v_error); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 525, __pyx_L44_error)
        __Pyx_GOTREF(__pyx_t_4);
        if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 525, __pyx_L44_error) }
        if (unlikely(PyDict_SetItem(__pyx_v_n, __pyx_n_s_controllerErrorInt, __pyx_t_4) < 0)) __PYX_ERR(0, 525, __pyx_L44_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

        /* "libopenzwave.pyx":526
 *             error = notification.GetNotification()
 *             n['controllerErrorInt'] = error
 *             n['controllerError'] = PyControllerError[error]             # <<<<<<<<<<<<<<
 *             n['controllerErrorDoc'] = PyControllerError[error].doc
 *         except:
 */
        __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyControllerError); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 526, __pyx_L44_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_1 = __Pyx_GetItemInt(__pyx_t_4, __pyx_v_error, uint8_t, 0, __Pyx_PyInt_From_uint8_t, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 526, __pyx_L44_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 526, __pyx_L44_error) }
        if (unlikely(PyDict_SetItem(__pyx_v_n, __pyx_n_s_controllerError, __pyx_t_1) < 0)) __PYX_ERR(0, 526, __pyx_L44_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "libopenzwave.pyx":527
 *             n['controllerErrorInt'] = error
 *             n['controllerError'] = PyControllerError[error]
 *             n['controllerErrorDoc'] = PyControllerError[error].doc             # <<<<<<<<<<<<<<
 *         except:
 *             logger.exception("notif_callback exception Type_ControllerCommand")
 */
        __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyControllerError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 527, __pyx_L44_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_1, __pyx_v_error, uint8_t, 0, __Pyx_PyInt_From_uint8_t, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 527, __pyx_L44_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_doc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 527, __pyx_L44_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 527, __pyx_L44_error) }
        if (unlikely(PyDict_SetItem(__pyx_v_n, __pyx_n_s_controllerErrorDoc, __pyx_t_1) < 0)) __PYX_ERR(0, 527, __pyx_L44_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "libopenzwave.pyx":518
 *             raise
 *     elif notification.GetType() == Type_ControllerCommand:
 *         try:             # <<<<<<<<<<<<<<
 *             state = notification.GetEvent()
 *             n['controllerStateInt'] = state
 */
      }
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      goto __pyx_L51_try_end;
      __pyx_L44_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "libopenzwave.pyx":528
 *             n['controllerError'] = PyControllerError[error]
 *             n['controllerErrorDoc'] = PyControllerError[error].doc
 *         except:             # <<<<<<<<<<<<<<
 *             logger.exception("notif_callback exception Type_ControllerCommand")
 *             raise
 */
      /*except:*/ {
        __Pyx_AddTraceback("libopenzwave.notif_callback", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_4, &__pyx_t_7) < 0) __PYX_ERR(0, 528, __pyx_L46_except_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_GOTREF(__pyx_t_7);

        /* "libopenzwave.pyx":529
 *             n['controllerErrorDoc'] = PyControllerError[error].doc
 *         except:
 *             logger.exception("notif_callback exception Type_ControllerCommand")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() in (Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff):
 */
        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 529, __pyx_L46_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_exception); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 529, __pyx_L46_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 529, __pyx_L46_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

        /* "libopenzwave.pyx":530
 *         except:
 *             logger.exception("notif_callback exception Type_ControllerCommand")
 *             raise             # <<<<<<<<<<<<<<
 *     elif notification.GetType() in (Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff):
 *         try:
 */
        __Pyx_GIVEREF(__pyx_t_1);
        __Pyx_GIVEREF(__pyx_t_4);
        __Pyx_XGIVEREF(__pyx_t_7);
        __Pyx_ErrRestoreWithState(__pyx_t_1, __pyx_t_4, __pyx_t_7);
        __pyx_t_1 = 0; __pyx_t_4 = 0; __pyx_t_7 = 0; 
        __PYX_ERR(0, 530, __pyx_L46_except_error)
      }
      __pyx_L46_except_error:;

      /* "libopenzwave.pyx":518
 *             raise
 *     elif notification.GetType() == Type_ControllerCommand:
 *         try:             # <<<<<<<<<<<<<<
 *             state = notification.GetEvent()
 *             n['controllerStateInt'] = state
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_ExceptionReset(__pyx_t_8, __pyx_t_9, __pyx_t_10);
      goto __pyx_L1_error;
      __pyx_L51_try_end:;
    }

    /* "libopenzwave.pyx":517
 *             logger.exception("notif_callback exception Type_Notification")
 *             raise
 *     elif notification.GetType() == Type_ControllerCommand:             # <<<<<<<<<<<<<<
 *         try:
 *             state = notification.GetEvent()
 */
    goto __pyx_L13;
  }

  /* "libopenzwave.pyx":531
 *             logger.exception("notif_callback exception Type_ControllerCommand")
 *             raise
 *     elif notification.GetType() in (Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff):             # <<<<<<<<<<<<<<
 *         try:
 *             n['buttonId'] = notification.GetButtonId()
 */
  __pyx_t_12 = __pyx_v_notification->GetType();
  __pyx_t_13 = ((__pyx_t_12 == OpenZWave::Notification::Type_CreateButton) != 0);
  if (!__pyx_t_13) {
  } else {
    __pyx_t_11 = __pyx_t_13;
    goto __pyx_L54_bool_binop_done;
  }
  __pyx_t_13 = ((__pyx_t_12 == OpenZWave::Notification::Type_DeleteButton) != 0);
  if (!__pyx_t_13) {
  } else {
    __pyx_t_11 = __pyx_t_13;
    goto __pyx_L54_bool_binop_done;
  }
  __pyx_t_13 = ((__pyx_t_12 == OpenZWave::Notification::Type_ButtonOn) != 0);
  if (!__pyx_t_13) {
  } else {
    __pyx_t_11 = __pyx_t_13;
    goto __pyx_L54_bool_binop_done;
  }
  __pyx_t_13 = ((__pyx_t_12 == OpenZWave::Notification::Type_ButtonOff) != 0);
  __pyx_t_11 = __pyx_t_13;
  __pyx_L54_bool_binop_done:;
  __pyx_t_13 = (__pyx_t_11 != 0);
  if (__pyx_t_13) {

    /* "libopenzwave.pyx":532
 *             raise
 *     elif notification.GetType() in (Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff):
 *         try:             # <<<<<<<<<<<<<<
 *             n['buttonId'] = notification.GetButtonId()
 *         except:
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_10, &__pyx_t_9, &__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_8);
      /*try:*/ {

        /* "libopenzwave.pyx":533
 *     elif notification.GetType() in (Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff):
 *         try:
 *             n['buttonId'] = notification.GetButtonId()             # <<<<<<<<<<<<<<
 *         except:
 *             logger.exception("notif_callback exception Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff")
 */
        __pyx_t_7 = __Pyx_PyInt_From_uint8_t(__pyx_v_notification->GetButtonId()); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 533, __pyx_L58_error)
        __Pyx_GOTREF(__pyx_t_7);
        if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 533, __pyx_L58_error) }
        if (unlikely(PyDict_SetItem(__pyx_v_n, __pyx_n_s_buttonId, __pyx_t_7) < 0)) __PYX_ERR(0, 533, __pyx_L58_error)
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

        /* "libopenzwave.pyx":532
 *             raise
 *     elif notification.GetType() in (Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff):
 *         try:             # <<<<<<<<<<<<<<
 *             n['buttonId'] = notification.GetButtonId()
 *         except:
 */
      }
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      goto __pyx_L65_try_end;
      __pyx_L58_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;

      /* "libopenzwave.pyx":534
 *         try:
 *             n['buttonId'] = notification.GetButtonId()
 *         except:             # <<<<<<<<<<<<<<
 *             logger.exception("notif_callback exception Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff")
 *             raise
 */
      /*except:*/ {
        __Pyx_AddTraceback("libopenzwave.notif_callback", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_4, &__pyx_t_1) < 0) __PYX_ERR(0, 534, __pyx_L60_except_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_GOTREF(__pyx_t_1);

        /* "libopenzwave.pyx":535
 *             n['buttonId'] = notification.GetButtonId()
 *         except:
 *             logger.exception("notif_callback exception Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() == Type_DriverRemoved:
 */
        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 535, __pyx_L60_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_exception); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 535, __pyx_L60_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 535, __pyx_L60_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

        /* "libopenzwave.pyx":536
 *         except:
 *             logger.exception("notif_callback exception Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff")
 *             raise             # <<<<<<<<<<<<<<
 *     elif notification.GetType() == Type_DriverRemoved:
 *         try:
 */
        __Pyx_GIVEREF(__pyx_t_7);
        __Pyx_GIVEREF(__pyx_t_4);
        __Pyx_XGIVEREF(__pyx_t_1);
        __Pyx_ErrRestoreWithState(__pyx_t_7, __pyx_t_4, __pyx_t_1);
        __pyx_t_7 = 0; __pyx_t_4 = 0; __pyx_t_1 = 0; 
        __PYX_ERR(0, 536, __pyx_L60_except_error)
      }
      __pyx_L60_except_error:;

      /* "libopenzwave.pyx":532
 *             raise
 *     elif notification.GetType() in (Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff):
 *         try:             # <<<<<<<<<<<<<<
 *             n['buttonId'] = notification.GetButtonId()
 *         except:
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_9, __pyx_t_8);
      goto __pyx_L1_error;
      __pyx_L65_try_end:;
    }

    /* "libopenzwave.pyx":531
 *             logger.exception("notif_callback exception Type_ControllerCommand")
 *             raise
 *     elif notification.GetType() in (Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff):             # <<<<<<<<<<<<<<
 *         try:
 *             n['buttonId'] = notification.GetButtonId()
 */
    goto __pyx_L13;
  }

  /* "libopenzwave.pyx":537
 *             logger.exception("notif_callback exception Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff")
 *             raise
 *     elif notification.GetType() == Type_DriverRemoved:             # <<<<<<<<<<<<<<
 *         try:
 *             logger.debug("Notification : Type_DriverRemoved received : clean all valueids")
 */
  __pyx_t_13 = ((__pyx_v_notification->GetType() == OpenZWave::Notification::Type_DriverRemoved) != 0);
  if (__pyx_t_13) {

    /* "libopenzwave.pyx":538
 *             raise
 *     elif notification.GetType() == Type_DriverRemoved:
 *         try:             # <<<<<<<<<<<<<<
 *             logger.debug("Notification : Type_DriverRemoved received : clean all valueids")
 *             values_map.empty()
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_10);
      /*try:*/ {

        /* "libopenzwave.pyx":539
 *     elif notification.GetType() == Type_DriverRemoved:
 *         try:
 *             logger.debug("Notification : Type_DriverRemoved received : clean all valueids")             # <<<<<<<<<<<<<<
 *             values_map.empty()
 *         except:
 */
        __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 539, __pyx_L68_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_debug); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 539, __pyx_L68_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 539, __pyx_L68_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "libopenzwave.pyx":540
 *         try:
 *             logger.debug("Notification : Type_DriverRemoved received : clean all valueids")
 *             values_map.empty()             # <<<<<<<<<<<<<<
 *         except:
 *             logger.exception("notif_callback exception Type_DriverRemoved")
 */
        __pyx_v_12libopenzwave_values_map.empty();

        /* "libopenzwave.pyx":538
 *             raise
 *     elif notification.GetType() == Type_DriverRemoved:
 *         try:             # <<<<<<<<<<<<<<
 *             logger.debug("Notification : Type_DriverRemoved received : clean all valueids")
 *             values_map.empty()
 */
      }
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      goto __pyx_L75_try_end;
      __pyx_L68_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "libopenzwave.pyx":541
 *             logger.debug("Notification : Type_DriverRemoved received : clean all valueids")
 *             values_map.empty()
 *         except:             # <<<<<<<<<<<<<<
 *             logger.exception("notif_callback exception Type_DriverRemoved")
 *             raise
 */
      /*except:*/ {
        __Pyx_AddTraceback("libopenzwave.notif_callback", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_4, &__pyx_t_7) < 0) __PYX_ERR(0, 541, __pyx_L70_except_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_GOTREF(__pyx_t_7);

        /* "libopenzwave.pyx":542
 *             values_map.empty()
 *         except:
 *             logger.exception("notif_callback exception Type_DriverRemoved")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() == Type_DriverReset:
 */
        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 542, __pyx_L70_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_exception); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 542, __pyx_L70_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 542, __pyx_L70_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

        /* "libopenzwave.pyx":543
 *         except:
 *             logger.exception("notif_callback exception Type_DriverRemoved")
 *             raise             # <<<<<<<<<<<<<<
 *     elif notification.GetType() == Type_DriverReset:
 *         try:
 */
        __Pyx_GIVEREF(__pyx_t_1);
        __Pyx_GIVEREF(__pyx_t_4);
        __Pyx_XGIVEREF(__pyx_t_7);
        __Pyx_ErrRestoreWithState(__pyx_t_1, __pyx_t_4, __pyx_t_7);
        __pyx_t_1 = 0; __pyx_t_4 = 0; __pyx_t_7 = 0; 
        __PYX_ERR(0, 543, __pyx_L70_except_error)
      }
      __pyx_L70_except_error:;

      /* "libopenzwave.pyx":538
 *             raise
 *     elif notification.GetType() == Type_DriverRemoved:
 *         try:             # <<<<<<<<<<<<<<
 *             logger.debug("Notification : Type_DriverRemoved received : clean all valueids")
 *             values_map.empty()
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_ExceptionReset(__pyx_t_8, __pyx_t_9, __pyx_t_10);
      goto __pyx_L1_error;
      __pyx_L75_try_end:;
    }

    /* "libopenzwave.pyx":537
 *             logger.exception("notif_callback exception Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff")
 *             raise
 *     elif notification.GetType() == Type_DriverRemoved:             # <<<<<<<<<<<<<<
 *         try:
 *             logger.debug("Notification : Type_DriverRemoved received : clean all valueids")
 */
    goto __pyx_L13;
  }

  /* "libopenzwave.pyx":544
 *             logger.exception("notif_callback exception Type_DriverRemoved")
 *             raise
 *     elif notification.GetType() == Type_DriverReset:             # <<<<<<<<<<<<<<
 *         try:
 *             logger.debug("Notification : Type_DriverReset received : clean all valueids")
 */
  __pyx_t_13 = ((__pyx_v_notification->GetType() == OpenZWave::Notification::Type_DriverReset) != 0);
  if (__pyx_t_13) {

    /* "libopenzwave.pyx":545
 *             raise
 *     elif notification.GetType() == Type_DriverReset:
 *         try:             # <<<<<<<<<<<<<<
 *             logger.debug("Notification : Type_DriverReset received : clean all valueids")
 *             values_map.empty()
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_10, &__pyx_t_9, &__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_8);
      /*try:*/ {

        /* "libopenzwave.pyx":546
 *     elif notification.GetType() == Type_DriverReset:
 *         try:
 *             logger.debug("Notification : Type_DriverReset received : clean all valueids")             # <<<<<<<<<<<<<<
 *             values_map.empty()
 *         except:
 */
        __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 546, __pyx_L78_error)
        __Pyx_GOTREF(__pyx_t_7);
        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_debug); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 546, __pyx_L78_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 546, __pyx_L78_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

        /* "libopenzwave.pyx":547
 *         try:
 *             logger.debug("Notification : Type_DriverReset received : clean all valueids")
 *             values_map.empty()             # <<<<<<<<<<<<<<
 *         except:
 *             logger.exception("notif_callback exception Type_DriverReset")
 */
        __pyx_v_12libopenzwave_values_map.empty();

        /* "libopenzwave.pyx":545
 *             raise
 *     elif notification.GetType() == Type_DriverReset:
 *         try:             # <<<<<<<<<<<<<<
 *             logger.debug("Notification : Type_DriverReset received : clean all valueids")
 *             values_map.empty()
 */
      }
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      goto __pyx_L85_try_end;
      __pyx_L78_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;

      /* "libopenzwave.pyx":548
 *             logger.debug("Notification : Type_DriverReset received : clean all valueids")
 *             values_map.empty()
 *         except:             # <<<<<<<<<<<<<<
 *             logger.exception("notif_callback exception Type_DriverReset")
 *             raise
 */
      /*except:*/ {
        __Pyx_AddTraceback("libopenzwave.notif_callback", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_4, &__pyx_t_1) < 0) __PYX_ERR(0, 548, __pyx_L80_except_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_GOTREF(__pyx_t_1);

        /* "libopenzwave.pyx":549
 *             values_map.empty()
 *         except:
 *             logger.exception("notif_callback exception Type_DriverReset")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() == Type_SceneEvent:
 */
        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 549, __pyx_L80_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_exception); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 549, __pyx_L80_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 549, __pyx_L80_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

        /* "libopenzwave.pyx":550
 *         except:
 *             logger.exception("notif_callback exception Type_DriverReset")
 *             raise             # <<<<<<<<<<<<<<
 *     elif notification.GetType() == Type_SceneEvent:
 *         try:
 */
        __Pyx_GIVEREF(__pyx_t_7);
        __Pyx_GIVEREF(__pyx_t_4);
        __Pyx_XGIVEREF(__pyx_t_1);
        __Pyx_ErrRestoreWithState(__pyx_t_7, __pyx_t_4, __pyx_t_1);
        __pyx_t_7 = 0; __pyx_t_4 = 0; __pyx_t_1 = 0; 
        __PYX_ERR(0, 550, __pyx_L80_except_error)
      }
      __pyx_L80_except_error:;

      /* "libopenzwave.pyx":545
 *             raise
 *     elif notification.GetType() == Type_DriverReset:
 *         try:             # <<<<<<<<<<<<<<
 *             logger.debug("Notification : Type_DriverReset received : clean all valueids")
 *             values_map.empty()
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_9, __pyx_t_8);
      goto __pyx_L1_error;
      __pyx_L85_try_end:;
    }

    /* "libopenzwave.pyx":544
 *             logger.exception("notif_callback exception Type_DriverRemoved")
 *             raise
 *     elif notification.GetType() == Type_DriverReset:             # <<<<<<<<<<<<<<
 *         try:
 *             logger.debug("Notification : Type_DriverReset received : clean all valueids")
 */
    goto __pyx_L13;
  }

  /* "libopenzwave.pyx":551
 *             logger.exception("notif_callback exception Type_DriverReset")
 *             raise
 *     elif notification.GetType() == Type_SceneEvent:             # <<<<<<<<<<<<<<
 *         try:
 *             n['sceneId'] = notification.GetSceneId()
 */
  __pyx_t_13 = ((__pyx_v_notification->GetType() == OpenZWave::Notification::Type_SceneEvent) != 0);
  if (__pyx_t_13) {

    /* "libopenzwave.pyx":552
 *             raise
 *     elif notification.GetType() == Type_SceneEvent:
 *         try:             # <<<<<<<<<<<<<<
 *             n['sceneId'] = notification.GetSceneId()
 *         except:
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_10);
      /*try:*/ {

        /* "libopenzwave.pyx":553
 *     elif notification.GetType() == Type_SceneEvent:
 *         try:
 *             n['sceneId'] = notification.GetSceneId()             # <<<<<<<<<<<<<<
 *         except:
 *             logger.exception("notif_callback exception Type_SceneEvent")
 */
        __pyx_t_1 = __Pyx_PyInt_From_uint8_t(__pyx_v_notification->GetSceneId()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 553, __pyx_L88_error)
        __Pyx_GOTREF(__pyx_t_1);
        if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 553, __pyx_L88_error) }
        if (unlikely(PyDict_SetItem(__pyx_v_n, __pyx_n_s_sceneId, __pyx_t_1) < 0)) __PYX_ERR(0, 553, __pyx_L88_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "libopenzwave.pyx":552
 *             raise
 *     elif notification.GetType() == Type_SceneEvent:
 *         try:             # <<<<<<<<<<<<<<
 *             n['sceneId'] = notification.GetSceneId()
 *         except:
 */
      }
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      goto __pyx_L95_try_end;
      __pyx_L88_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "libopenzwave.pyx":554
 *         try:
 *             n['sceneId'] = notification.GetSceneId()
 *         except:             # <<<<<<<<<<<<<<
 *             logger.exception("notif_callback exception Type_SceneEvent")
 *             raise
 */
      /*except:*/ {
        __Pyx_AddTraceback("libopenzwave.notif_callback", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_4, &__pyx_t_7) < 0) __PYX_ERR(0, 554, __pyx_L90_except_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_GOTREF(__pyx_t_7);

        /* "libopenzwave.pyx":555
 *             n['sceneId'] = notification.GetSceneId()
 *         except:
 *             logger.exception("notif_callback exception Type_SceneEvent")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() in (Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed):
 */
        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 555, __pyx_L90_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_exception); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 555, __pyx_L90_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 555, __pyx_L90_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

        /* "libopenzwave.pyx":556
 *         except:
 *             logger.exception("notif_callback exception Type_SceneEvent")
 *             raise             # <<<<<<<<<<<<<<
 *     elif notification.GetType() in (Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed):
 *         try:
 */
        __Pyx_GIVEREF(__pyx_t_1);
        __Pyx_GIVEREF(__pyx_t_4);
        __Pyx_XGIVEREF(__pyx_t_7);
        __Pyx_ErrRestoreWithState(__pyx_t_1, __pyx_t_4, __pyx_t_7);
        __pyx_t_1 = 0; __pyx_t_4 = 0; __pyx_t_7 = 0; 
        __PYX_ERR(0, 556, __pyx_L90_except_error)
      }
      __pyx_L90_except_error:;

      /* "libopenzwave.pyx":552
 *             raise
 *     elif notification.GetType() == Type_SceneEvent:
 *         try:             # <<<<<<<<<<<<<<
 *             n['sceneId'] = notification.GetSceneId()
 *         except:
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_ExceptionReset(__pyx_t_8, __pyx_t_9, __pyx_t_10);
      goto __pyx_L1_error;
      __pyx_L95_try_end:;
    }

    /* "libopenzwave.pyx":551
 *             logger.exception("notif_callback exception Type_DriverReset")
 *             raise
 *     elif notification.GetType() == Type_SceneEvent:             # <<<<<<<<<<<<<<
 *         try:
 *             n['sceneId'] = notification.GetSceneId()
 */
    goto __pyx_L13;
  }

  /* "libopenzwave.pyx":557
 *             logger.exception("notif_callback exception Type_SceneEvent")
 *             raise
 *     elif notification.GetType() in (Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed):             # <<<<<<<<<<<<<<
 *         try:
 *             addValueId(notification.GetValueID(), n)
 */
  __pyx_t_12 = __pyx_v_notification->GetType();
  __pyx_t_11 = ((__pyx_t_12 == OpenZWave::Notification::Type_ValueAdded) != 0);
  if (!__pyx_t_11) {
  } else {
    __pyx_t_13 = __pyx_t_11;
    goto __pyx_L98_bool_binop_done;
  }
  __pyx_t_11 = ((__pyx_t_12 == OpenZWave::Notification::Type_ValueChanged) != 0);
  if (!__pyx_t_11) {
  } else {
    __pyx_t_13 = __pyx_t_11;
    goto __pyx_L98_bool_binop_done;
  }
  __pyx_t_11 = ((__pyx_t_12 == OpenZWave::Notification::Type_ValueRefreshed) != 0);
  __pyx_t_13 = __pyx_t_11;
  __pyx_L98_bool_binop_done:;
  __pyx_t_11 = (__pyx_t_13 != 0);
  if (__pyx_t_11) {

    /* "libopenzwave.pyx":558
 *             raise
 *     elif notification.GetType() in (Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed):
 *         try:             # <<<<<<<<<<<<<<
 *             addValueId(notification.GetValueID(), n)
 *         except:
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_10, &__pyx_t_9, &__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_8);
      /*try:*/ {

        /* "libopenzwave.pyx":559
 *     elif notification.GetType() in (Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed):
 *         try:
 *             addValueId(notification.GetValueID(), n)             # <<<<<<<<<<<<<<
 *         except:
 *             logger.exception("notif_callback exception Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed")
 */
        if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 559, __pyx_L101_error) }
        __pyx_t_7 = __pyx_f_12libopenzwave_addValueId(__pyx_v_notification->GetValueID(), __pyx_v_n); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 559, __pyx_L101_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

        /* "libopenzwave.pyx":558
 *             raise
 *     elif notification.GetType() in (Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed):
 *         try:             # <<<<<<<<<<<<<<
 *             addValueId(notification.GetValueID(), n)
 *         except:
 */
      }
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      goto __pyx_L108_try_end;
      __pyx_L101_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;

      /* "libopenzwave.pyx":560
 *         try:
 *             addValueId(notification.GetValueID(), n)
 *         except:             # <<<<<<<<<<<<<<
 *             logger.exception("notif_callback exception Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed")
 *             raise
 */
      /*except:*/ {
        __Pyx_AddTraceback("libopenzwave.notif_callback", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_4, &__pyx_t_1) < 0) __PYX_ERR(0, 560, __pyx_L103_except_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_GOTREF(__pyx_t_1);

        /* "libopenzwave.pyx":561
 *             addValueId(notification.GetValueID(), n)
 *         except:
 *             logger.exception("notif_callback exception Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() == Type_ValueRemoved:
 */
        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 561, __pyx_L103_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_exception); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 561, __pyx_L103_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 561, __pyx_L103_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

        /* "libopenzwave.pyx":562
 *         except:
 *             logger.exception("notif_callback exception Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed")
 *             raise             # <<<<<<<<<<<<<<
 *     elif notification.GetType() == Type_ValueRemoved:
 *         try:
 */
        __Pyx_GIVEREF(__pyx_t_7);
        __Pyx_GIVEREF(__pyx_t_4);
        __Pyx_XGIVEREF(__pyx_t_1);
        __Pyx_ErrRestoreWithState(__pyx_t_7, __pyx_t_4, __pyx_t_1);
        __pyx_t_7 = 0; __pyx_t_4 = 0; __pyx_t_1 = 0; 
        __PYX_ERR(0, 562, __pyx_L103_except_error)
      }
      __pyx_L103_except_error:;

      /* "libopenzwave.pyx":558
 *             raise
 *     elif notification.GetType() in (Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed):
 *         try:             # <<<<<<<<<<<<<<
 *             addValueId(notification.GetValueID(), n)
 *         except:
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_9, __pyx_t_8);
      goto __pyx_L1_error;
      __pyx_L108_try_end:;
    }

    /* "libopenzwave.pyx":557
 *             logger.exception("notif_callback exception Type_SceneEvent")
 *             raise
 *     elif notification.GetType() in (Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed):             # <<<<<<<<<<<<<<
 *         try:
 *             addValueId(notification.GetValueID(), n)
 */
    goto __pyx_L13;
  }

  /* "libopenzwave.pyx":563
 *             logger.exception("notif_callback exception Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed")
 *             raise
 *     elif notification.GetType() == Type_ValueRemoved:             # <<<<<<<<<<<<<<
 *         try:
 *             n['valueId'] = {'id' : notification.GetValueID().GetId()}
 */
  __pyx_t_11 = ((__pyx_v_notification->GetType() == OpenZWave::Notification::Type_ValueRemoved) != 0);
  if (__pyx_t_11) {

    /* "libopenzwave.pyx":564
 *             raise
 *     elif notification.GetType() == Type_ValueRemoved:
 *         try:             # <<<<<<<<<<<<<<
 *             n['valueId'] = {'id' : notification.GetValueID().GetId()}
 *         except:
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_10);
      /*try:*/ {

        /* "libopenzwave.pyx":565
 *     elif notification.GetType() == Type_ValueRemoved:
 *         try:
 *             n['valueId'] = {'id' : notification.GetValueID().GetId()}             # <<<<<<<<<<<<<<
 *         except:
 *             logger.exception("notif_callback exception Type_ValueRemoved")
 */
        __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 565, __pyx_L111_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_4 = __Pyx_PyInt_From_uint64_t(__pyx_v_notification->GetValueID().GetId()); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 565, __pyx_L111_error)
        __Pyx_GOTREF(__pyx_t_4);
        if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_id, __pyx_t_4) < 0) __PYX_ERR(0, 565, __pyx_L111_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 565, __pyx_L111_error) }
        if (unlikely(PyDict_SetItem(__pyx_v_n, __pyx_n_s_valueId, __pyx_t_1) < 0)) __PYX_ERR(0, 565, __pyx_L111_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "libopenzwave.pyx":564
 *             raise
 *     elif notification.GetType() == Type_ValueRemoved:
 *         try:             # <<<<<<<<<<<<<<
 *             n['valueId'] = {'id' : notification.GetValueID().GetId()}
 *         except:
 */
      }
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      goto __pyx_L118_try_end;
      __pyx_L111_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "libopenzwave.pyx":566
 *         try:
 *             n['valueId'] = {'id' : notification.GetValueID().GetId()}
 *         except:             # <<<<<<<<<<<<<<
 *             logger.exception("notif_callback exception Type_ValueRemoved")
 *             raise
 */
      /*except:*/ {
        __Pyx_AddTraceback("libopenzwave.notif_callback", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_4, &__pyx_t_7) < 0) __PYX_ERR(0, 566, __pyx_L113_except_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_GOTREF(__pyx_t_7);

        /* "libopenzwave.pyx":567
 *             n['valueId'] = {'id' : notification.GetValueID().GetId()}
 *         except:
 *             logger.exception("notif_callback exception Type_ValueRemoved")             # <<<<<<<<<<<<<<
 *             raise
 *     #elif notification.GetType() in (Type_PollingEnabled, Type_PollingDisabled):
 */
        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 567, __pyx_L113_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_exception); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 567, __pyx_L113_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 567, __pyx_L113_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

        /* "libopenzwave.pyx":568
 *         except:
 *             logger.exception("notif_callback exception Type_ValueRemoved")
 *             raise             # <<<<<<<<<<<<<<
 *     #elif notification.GetType() in (Type_PollingEnabled, Type_PollingDisabled):
 *     #    #Maybe we should enable/disable this
 */
        __Pyx_GIVEREF(__pyx_t_1);
        __Pyx_GIVEREF(__pyx_t_4);
        __Pyx_XGIVEREF(__pyx_t_7);
        __Pyx_ErrRestoreWithState(__pyx_t_1, __pyx_t_4, __pyx_t_7);
        __pyx_t_1 = 0; __pyx_t_4 = 0; __pyx_t_7 = 0; 
        __PYX_ERR(0, 568, __pyx_L113_except_error)
      }
      __pyx_L113_except_error:;

      /* "libopenzwave.pyx":564
 *             raise
 *     elif notification.GetType() == Type_ValueRemoved:
 *         try:             # <<<<<<<<<<<<<<
 *             n['valueId'] = {'id' : notification.GetValueID().GetId()}
 *         except:
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_ExceptionReset(__pyx_t_8, __pyx_t_9, __pyx_t_10);
      goto __pyx_L1_error;
      __pyx_L118_try_end:;
    }

    /* "libopenzwave.pyx":563
 *             logger.exception("notif_callback exception Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed")
 *             raise
 *     elif notification.GetType() == Type_ValueRemoved:             # <<<<<<<<<<<<<<
 *         try:
 *             n['valueId'] = {'id' : notification.GetValueID().GetId()}
 */
  }
  __pyx_L13:;

  /* "libopenzwave.pyx":572
 *     #    #Maybe we should enable/disable this
 *     #    addValueId(notification.GetValueID(), n)
 *     logger.debug("notif_callback : call callback context")             # <<<<<<<<<<<<<<
 *     (<object>_context)(n)
 *     if notification.GetType() == Type_ValueRemoved:
 */
  __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 572, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_debug); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 572, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 572, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

  /* "libopenzwave.pyx":573
 *     #    addValueId(notification.GetValueID(), n)
 *     logger.debug("notif_callback : call callback context")
 *     (<object>_context)(n)             # <<<<<<<<<<<<<<
 *     if notification.GetType() == Type_ValueRemoved:
 *         try:
 */
  if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 573, __pyx_L1_error) }
  __Pyx_INCREF(((PyObject *)__pyx_v__context));
  __pyx_t_4 = ((PyObject *)__pyx_v__context); __pyx_t_1 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  if (!__pyx_t_1) {
    __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_n); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 573, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[2] = {__pyx_t_1, __pyx_v_n};
      __pyx_t_7 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 573, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_GOTREF(__pyx_t_7);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[2] = {__pyx_t_1, __pyx_v_n};
      __pyx_t_7 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 573, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_GOTREF(__pyx_t_7);
    } else
    #endif
    {
      __pyx_t_3 = PyTuple_New(1+1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 573, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1); __pyx_t_1 = NULL;
      __Pyx_INCREF(__pyx_v_n);
      __Pyx_GIVEREF(__pyx_v_n);
      PyTuple_SET_ITEM(__pyx_t_3, 0+1, __pyx_v_n);
      __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 573, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

  /* "libopenzwave.pyx":574
 *     logger.debug("notif_callback : call callback context")
 *     (<object>_context)(n)
 *     if notification.GetType() == Type_ValueRemoved:             # <<<<<<<<<<<<<<
 *         try:
 *             delValueId(notification.GetValueID(), n)
 */
  __pyx_t_11 = ((__pyx_v_notification->GetType() == OpenZWave::Notification::Type_ValueRemoved) != 0);
  if (__pyx_t_11) {

    /* "libopenzwave.pyx":575
 *     (<object>_context)(n)
 *     if notification.GetType() == Type_ValueRemoved:
 *         try:             # <<<<<<<<<<<<<<
 *             delValueId(notification.GetValueID(), n)
 *         except:
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_10, &__pyx_t_9, &__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_8);
      /*try:*/ {

        /* "libopenzwave.pyx":576
 *     if notification.GetType() == Type_ValueRemoved:
 *         try:
 *             delValueId(notification.GetValueID(), n)             # <<<<<<<<<<<<<<
 *         except:
 *             logger.exception("notif_callback exception Type_ValueRemoved delete")
 */
        if (unlikely(!__pyx_v_n)) { __Pyx_RaiseUnboundLocalError("n"); __PYX_ERR(0, 576, __pyx_L122_error) }
        __pyx_t_7 = __pyx_f_12libopenzwave_delValueId(__pyx_v_notification->GetValueID(), __pyx_v_n); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 576, __pyx_L122_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

        /* "libopenzwave.pyx":575
 *     (<object>_context)(n)
 *     if notification.GetType() == Type_ValueRemoved:
 *         try:             # <<<<<<<<<<<<<<
 *             delValueId(notification.GetValueID(), n)
 *         except:
 */
      }
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      goto __pyx_L129_try_end;
      __pyx_L122_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;

      /* "libopenzwave.pyx":577
 *         try:
 *             delValueId(notification.GetValueID(), n)
 *         except:             # <<<<<<<<<<<<<<
 *             logger.exception("notif_callback exception Type_ValueRemoved delete")
 *             raise
 */
      /*except:*/ {
        __Pyx_AddTraceback("libopenzwave.notif_callback", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_4, &__pyx_t_3) < 0) __PYX_ERR(0, 577, __pyx_L124_except_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_GOTREF(__pyx_t_3);

        /* "libopenzwave.pyx":578
 *             delValueId(notification.GetValueID(), n)
 *         except:
 *             logger.exception("notif_callback exception Type_ValueRemoved delete")             # <<<<<<<<<<<<<<
 *             raise
 *     logger.debug("notif_callback : end")
 */
        __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 578, __pyx_L124_except_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_exception); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 578, __pyx_L124_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 578, __pyx_L124_except_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "libopenzwave.pyx":579
 *         except:
 *             logger.exception("notif_callback exception Type_ValueRemoved delete")
 *             raise             # <<<<<<<<<<<<<<
 *     logger.debug("notif_callback : end")
 * 
 */
        __Pyx_GIVEREF(__pyx_t_7);
        __Pyx_GIVEREF(__pyx_t_4);
        __Pyx_XGIVEREF(__pyx_t_3);
        __Pyx_ErrRestoreWithState(__pyx_t_7, __pyx_t_4, __pyx_t_3);
        __pyx_t_7 = 0; __pyx_t_4 = 0; __pyx_t_3 = 0; 
        __PYX_ERR(0, 579, __pyx_L124_except_error)
      }
      __pyx_L124_except_error:;

      /* "libopenzwave.pyx":575
 *     (<object>_context)(n)
 *     if notification.GetType() == Type_ValueRemoved:
 *         try:             # <<<<<<<<<<<<<<
 *             delValueId(notification.GetValueID(), n)
 *         except:
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_9, __pyx_t_8);
      goto __pyx_L1_error;
      __pyx_L129_try_end:;
    }

    /* "libopenzwave.pyx":574
 *     logger.debug("notif_callback : call callback context")
 *     (<object>_context)(n)
 *     if notification.GetType() == Type_ValueRemoved:             # <<<<<<<<<<<<<<
 *         try:
 *             delValueId(notification.GetValueID(), n)
 */
  }

  /* "libopenzwave.pyx":580
 *             logger.exception("notif_callback exception Type_ValueRemoved delete")
 *             raise
 *     logger.debug("notif_callback : end")             # <<<<<<<<<<<<<<
 * 
 * cdef void ctrl_callback(ControllerState _state, ControllerError _error, void* _context) with gil:
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 580, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_debug); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 580, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 580, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":485
 *     logger.debug("addValueId : Notification : %s", n)
 * 
 * cdef void notif_callback(const_notification _notification, void* _context) with gil:             # <<<<<<<<<<<<<<
 *     """
 *     Notification callback to the C++ library
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_WriteUnraisable("libopenzwave.notif_callback", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_n);
  __Pyx_RefNannyFinishContext();
  #ifdef WITH_THREAD
  PyGILState_Release(__pyx_gilstate_save);
  #endif
}

/* "libopenzwave.pyx":582
 *     logger.debug("notif_callback : end")
 * 
 * cdef void ctrl_callback(ControllerState _state, ControllerError _error, void* _context) with gil:             # <<<<<<<<<<<<<<
 *     """
 *     Controller callback to the C++ library
 */

static void __pyx_f_12libopenzwave_ctrl_callback(enum OpenZWave::Driver::ControllerState __pyx_v__state, enum OpenZWave::Driver::ControllerError __pyx_v__error, void *__pyx_v__context) {
  PyObject *__pyx_v_c = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  #ifdef WITH_THREAD
  PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();
  #endif
  __Pyx_RefNannySetupContext("ctrl_callback", 0);

  /* "libopenzwave.pyx":587
 * 
 *     """
 *     c = {'state' : PyControllerState[_state],             # <<<<<<<<<<<<<<
 *          'message' : PyControllerState[_state].doc,
 *          'error' : _error,
 */
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 587, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyControllerState); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 587, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerState(__pyx_v__state); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 587, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PyObject_GetItem(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 587, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_state, __pyx_t_4) < 0) __PYX_ERR(0, 587, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "libopenzwave.pyx":588
 *     """
 *     c = {'state' : PyControllerState[_state],
 *          'message' : PyControllerState[_state].doc,             # <<<<<<<<<<<<<<
 *          'error' : _error,
 *          'error_msg' : PyControllerError[_error].doc,
 */
  __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyControllerState); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 588, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerState(__pyx_v__state); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 588, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyObject_GetItem(__pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 588, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_doc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 588, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_message, __pyx_t_3) < 0) __PYX_ERR(0, 587, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":589
 *     c = {'state' : PyControllerState[_state],
 *          'message' : PyControllerState[_state].doc,
 *          'error' : _error,             # <<<<<<<<<<<<<<
 *          'error_msg' : PyControllerError[_error].doc,
 *         }
 */
  __pyx_t_3 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerError(__pyx_v__error); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 589, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_error, __pyx_t_3) < 0) __PYX_ERR(0, 587, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":590
 *          'message' : PyControllerState[_state].doc,
 *          'error' : _error,
 *          'error_msg' : PyControllerError[_error].doc,             # <<<<<<<<<<<<<<
 *         }
 *     logger.debug("ctrl_callback : Message: %s", c)
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyControllerError); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 590, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerError(__pyx_v__error); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 590, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = PyObject_GetItem(__pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 590, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_doc); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 590, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_error_msg, __pyx_t_2) < 0) __PYX_ERR(0, 587, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_c = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "libopenzwave.pyx":592
 *          'error_msg' : PyControllerError[_error].doc,
 *         }
 *     logger.debug("ctrl_callback : Message: %s", c)             # <<<<<<<<<<<<<<
 *     (<object>_context)(c)
 * 
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 592, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_debug); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 592, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  __pyx_t_5 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
      __pyx_t_5 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_kp_s_ctrl_callback_Message_s, __pyx_v_c};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 592, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_kp_s_ctrl_callback_Message_s, __pyx_v_c};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 592, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_3 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 592, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (__pyx_t_2) {
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2); __pyx_t_2 = NULL;
    }
    __Pyx_INCREF(__pyx_kp_s_ctrl_callback_Message_s);
    __Pyx_GIVEREF(__pyx_kp_s_ctrl_callback_Message_s);
    PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_5, __pyx_kp_s_ctrl_callback_Message_s);
    __Pyx_INCREF(__pyx_v_c);
    __Pyx_GIVEREF(__pyx_v_c);
    PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_5, __pyx_v_c);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 592, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":593
 *         }
 *     logger.debug("ctrl_callback : Message: %s", c)
 *     (<object>_context)(c)             # <<<<<<<<<<<<<<
 * 
 * cpdef object driverData():
 */
  __Pyx_INCREF(((PyObject *)__pyx_v__context));
  __pyx_t_4 = ((PyObject *)__pyx_v__context); __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  if (!__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_c); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 593, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_v_c};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 593, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_v_c};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 593, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_2 = PyTuple_New(1+1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 593, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3); __pyx_t_3 = NULL;
      __Pyx_INCREF(__pyx_v_c);
      __Pyx_GIVEREF(__pyx_v_c);
      PyTuple_SET_ITEM(__pyx_t_2, 0+1, __pyx_v_c);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 593, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":582
 *     logger.debug("notif_callback : end")
 * 
 * cdef void ctrl_callback(ControllerState _state, ControllerError _error, void* _context) with gil:             # <<<<<<<<<<<<<<
 *     """
 *     Controller callback to the C++ library
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("libopenzwave.ctrl_callback", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_c);
  __Pyx_RefNannyFinishContext();
  #ifdef WITH_THREAD
  PyGILState_Release(__pyx_gilstate_save);
  #endif
}

/* "libopenzwave.pyx":595
 *     (<object>_context)(c)
 * 
 * cpdef object driverData():             # <<<<<<<<<<<<<<
 *     cdef DriverData data
 * 
 */

static PyObject *__pyx_pw_12libopenzwave_1driverData(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_12libopenzwave_driverData(CYTHON_UNUSED int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("driverData", 0);

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_1driverData(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_12libopenzwave_1driverData(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("driverData (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_driverData(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_driverData(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("driverData", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_12libopenzwave_driverData(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 595, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.driverData", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":598
 *     cdef DriverData data
 * 
 * def configPath():             # <<<<<<<<<<<<<<
 *     '''
 *     Retrieve the config path. This directory hold the xml files.
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_3configPath(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_2configPath[] = "\n    Retrieve the config path. This directory hold the xml files.\n\n    :return: A string containing the library config path or None.\n    :rtype: str\n\n    ";
static PyMethodDef __pyx_mdef_12libopenzwave_3configPath = {"configPath", (PyCFunction)__pyx_pw_12libopenzwave_3configPath, METH_NOARGS, __pyx_doc_12libopenzwave_2configPath};
static PyObject *__pyx_pw_12libopenzwave_3configPath(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("configPath (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_2configPath(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_2configPath(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_v_dirn = NULL;
  PyObject *__pyx_v_resource_filename = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_t_10;
  int __pyx_t_11;
  int __pyx_t_12;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  PyObject *__pyx_t_16 = NULL;
  __Pyx_RefNannySetupContext("configPath", 0);

  /* "libopenzwave.pyx":606
 * 
 *     '''
 *     if os.path.isfile(os.path.join("/etc/openzwave/",'device_classes.xml')):             # <<<<<<<<<<<<<<
 *         #At first, check in /etc/openzwave
 *         return "/etc/openzwave/"
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 606, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_path); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 606, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_isfile); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 606, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 606, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_path); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 606, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_join); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 606, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 606, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 606, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_t_4};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 606, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_t_4};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 606, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    } else
    #endif
    {
      __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 606, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
      __Pyx_GIVEREF(__pyx_t_4);
      PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 606, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 606, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_6) {

    /* "libopenzwave.pyx":608
 *     if os.path.isfile(os.path.join("/etc/openzwave/",'device_classes.xml')):
 *         #At first, check in /etc/openzwave
 *         return "/etc/openzwave/"             # <<<<<<<<<<<<<<
 *     elif os.path.isfile(os.path.join("/usr/local/etc/openzwave/",'device_classes.xml')):
 *         #Next, check in /usr/local/etc/openzwave
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_kp_s_etc_openzwave);
    __pyx_r = __pyx_kp_s_etc_openzwave;
    goto __pyx_L0;

    /* "libopenzwave.pyx":606
 * 
 *     '''
 *     if os.path.isfile(os.path.join("/etc/openzwave/",'device_classes.xml')):             # <<<<<<<<<<<<<<
 *         #At first, check in /etc/openzwave
 *         return "/etc/openzwave/"
 */
  }

  /* "libopenzwave.pyx":609
 *         #At first, check in /etc/openzwave
 *         return "/etc/openzwave/"
 *     elif os.path.isfile(os.path.join("/usr/local/etc/openzwave/",'device_classes.xml')):             # <<<<<<<<<<<<<<
 *         #Next, check in /usr/local/etc/openzwave
 *         return "/usr/local/etc/openzwave/"
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 609, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_path); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 609, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_isfile); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 609, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 609, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_path); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 609, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_join); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 609, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 609, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_5) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 609, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_t_4};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 609, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_t_4};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 609, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    } else
    #endif
    {
      __pyx_t_3 = PyTuple_New(1+1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 609, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5); __pyx_t_5 = NULL;
      __Pyx_GIVEREF(__pyx_t_4);
      PyTuple_SET_ITEM(__pyx_t_3, 0+1, __pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 609, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 609, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_6) {

    /* "libopenzwave.pyx":611
 *     elif os.path.isfile(os.path.join("/usr/local/etc/openzwave/",'device_classes.xml')):
 *         #Next, check in /usr/local/etc/openzwave
 *         return "/usr/local/etc/openzwave/"             # <<<<<<<<<<<<<<
 *     else :
 *         #Check in python_openzwave.resources
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_kp_s_usr_local_etc_openzwave);
    __pyx_r = __pyx_kp_s_usr_local_etc_openzwave;
    goto __pyx_L0;

    /* "libopenzwave.pyx":609
 *         #At first, check in /etc/openzwave
 *         return "/etc/openzwave/"
 *     elif os.path.isfile(os.path.join("/usr/local/etc/openzwave/",'device_classes.xml')):             # <<<<<<<<<<<<<<
 *         #Next, check in /usr/local/etc/openzwave
 *         return "/usr/local/etc/openzwave/"
 */
  }

  /* "libopenzwave.pyx":614
 *     else :
 *         #Check in python_openzwave.resources
 *         dirn = None             # <<<<<<<<<<<<<<
 *         try:
 *             from pkg_resources import resource_filename
 */
  /*else*/ {
    __Pyx_INCREF(Py_None);
    __pyx_v_dirn = Py_None;

    /* "libopenzwave.pyx":615
 *         #Check in python_openzwave.resources
 *         dirn = None
 *         try:             # <<<<<<<<<<<<<<
 *             from pkg_resources import resource_filename
 *             dirn = resource_filename('python_openzwave.ozw_config', '__init__.py')
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_9);
      /*try:*/ {

        /* "libopenzwave.pyx":616
 *         dirn = None
 *         try:
 *             from pkg_resources import resource_filename             # <<<<<<<<<<<<<<
 *             dirn = resource_filename('python_openzwave.ozw_config', '__init__.py')
 *             dirn = os.path.dirname(dirn)
 */
        __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 616, __pyx_L4_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_INCREF(__pyx_n_s_resource_filename);
        __Pyx_GIVEREF(__pyx_n_s_resource_filename);
        PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_resource_filename);
        __pyx_t_2 = __Pyx_Import(__pyx_n_s_pkg_resources, __pyx_t_1, -1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 616, __pyx_L4_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_resource_filename); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 616, __pyx_L4_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_1);
        __pyx_v_resource_filename = __pyx_t_1;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

        /* "libopenzwave.pyx":617
 *         try:
 *             from pkg_resources import resource_filename
 *             dirn = resource_filename('python_openzwave.ozw_config', '__init__.py')             # <<<<<<<<<<<<<<
 *             dirn = os.path.dirname(dirn)
 *         except ImportError:
 */
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_v_resource_filename, __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 617, __pyx_L4_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF_SET(__pyx_v_dirn, __pyx_t_2);
        __pyx_t_2 = 0;

        /* "libopenzwave.pyx":618
 *             from pkg_resources import resource_filename
 *             dirn = resource_filename('python_openzwave.ozw_config', '__init__.py')
 *             dirn = os.path.dirname(dirn)             # <<<<<<<<<<<<<<
 *         except ImportError:
 *             dirn = None
 */
        __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 618, __pyx_L4_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_path); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 618, __pyx_L4_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_dirname); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 618, __pyx_L4_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = NULL;
        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
          __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
          if (likely(__pyx_t_3)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
            __Pyx_INCREF(__pyx_t_3);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_1, function);
          }
        }
        if (!__pyx_t_3) {
          __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_dirn); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 618, __pyx_L4_error)
          __Pyx_GOTREF(__pyx_t_2);
        } else {
          #if CYTHON_FAST_PYCALL
          if (PyFunction_Check(__pyx_t_1)) {
            PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_v_dirn};
            __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 618, __pyx_L4_error)
            __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
            __Pyx_GOTREF(__pyx_t_2);
          } else
          #endif
          #if CYTHON_FAST_PYCCALL
          if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
            PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_v_dirn};
            __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 618, __pyx_L4_error)
            __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
            __Pyx_GOTREF(__pyx_t_2);
          } else
          #endif
          {
            __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 618, __pyx_L4_error)
            __Pyx_GOTREF(__pyx_t_4);
            __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3); __pyx_t_3 = NULL;
            __Pyx_INCREF(__pyx_v_dirn);
            __Pyx_GIVEREF(__pyx_v_dirn);
            PyTuple_SET_ITEM(__pyx_t_4, 0+1, __pyx_v_dirn);
            __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_4, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 618, __pyx_L4_error)
            __Pyx_GOTREF(__pyx_t_2);
            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
          }
        }
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_DECREF_SET(__pyx_v_dirn, __pyx_t_2);
        __pyx_t_2 = 0;

        /* "libopenzwave.pyx":615
 *         #Check in python_openzwave.resources
 *         dirn = None
 *         try:             # <<<<<<<<<<<<<<
 *             from pkg_resources import resource_filename
 *             dirn = resource_filename('python_openzwave.ozw_config', '__init__.py')
 */
      }
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      goto __pyx_L11_try_end;
      __pyx_L4_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;

      /* "libopenzwave.pyx":619
 *             dirn = resource_filename('python_openzwave.ozw_config', '__init__.py')
 *             dirn = os.path.dirname(dirn)
 *         except ImportError:             # <<<<<<<<<<<<<<
 *             dirn = None
 *         if dirn is not None  and os.path.isfile(os.path.join(dirn,'device_classes.xml')):
 */
      __pyx_t_10 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_ImportError);
      if (__pyx_t_10) {
        __Pyx_AddTraceback("libopenzwave.configPath", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_1, &__pyx_t_4) < 0) __PYX_ERR(0, 619, __pyx_L6_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_GOTREF(__pyx_t_4);

        /* "libopenzwave.pyx":620
 *             dirn = os.path.dirname(dirn)
 *         except ImportError:
 *             dirn = None             # <<<<<<<<<<<<<<
 *         if dirn is not None  and os.path.isfile(os.path.join(dirn,'device_classes.xml')):
 *             #At first, check in /etc/openzwave
 */
        __Pyx_INCREF(Py_None);
        __Pyx_DECREF_SET(__pyx_v_dirn, Py_None);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        goto __pyx_L5_exception_handled;
      }
      goto __pyx_L6_except_error;
      __pyx_L6_except_error:;

      /* "libopenzwave.pyx":615
 *         #Check in python_openzwave.resources
 *         dirn = None
 *         try:             # <<<<<<<<<<<<<<
 *             from pkg_resources import resource_filename
 *             dirn = resource_filename('python_openzwave.ozw_config', '__init__.py')
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_7);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
      goto __pyx_L1_error;
      __pyx_L5_exception_handled:;
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_7);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
      __pyx_L11_try_end:;
    }

    /* "libopenzwave.pyx":621
 *         except ImportError:
 *             dirn = None
 *         if dirn is not None  and os.path.isfile(os.path.join(dirn,'device_classes.xml')):             # <<<<<<<<<<<<<<
 *             #At first, check in /etc/openzwave
 *             return dirn
 */
    __pyx_t_11 = (__pyx_v_dirn != Py_None);
    __pyx_t_12 = (__pyx_t_11 != 0);
    if (__pyx_t_12) {
    } else {
      __pyx_t_6 = __pyx_t_12;
      goto __pyx_L15_bool_binop_done;
    }
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 621, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_path); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 621, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_isfile); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 621, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 621, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_path); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 621, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_join); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 621, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = NULL;
    __pyx_t_10 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
        __pyx_t_10 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_dirn, __pyx_kp_s_device_classes_xml};
      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 621, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_2);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_dirn, __pyx_kp_s_device_classes_xml};
      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 621, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_2);
    } else
    #endif
    {
      __pyx_t_13 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 621, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_13);
      if (__pyx_t_5) {
        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_13, 0, __pyx_t_5); __pyx_t_5 = NULL;
      }
      __Pyx_INCREF(__pyx_v_dirn);
      __Pyx_GIVEREF(__pyx_v_dirn);
      PyTuple_SET_ITEM(__pyx_t_13, 0+__pyx_t_10, __pyx_v_dirn);
      __Pyx_INCREF(__pyx_kp_s_device_classes_xml);
      __Pyx_GIVEREF(__pyx_kp_s_device_classes_xml);
      PyTuple_SET_ITEM(__pyx_t_13, 1+__pyx_t_10, __pyx_kp_s_device_classes_xml);
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_13, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 621, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    if (!__pyx_t_3) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 621, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_1)) {
        PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_t_2};
        __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 621, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
        PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_t_2};
        __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 621, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      } else
      #endif
      {
        __pyx_t_13 = PyTuple_New(1+1); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 621, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_13);
        __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_13, 0, __pyx_t_3); __pyx_t_3 = NULL;
        __Pyx_GIVEREF(__pyx_t_2);
        PyTuple_SET_ITEM(__pyx_t_13, 0+1, __pyx_t_2);
        __pyx_t_2 = 0;
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_13, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 621, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_12 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_12 < 0)) __PYX_ERR(0, 621, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = __pyx_t_12;
    __pyx_L15_bool_binop_done:;
    if (__pyx_t_6) {

      /* "libopenzwave.pyx":623
 *         if dirn is not None  and os.path.isfile(os.path.join(dirn,'device_classes.xml')):
 *             #At first, check in /etc/openzwave
 *             return dirn             # <<<<<<<<<<<<<<
 *         elif os.path.isfile(os.path.join("openzwave/config",'device_classes.xml')):
 *             return os.path.abspath('openzwave/config')
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_v_dirn);
      __pyx_r = __pyx_v_dirn;
      goto __pyx_L0;

      /* "libopenzwave.pyx":621
 *         except ImportError:
 *             dirn = None
 *         if dirn is not None  and os.path.isfile(os.path.join(dirn,'device_classes.xml')):             # <<<<<<<<<<<<<<
 *             #At first, check in /etc/openzwave
 *             return dirn
 */
    }

    /* "libopenzwave.pyx":624
 *             #At first, check in /etc/openzwave
 *             return dirn
 *         elif os.path.isfile(os.path.join("openzwave/config",'device_classes.xml')):             # <<<<<<<<<<<<<<
 *             return os.path.abspath('openzwave/config')
 *         #For historical reasons.
 */
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 624, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_path); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 624, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_13);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_13, __pyx_n_s_isfile); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 624, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    __pyx_t_13 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 624, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_13);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_13, __pyx_n_s_path); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 624, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_join); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 624, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_13);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_13, __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 624, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    __pyx_t_13 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_13)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_13);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    if (!__pyx_t_13) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 624, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_1)) {
        PyObject *__pyx_temp[2] = {__pyx_t_13, __pyx_t_2};
        __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 624, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
        PyObject *__pyx_temp[2] = {__pyx_t_13, __pyx_t_2};
        __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 624, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      } else
      #endif
      {
        __pyx_t_3 = PyTuple_New(1+1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 624, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_GIVEREF(__pyx_t_13); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_13); __pyx_t_13 = NULL;
        __Pyx_GIVEREF(__pyx_t_2);
        PyTuple_SET_ITEM(__pyx_t_3, 0+1, __pyx_t_2);
        __pyx_t_2 = 0;
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 624, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 624, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (__pyx_t_6) {

      /* "libopenzwave.pyx":625
 *             return dirn
 *         elif os.path.isfile(os.path.join("openzwave/config",'device_classes.xml')):
 *             return os.path.abspath('openzwave/config')             # <<<<<<<<<<<<<<
 *         #For historical reasons.
 *         elif os.path.isdir(os.path.join("/usr",PY_OZWAVE_CONFIG_DIRECTORY)):
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 625, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 625, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_abspath); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 625, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__28, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 625, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_r = __pyx_t_1;
      __pyx_t_1 = 0;
      goto __pyx_L0;

      /* "libopenzwave.pyx":624
 *             #At first, check in /etc/openzwave
 *             return dirn
 *         elif os.path.isfile(os.path.join("openzwave/config",'device_classes.xml')):             # <<<<<<<<<<<<<<
 *             return os.path.abspath('openzwave/config')
 *         #For historical reasons.
 */
    }

    /* "libopenzwave.pyx":627
 *             return os.path.abspath('openzwave/config')
 *         #For historical reasons.
 *         elif os.path.isdir(os.path.join("/usr",PY_OZWAVE_CONFIG_DIRECTORY)):             # <<<<<<<<<<<<<<
 *             return os.path.join("/usr",PY_OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)):
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 627, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 627, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_isdir); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 627, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 627, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_path); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 627, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_13);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_13, __pyx_n_s_join); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 627, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    __pyx_t_13 = __Pyx_GetModuleGlobalName(__pyx_n_s_PY_OZWAVE_CONFIG_DIRECTORY); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 627, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_13);
    __pyx_t_5 = NULL;
    __pyx_t_10 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
        __pyx_t_10 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_kp_s_usr, __pyx_t_13};
      __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 627, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_kp_s_usr, __pyx_t_13};
      __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 627, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    } else
    #endif
    {
      __pyx_t_14 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 627, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_14);
      if (__pyx_t_5) {
        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_5); __pyx_t_5 = NULL;
      }
      __Pyx_INCREF(__pyx_kp_s_usr);
      __Pyx_GIVEREF(__pyx_kp_s_usr);
      PyTuple_SET_ITEM(__pyx_t_14, 0+__pyx_t_10, __pyx_kp_s_usr);
      __Pyx_GIVEREF(__pyx_t_13);
      PyTuple_SET_ITEM(__pyx_t_14, 1+__pyx_t_10, __pyx_t_13);
      __pyx_t_13 = 0;
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_14, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 627, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_2) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 627, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_t_3};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 627, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_t_3};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 627, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      } else
      #endif
      {
        __pyx_t_14 = PyTuple_New(1+1); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 627, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_14);
        __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_2); __pyx_t_2 = NULL;
        __Pyx_GIVEREF(__pyx_t_3);
        PyTuple_SET_ITEM(__pyx_t_14, 0+1, __pyx_t_3);
        __pyx_t_3 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 627, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 627, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (__pyx_t_6) {

      /* "libopenzwave.pyx":628
 *         #For historical reasons.
 *         elif os.path.isdir(os.path.join("/usr",PY_OZWAVE_CONFIG_DIRECTORY)):
 *             return os.path.join("/usr",PY_OZWAVE_CONFIG_DIRECTORY)             # <<<<<<<<<<<<<<
 *         elif os.path.isdir(os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)):
 *             return os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 628, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_14 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 628, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_14);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_14, __pyx_n_s_join); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 628, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      __pyx_t_14 = __Pyx_GetModuleGlobalName(__pyx_n_s_PY_OZWAVE_CONFIG_DIRECTORY); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 628, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_14);
      __pyx_t_3 = NULL;
      __pyx_t_10 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_3)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_3);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
          __pyx_t_10 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_kp_s_usr, __pyx_t_14};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 628, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_kp_s_usr, __pyx_t_14};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 628, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      } else
      #endif
      {
        __pyx_t_2 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 628, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        if (__pyx_t_3) {
          __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3); __pyx_t_3 = NULL;
        }
        __Pyx_INCREF(__pyx_kp_s_usr);
        __Pyx_GIVEREF(__pyx_kp_s_usr);
        PyTuple_SET_ITEM(__pyx_t_2, 0+__pyx_t_10, __pyx_kp_s_usr);
        __Pyx_GIVEREF(__pyx_t_14);
        PyTuple_SET_ITEM(__pyx_t_2, 1+__pyx_t_10, __pyx_t_14);
        __pyx_t_14 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 628, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      }
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_r = __pyx_t_1;
      __pyx_t_1 = 0;
      goto __pyx_L0;

      /* "libopenzwave.pyx":627
 *             return os.path.abspath('openzwave/config')
 *         #For historical reasons.
 *         elif os.path.isdir(os.path.join("/usr",PY_OZWAVE_CONFIG_DIRECTORY)):             # <<<<<<<<<<<<<<
 *             return os.path.join("/usr",PY_OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)):
 */
    }

    /* "libopenzwave.pyx":629
 *         elif os.path.isdir(os.path.join("/usr",PY_OZWAVE_CONFIG_DIRECTORY)):
 *             return os.path.join("/usr",PY_OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)):             # <<<<<<<<<<<<<<
 *             return os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)):
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 629, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 629, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_isdir); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 629, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_14 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 629, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_14);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_14, __pyx_n_s_path); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 629, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
    __pyx_t_14 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_join); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 629, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_14);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_PY_OZWAVE_CONFIG_DIRECTORY); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 629, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_13 = NULL;
    __pyx_t_10 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_14))) {
      __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_14);
      if (likely(__pyx_t_13)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_14);
        __Pyx_INCREF(__pyx_t_13);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_14, function);
        __pyx_t_10 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_14)) {
      PyObject *__pyx_temp[3] = {__pyx_t_13, __pyx_kp_s_usr_local, __pyx_t_3};
      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_14, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 629, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_14)) {
      PyObject *__pyx_temp[3] = {__pyx_t_13, __pyx_kp_s_usr_local, __pyx_t_3};
      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_14, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 629, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else
    #endif
    {
      __pyx_t_5 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 629, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      if (__pyx_t_13) {
        __Pyx_GIVEREF(__pyx_t_13); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_13); __pyx_t_13 = NULL;
      }
      __Pyx_INCREF(__pyx_kp_s_usr_local);
      __Pyx_GIVEREF(__pyx_kp_s_usr_local);
      PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_10, __pyx_kp_s_usr_local);
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_10, __pyx_t_3);
      __pyx_t_3 = 0;
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_14, __pyx_t_5, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 629, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
    __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
    __pyx_t_14 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_14 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_14)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_14);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_14) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 629, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_14, __pyx_t_2};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 629, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_14, __pyx_t_2};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 629, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      } else
      #endif
      {
        __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 629, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_GIVEREF(__pyx_t_14); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_14); __pyx_t_14 = NULL;
        __Pyx_GIVEREF(__pyx_t_2);
        PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_2);
        __pyx_t_2 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 629, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 629, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (__pyx_t_6) {

      /* "libopenzwave.pyx":630
 *             return os.path.join("/usr",PY_OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)):
 *             return os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)             # <<<<<<<<<<<<<<
 *         elif os.path.isdir(os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)):
 *             return os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 630, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 630, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_join); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 630, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_PY_OZWAVE_CONFIG_DIRECTORY); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 630, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_2 = NULL;
      __pyx_t_10 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_2)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_2);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
          __pyx_t_10 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_kp_s_usr_local, __pyx_t_5};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 630, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_kp_s_usr_local, __pyx_t_5};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 630, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else
      #endif
      {
        __pyx_t_14 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 630, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_14);
        if (__pyx_t_2) {
          __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_2); __pyx_t_2 = NULL;
        }
        __Pyx_INCREF(__pyx_kp_s_usr_local);
        __Pyx_GIVEREF(__pyx_kp_s_usr_local);
        PyTuple_SET_ITEM(__pyx_t_14, 0+__pyx_t_10, __pyx_kp_s_usr_local);
        __Pyx_GIVEREF(__pyx_t_5);
        PyTuple_SET_ITEM(__pyx_t_14, 1+__pyx_t_10, __pyx_t_5);
        __pyx_t_5 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 630, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      }
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_r = __pyx_t_1;
      __pyx_t_1 = 0;
      goto __pyx_L0;

      /* "libopenzwave.pyx":629
 *         elif os.path.isdir(os.path.join("/usr",PY_OZWAVE_CONFIG_DIRECTORY)):
 *             return os.path.join("/usr",PY_OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)):             # <<<<<<<<<<<<<<
 *             return os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)):
 */
    }

    /* "libopenzwave.pyx":631
 *         elif os.path.isdir(os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)):
 *             return os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)):             # <<<<<<<<<<<<<<
 *             return os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr/local",OZWAVE_CONFIG_DIRECTORY)):
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 631, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_14 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 631, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_14);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_14, __pyx_n_s_isdir); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 631, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 631, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_path); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 631, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_join); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 631, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_OZWAVE_CONFIG_DIRECTORY); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 631, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = NULL;
    __pyx_t_10 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
        __pyx_t_10 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_kp_s_usr, __pyx_t_2};
      __pyx_t_14 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 631, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_14);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_kp_s_usr, __pyx_t_2};
      __pyx_t_14 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 631, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_14);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    } else
    #endif
    {
      __pyx_t_13 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 631, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_13);
      if (__pyx_t_3) {
        __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_13, 0, __pyx_t_3); __pyx_t_3 = NULL;
      }
      __Pyx_INCREF(__pyx_kp_s_usr);
      __Pyx_GIVEREF(__pyx_kp_s_usr);
      PyTuple_SET_ITEM(__pyx_t_13, 0+__pyx_t_10, __pyx_kp_s_usr);
      __Pyx_GIVEREF(__pyx_t_2);
      PyTuple_SET_ITEM(__pyx_t_13, 1+__pyx_t_10, __pyx_t_2);
      __pyx_t_2 = 0;
      __pyx_t_14 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_13, NULL); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 631, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_14);
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_5) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_14); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 631, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_t_14};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 631, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_t_14};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 631, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      } else
      #endif
      {
        __pyx_t_13 = PyTuple_New(1+1); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 631, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_13);
        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_13, 0, __pyx_t_5); __pyx_t_5 = NULL;
        __Pyx_GIVEREF(__pyx_t_14);
        PyTuple_SET_ITEM(__pyx_t_13, 0+1, __pyx_t_14);
        __pyx_t_14 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_13, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 631, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 631, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (__pyx_t_6) {

      /* "libopenzwave.pyx":632
 *             return os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)):
 *             return os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)             # <<<<<<<<<<<<<<
 *         elif os.path.isdir(os.path.join("/usr/local",OZWAVE_CONFIG_DIRECTORY)):
 *             return os.path.join("/usr/local",OZWAVE_CONFIG_DIRECTORY)
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 632, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 632, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_13);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_13, __pyx_n_s_join); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 632, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
      __pyx_t_13 = __Pyx_GetModuleGlobalName(__pyx_n_s_OZWAVE_CONFIG_DIRECTORY); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 632, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_13);
      __pyx_t_14 = NULL;
      __pyx_t_10 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_14 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_14)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_14);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
          __pyx_t_10 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[3] = {__pyx_t_14, __pyx_kp_s_usr, __pyx_t_13};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 632, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[3] = {__pyx_t_14, __pyx_kp_s_usr, __pyx_t_13};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 632, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
      } else
      #endif
      {
        __pyx_t_5 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 632, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        if (__pyx_t_14) {
          __Pyx_GIVEREF(__pyx_t_14); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_14); __pyx_t_14 = NULL;
        }
        __Pyx_INCREF(__pyx_kp_s_usr);
        __Pyx_GIVEREF(__pyx_kp_s_usr);
        PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_10, __pyx_kp_s_usr);
        __Pyx_GIVEREF(__pyx_t_13);
        PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_10, __pyx_t_13);
        __pyx_t_13 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 632, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      }
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_r = __pyx_t_1;
      __pyx_t_1 = 0;
      goto __pyx_L0;

      /* "libopenzwave.pyx":631
 *         elif os.path.isdir(os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)):
 *             return os.path.join("/usr/local",PY_OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)):             # <<<<<<<<<<<<<<
 *             return os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr/local",OZWAVE_CONFIG_DIRECTORY)):
 */
    }

    /* "libopenzwave.pyx":633
 *         elif os.path.isdir(os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)):
 *             return os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr/local",OZWAVE_CONFIG_DIRECTORY)):             # <<<<<<<<<<<<<<
 *             return os.path.join("/usr/local",OZWAVE_CONFIG_DIRECTORY)
 *         else:
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 633, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 633, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_isdir); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 633, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_13 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 633, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_13);
    __pyx_t_14 = __Pyx_PyObject_GetAttrStr(__pyx_t_13, __pyx_n_s_path); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 633, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_14);
    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_14, __pyx_n_s_join); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 633, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_13);
    __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
    __pyx_t_14 = __Pyx_GetModuleGlobalName(__pyx_n_s_OZWAVE_CONFIG_DIRECTORY); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 633, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_14);
    __pyx_t_2 = NULL;
    __pyx_t_10 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_13))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_13);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_13);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_13, function);
        __pyx_t_10 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_13)) {
      PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_kp_s_usr_local, __pyx_t_14};
      __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_13, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 633, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_13)) {
      PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_kp_s_usr_local, __pyx_t_14};
      __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_13, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 633, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
    } else
    #endif
    {
      __pyx_t_3 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 633, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      if (__pyx_t_2) {
        __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2); __pyx_t_2 = NULL;
      }
      __Pyx_INCREF(__pyx_kp_s_usr_local);
      __Pyx_GIVEREF(__pyx_kp_s_usr_local);
      PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_10, __pyx_kp_s_usr_local);
      __Pyx_GIVEREF(__pyx_t_14);
      PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_10, __pyx_t_14);
      __pyx_t_14 = 0;
      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_13, __pyx_t_3, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 633, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    }
    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    __pyx_t_13 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_13)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_13);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_13) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 633, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_13, __pyx_t_5};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 633, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_13, __pyx_t_5};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 633, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else
      #endif
      {
        __pyx_t_3 = PyTuple_New(1+1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 633, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_GIVEREF(__pyx_t_13); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_13); __pyx_t_13 = NULL;
        __Pyx_GIVEREF(__pyx_t_5);
        PyTuple_SET_ITEM(__pyx_t_3, 0+1, __pyx_t_5);
        __pyx_t_5 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 633, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 633, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (__pyx_t_6) {

      /* "libopenzwave.pyx":634
 *             return os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr/local",OZWAVE_CONFIG_DIRECTORY)):
 *             return os.path.join("/usr/local",OZWAVE_CONFIG_DIRECTORY)             # <<<<<<<<<<<<<<
 *         else:
 *             if os.path.isdir(os.path.join(os.path.dirname(libopenzwave_file),PY_OZWAVE_CONFIG_DIRECTORY)):
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 634, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 634, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_join); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 634, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_OZWAVE_CONFIG_DIRECTORY); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 634, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = NULL;
      __pyx_t_10 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_5)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_5);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
          __pyx_t_10 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_kp_s_usr_local, __pyx_t_3};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 634, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_kp_s_usr_local, __pyx_t_3};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 634, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      } else
      #endif
      {
        __pyx_t_13 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 634, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_13);
        if (__pyx_t_5) {
          __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_13, 0, __pyx_t_5); __pyx_t_5 = NULL;
        }
        __Pyx_INCREF(__pyx_kp_s_usr_local);
        __Pyx_GIVEREF(__pyx_kp_s_usr_local);
        PyTuple_SET_ITEM(__pyx_t_13, 0+__pyx_t_10, __pyx_kp_s_usr_local);
        __Pyx_GIVEREF(__pyx_t_3);
        PyTuple_SET_ITEM(__pyx_t_13, 1+__pyx_t_10, __pyx_t_3);
        __pyx_t_3 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_13, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 634, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
      }
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_r = __pyx_t_1;
      __pyx_t_1 = 0;
      goto __pyx_L0;

      /* "libopenzwave.pyx":633
 *         elif os.path.isdir(os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)):
 *             return os.path.join("/usr",OZWAVE_CONFIG_DIRECTORY)
 *         elif os.path.isdir(os.path.join("/usr/local",OZWAVE_CONFIG_DIRECTORY)):             # <<<<<<<<<<<<<<
 *             return os.path.join("/usr/local",OZWAVE_CONFIG_DIRECTORY)
 *         else:
 */
    }

    /* "libopenzwave.pyx":636
 *             return os.path.join("/usr/local",OZWAVE_CONFIG_DIRECTORY)
 *         else:
 *             if os.path.isdir(os.path.join(os.path.dirname(libopenzwave_file),PY_OZWAVE_CONFIG_DIRECTORY)):             # <<<<<<<<<<<<<<
 *                 return os.path.join(os.path.dirname(libopenzwave_file), PY_OZWAVE_CONFIG_DIRECTORY)
 *             if os.path.isdir(os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)):
 */
    /*else*/ {
      __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 636, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 636, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_13);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_13, __pyx_n_s_isdir); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 636, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 636, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_path); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 636, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_join); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 636, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_14 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 636, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_14);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_14, __pyx_n_s_path); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 636, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      __pyx_t_14 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_dirname); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 636, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_14);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_libopenzwave_file); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 636, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_15 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_14))) {
        __pyx_t_15 = PyMethod_GET_SELF(__pyx_t_14);
        if (likely(__pyx_t_15)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_14);
          __Pyx_INCREF(__pyx_t_15);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_14, function);
        }
      }
      if (!__pyx_t_15) {
        __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_14, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 636, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_5);
      } else {
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_14)) {
          PyObject *__pyx_temp[2] = {__pyx_t_15, __pyx_t_2};
          __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_14, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 636, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_15); __pyx_t_15 = 0;
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_14)) {
          PyObject *__pyx_temp[2] = {__pyx_t_15, __pyx_t_2};
          __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_14, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 636, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_15); __pyx_t_15 = 0;
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        } else
        #endif
        {
          __pyx_t_16 = PyTuple_New(1+1); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 636, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_16);
          __Pyx_GIVEREF(__pyx_t_15); PyTuple_SET_ITEM(__pyx_t_16, 0, __pyx_t_15); __pyx_t_15 = NULL;
          __Pyx_GIVEREF(__pyx_t_2);
          PyTuple_SET_ITEM(__pyx_t_16, 0+1, __pyx_t_2);
          __pyx_t_2 = 0;
          __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_14, __pyx_t_16, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 636, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
        }
      }
      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      __pyx_t_14 = __Pyx_GetModuleGlobalName(__pyx_n_s_PY_OZWAVE_CONFIG_DIRECTORY); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 636, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_14);
      __pyx_t_16 = NULL;
      __pyx_t_10 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_16 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_16)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_16);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
          __pyx_t_10 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[3] = {__pyx_t_16, __pyx_t_5, __pyx_t_14};
        __pyx_t_13 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 636, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_16); __pyx_t_16 = 0;
        __Pyx_GOTREF(__pyx_t_13);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[3] = {__pyx_t_16, __pyx_t_5, __pyx_t_14};
        __pyx_t_13 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 636, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_16); __pyx_t_16 = 0;
        __Pyx_GOTREF(__pyx_t_13);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      } else
      #endif
      {
        __pyx_t_2 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 636, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        if (__pyx_t_16) {
          __Pyx_GIVEREF(__pyx_t_16); PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_16); __pyx_t_16 = NULL;
        }
        __Pyx_GIVEREF(__pyx_t_5);
        PyTuple_SET_ITEM(__pyx_t_2, 0+__pyx_t_10, __pyx_t_5);
        __Pyx_GIVEREF(__pyx_t_14);
        PyTuple_SET_ITEM(__pyx_t_2, 1+__pyx_t_10, __pyx_t_14);
        __pyx_t_5 = 0;
        __pyx_t_14 = 0;
        __pyx_t_13 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 636, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_13);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_3)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_3);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
        }
      }
      if (!__pyx_t_3) {
        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_13); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 636, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else {
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_t_13};
          __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 636, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_t_13};
          __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 636, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        } else
        #endif
        {
          __pyx_t_2 = PyTuple_New(1+1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 636, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3); __pyx_t_3 = NULL;
          __Pyx_GIVEREF(__pyx_t_13);
          PyTuple_SET_ITEM(__pyx_t_2, 0+1, __pyx_t_13);
          __pyx_t_13 = 0;
          __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 636, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        }
      }
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 636, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (__pyx_t_6) {

        /* "libopenzwave.pyx":637
 *         else:
 *             if os.path.isdir(os.path.join(os.path.dirname(libopenzwave_file),PY_OZWAVE_CONFIG_DIRECTORY)):
 *                 return os.path.join(os.path.dirname(libopenzwave_file), PY_OZWAVE_CONFIG_DIRECTORY)             # <<<<<<<<<<<<<<
 *             if os.path.isdir(os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)):
 *                 return os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)
 */
        __Pyx_XDECREF(__pyx_r);
        __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 637, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 637, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_join); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 637, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_t_13 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 637, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_13);
        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_13, __pyx_n_s_path); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 637, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_dirname); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 637, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_13);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_libopenzwave_file); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 637, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_14 = NULL;
        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_13))) {
          __pyx_t_14 = PyMethod_GET_SELF(__pyx_t_13);
          if (likely(__pyx_t_14)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_13);
            __Pyx_INCREF(__pyx_t_14);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_13, function);
          }
        }
        if (!__pyx_t_14) {
          __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_13, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 637, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          __Pyx_GOTREF(__pyx_t_2);
        } else {
          #if CYTHON_FAST_PYCALL
          if (PyFunction_Check(__pyx_t_13)) {
            PyObject *__pyx_temp[2] = {__pyx_t_14, __pyx_t_3};
            __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_13, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 637, __pyx_L1_error)
            __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
            __Pyx_GOTREF(__pyx_t_2);
            __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          } else
          #endif
          #if CYTHON_FAST_PYCCALL
          if (__Pyx_PyFastCFunction_Check(__pyx_t_13)) {
            PyObject *__pyx_temp[2] = {__pyx_t_14, __pyx_t_3};
            __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_13, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 637, __pyx_L1_error)
            __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
            __Pyx_GOTREF(__pyx_t_2);
            __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          } else
          #endif
          {
            __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 637, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_5);
            __Pyx_GIVEREF(__pyx_t_14); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_14); __pyx_t_14 = NULL;
            __Pyx_GIVEREF(__pyx_t_3);
            PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_3);
            __pyx_t_3 = 0;
            __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_13, __pyx_t_5, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 637, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_2);
            __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
          }
        }
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        __pyx_t_13 = __Pyx_GetModuleGlobalName(__pyx_n_s_PY_OZWAVE_CONFIG_DIRECTORY); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 637, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_13);
        __pyx_t_5 = NULL;
        __pyx_t_10 = 0;
        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
          if (likely(__pyx_t_5)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
            __Pyx_INCREF(__pyx_t_5);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_4, function);
            __pyx_t_10 = 1;
          }
        }
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_2, __pyx_t_13};
          __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 637, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_2, __pyx_t_13};
          __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 637, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        } else
        #endif
        {
          __pyx_t_3 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 637, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          if (__pyx_t_5) {
            __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5); __pyx_t_5 = NULL;
          }
          __Pyx_GIVEREF(__pyx_t_2);
          PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_10, __pyx_t_2);
          __Pyx_GIVEREF(__pyx_t_13);
          PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_10, __pyx_t_13);
          __pyx_t_2 = 0;
          __pyx_t_13 = 0;
          __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 637, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        }
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_r = __pyx_t_1;
        __pyx_t_1 = 0;
        goto __pyx_L0;

        /* "libopenzwave.pyx":636
 *             return os.path.join("/usr/local",OZWAVE_CONFIG_DIRECTORY)
 *         else:
 *             if os.path.isdir(os.path.join(os.path.dirname(libopenzwave_file),PY_OZWAVE_CONFIG_DIRECTORY)):             # <<<<<<<<<<<<<<
 *                 return os.path.join(os.path.dirname(libopenzwave_file), PY_OZWAVE_CONFIG_DIRECTORY)
 *             if os.path.isdir(os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)):
 */
      }

      /* "libopenzwave.pyx":638
 *             if os.path.isdir(os.path.join(os.path.dirname(libopenzwave_file),PY_OZWAVE_CONFIG_DIRECTORY)):
 *                 return os.path.join(os.path.dirname(libopenzwave_file), PY_OZWAVE_CONFIG_DIRECTORY)
 *             if os.path.isdir(os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)):             # <<<<<<<<<<<<<<
 *                 return os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)
 *             if os.path.isdir(os.path.join(libopenzwave_location,PY_OZWAVE_CONFIG_DIRECTORY)):
 */
      __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 638, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 638, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_isdir); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 638, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_13 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 638, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_13);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_13, __pyx_n_s_path); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 638, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
      __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_join); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 638, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_13);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 638, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_14 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_getcwd); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 638, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_14);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_5 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_14))) {
        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_14);
        if (likely(__pyx_t_5)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_14);
          __Pyx_INCREF(__pyx_t_5);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_14, function);
        }
      }
      if (__pyx_t_5) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_14, __pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 638, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_14); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 638, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      __pyx_t_14 = __Pyx_GetModuleGlobalName(__pyx_n_s_CWD_CONFIG_DIRECTORY); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 638, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_14);
      __pyx_t_5 = NULL;
      __pyx_t_10 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_13))) {
        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_13);
        if (likely(__pyx_t_5)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_13);
          __Pyx_INCREF(__pyx_t_5);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_13, function);
          __pyx_t_10 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_13)) {
        PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_2, __pyx_t_14};
        __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_13, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 638, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_13)) {
        PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_2, __pyx_t_14};
        __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_13, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 638, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      } else
      #endif
      {
        __pyx_t_16 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 638, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_16);
        if (__pyx_t_5) {
          __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_16, 0, __pyx_t_5); __pyx_t_5 = NULL;
        }
        __Pyx_GIVEREF(__pyx_t_2);
        PyTuple_SET_ITEM(__pyx_t_16, 0+__pyx_t_10, __pyx_t_2);
        __Pyx_GIVEREF(__pyx_t_14);
        PyTuple_SET_ITEM(__pyx_t_16, 1+__pyx_t_10, __pyx_t_14);
        __pyx_t_2 = 0;
        __pyx_t_14 = 0;
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_13, __pyx_t_16, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 638, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
      }
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
      __pyx_t_13 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_13)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_13);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
        }
      }
      if (!__pyx_t_13) {
        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 638, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else {
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[2] = {__pyx_t_13, __pyx_t_3};
          __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 638, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[2] = {__pyx_t_13, __pyx_t_3};
          __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 638, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        } else
        #endif
        {
          __pyx_t_16 = PyTuple_New(1+1); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 638, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_16);
          __Pyx_GIVEREF(__pyx_t_13); PyTuple_SET_ITEM(__pyx_t_16, 0, __pyx_t_13); __pyx_t_13 = NULL;
          __Pyx_GIVEREF(__pyx_t_3);
          PyTuple_SET_ITEM(__pyx_t_16, 0+1, __pyx_t_3);
          __pyx_t_3 = 0;
          __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_16, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 638, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
        }
      }
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 638, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (__pyx_t_6) {

        /* "libopenzwave.pyx":639
 *                 return os.path.join(os.path.dirname(libopenzwave_file), PY_OZWAVE_CONFIG_DIRECTORY)
 *             if os.path.isdir(os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)):
 *                 return os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)             # <<<<<<<<<<<<<<
 *             if os.path.isdir(os.path.join(libopenzwave_location,PY_OZWAVE_CONFIG_DIRECTORY)):
 *                 return os.path.join(libopenzwave_location, PY_OZWAVE_CONFIG_DIRECTORY)
 */
        __Pyx_XDECREF(__pyx_r);
        __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 639, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_16 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 639, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_16);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_16, __pyx_n_s_join); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 639, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 639, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_getcwd); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 639, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_13);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_13))) {
          __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_13);
          if (likely(__pyx_t_3)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_13);
            __Pyx_INCREF(__pyx_t_3);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_13, function);
          }
        }
        if (__pyx_t_3) {
          __pyx_t_16 = __Pyx_PyObject_CallOneArg(__pyx_t_13, __pyx_t_3); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 639, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        } else {
          __pyx_t_16 = __Pyx_PyObject_CallNoArg(__pyx_t_13); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 639, __pyx_L1_error)
        }
        __Pyx_GOTREF(__pyx_t_16);
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        __pyx_t_13 = __Pyx_GetModuleGlobalName(__pyx_n_s_CWD_CONFIG_DIRECTORY); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 639, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_13);
        __pyx_t_3 = NULL;
        __pyx_t_10 = 0;
        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
          __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
          if (likely(__pyx_t_3)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
            __Pyx_INCREF(__pyx_t_3);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_4, function);
            __pyx_t_10 = 1;
          }
        }
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_t_16, __pyx_t_13};
          __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 639, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
          __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_t_16, __pyx_t_13};
          __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 639, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
          __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        } else
        #endif
        {
          __pyx_t_14 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 639, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_14);
          if (__pyx_t_3) {
            __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_3); __pyx_t_3 = NULL;
          }
          __Pyx_GIVEREF(__pyx_t_16);
          PyTuple_SET_ITEM(__pyx_t_14, 0+__pyx_t_10, __pyx_t_16);
          __Pyx_GIVEREF(__pyx_t_13);
          PyTuple_SET_ITEM(__pyx_t_14, 1+__pyx_t_10, __pyx_t_13);
          __pyx_t_16 = 0;
          __pyx_t_13 = 0;
          __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 639, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
        }
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_r = __pyx_t_1;
        __pyx_t_1 = 0;
        goto __pyx_L0;

        /* "libopenzwave.pyx":638
 *             if os.path.isdir(os.path.join(os.path.dirname(libopenzwave_file),PY_OZWAVE_CONFIG_DIRECTORY)):
 *                 return os.path.join(os.path.dirname(libopenzwave_file), PY_OZWAVE_CONFIG_DIRECTORY)
 *             if os.path.isdir(os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)):             # <<<<<<<<<<<<<<
 *                 return os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)
 *             if os.path.isdir(os.path.join(libopenzwave_location,PY_OZWAVE_CONFIG_DIRECTORY)):
 */
      }

      /* "libopenzwave.pyx":640
 *             if os.path.isdir(os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)):
 *                 return os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)
 *             if os.path.isdir(os.path.join(libopenzwave_location,PY_OZWAVE_CONFIG_DIRECTORY)):             # <<<<<<<<<<<<<<
 *                 return os.path.join(libopenzwave_location, PY_OZWAVE_CONFIG_DIRECTORY)
 *     return None
 */
      __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 640, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_14 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 640, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_14);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_14, __pyx_n_s_isdir); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 640, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      __pyx_t_13 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 640, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_13);
      __pyx_t_16 = __Pyx_PyObject_GetAttrStr(__pyx_t_13, __pyx_n_s_path); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 640, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_16);
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
      __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_16, __pyx_n_s_join); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 640, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_13);
      __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
      __pyx_t_16 = __Pyx_GetModuleGlobalName(__pyx_n_s_libopenzwave_location); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 640, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_16);
      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_PY_OZWAVE_CONFIG_DIRECTORY); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 640, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_2 = NULL;
      __pyx_t_10 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_13))) {
        __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_13);
        if (likely(__pyx_t_2)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_13);
          __Pyx_INCREF(__pyx_t_2);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_13, function);
          __pyx_t_10 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_13)) {
        PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_t_16, __pyx_t_3};
        __pyx_t_14 = __Pyx_PyFunction_FastCall(__pyx_t_13, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 640, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_14);
        __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_13)) {
        PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_t_16, __pyx_t_3};
        __pyx_t_14 = __Pyx_PyCFunction_FastCall(__pyx_t_13, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 640, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_14);
        __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      } else
      #endif
      {
        __pyx_t_5 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 640, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        if (__pyx_t_2) {
          __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
        }
        __Pyx_GIVEREF(__pyx_t_16);
        PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_10, __pyx_t_16);
        __Pyx_GIVEREF(__pyx_t_3);
        PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_10, __pyx_t_3);
        __pyx_t_16 = 0;
        __pyx_t_3 = 0;
        __pyx_t_14 = __Pyx_PyObject_Call(__pyx_t_13, __pyx_t_5, NULL); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 640, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_14);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      }
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
      __pyx_t_13 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_13)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_13);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
        }
      }
      if (!__pyx_t_13) {
        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_14); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 640, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else {
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[2] = {__pyx_t_13, __pyx_t_14};
          __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 640, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[2] = {__pyx_t_13, __pyx_t_14};
          __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 640, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
        } else
        #endif
        {
          __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 640, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_GIVEREF(__pyx_t_13); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_13); __pyx_t_13 = NULL;
          __Pyx_GIVEREF(__pyx_t_14);
          PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_14);
          __pyx_t_14 = 0;
          __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 640, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        }
      }
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 640, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (__pyx_t_6) {

        /* "libopenzwave.pyx":641
 *                 return os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)
 *             if os.path.isdir(os.path.join(libopenzwave_location,PY_OZWAVE_CONFIG_DIRECTORY)):
 *                 return os.path.join(libopenzwave_location, PY_OZWAVE_CONFIG_DIRECTORY)             # <<<<<<<<<<<<<<
 *     return None
 * 
 */
        __Pyx_XDECREF(__pyx_r);
        __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 641, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 641, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_join); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 641, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_libopenzwave_location); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 641, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __pyx_t_14 = __Pyx_GetModuleGlobalName(__pyx_n_s_PY_OZWAVE_CONFIG_DIRECTORY); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 641, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_14);
        __pyx_t_13 = NULL;
        __pyx_t_10 = 0;
        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
          __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_4);
          if (likely(__pyx_t_13)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
            __Pyx_INCREF(__pyx_t_13);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_4, function);
            __pyx_t_10 = 1;
          }
        }
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[3] = {__pyx_t_13, __pyx_t_5, __pyx_t_14};
          __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 641, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[3] = {__pyx_t_13, __pyx_t_5, __pyx_t_14};
          __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 641, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
        } else
        #endif
        {
          __pyx_t_3 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 641, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          if (__pyx_t_13) {
            __Pyx_GIVEREF(__pyx_t_13); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_13); __pyx_t_13 = NULL;
          }
          __Pyx_GIVEREF(__pyx_t_5);
          PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_10, __pyx_t_5);
          __Pyx_GIVEREF(__pyx_t_14);
          PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_10, __pyx_t_14);
          __pyx_t_5 = 0;
          __pyx_t_14 = 0;
          __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 641, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        }
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_r = __pyx_t_1;
        __pyx_t_1 = 0;
        goto __pyx_L0;

        /* "libopenzwave.pyx":640
 *             if os.path.isdir(os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)):
 *                 return os.path.join(os.getcwd(),CWD_CONFIG_DIRECTORY)
 *             if os.path.isdir(os.path.join(libopenzwave_location,PY_OZWAVE_CONFIG_DIRECTORY)):             # <<<<<<<<<<<<<<
 *                 return os.path.join(libopenzwave_location, PY_OZWAVE_CONFIG_DIRECTORY)
 *     return None
 */
      }
    }
  }

  /* "libopenzwave.pyx":642
 *             if os.path.isdir(os.path.join(libopenzwave_location,PY_OZWAVE_CONFIG_DIRECTORY)):
 *                 return os.path.join(libopenzwave_location, PY_OZWAVE_CONFIG_DIRECTORY)
 *     return None             # <<<<<<<<<<<<<<
 * 
 * cdef class PyOptions:
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_None);
  __pyx_r = Py_None;
  goto __pyx_L0;

  /* "libopenzwave.pyx":598
 *     cdef DriverData data
 * 
 * def configPath():             # <<<<<<<<<<<<<<
 *     '''
 *     Retrieve the config path. This directory hold the xml files.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_XDECREF(__pyx_t_14);
  __Pyx_XDECREF(__pyx_t_15);
  __Pyx_XDECREF(__pyx_t_16);
  __Pyx_AddTraceback("libopenzwave.configPath", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_dirn);
  __Pyx_XDECREF(__pyx_v_resource_filename);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":655
 *     cdef Options *options
 * 
 *     def __init__(self, config_path=None, user_path=".", cmd_line=""):             # <<<<<<<<<<<<<<
 *         """
 *         Create an option object and check that parameters are valid.
 */

/* Python wrapper */
static int __pyx_pw_12libopenzwave_9PyOptions_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyOptions___init__[] = "\n        Create an option object and check that parameters are valid.\n\n        :param device: The device to use\n        :type device: str\n        :param config_path: The openzwave config directory. If None, try to configure automatically.\n        :type config_path: str\n        :param user_path: The user directory\n        :type user_path: str\n        :param cmd_line: The \"command line\" options of the openzwave library\n        :type cmd_line: str\n\n        ";
#if CYTHON_COMPILING_IN_CPYTHON
struct wrapperbase __pyx_wrapperbase_12libopenzwave_9PyOptions___init__;
#endif
static int __pyx_pw_12libopenzwave_9PyOptions_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_config_path = 0;
  PyObject *__pyx_v_user_path = 0;
  PyObject *__pyx_v_cmd_line = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_config_path,&__pyx_n_s_user_path,&__pyx_n_s_cmd_line,0};
    PyObject* values[3] = {0,0,0};
    values[0] = ((PyObject *)Py_None);
    values[1] = ((PyObject *)__pyx_kp_s__29);
    values[2] = ((PyObject *)__pyx_kp_s__6);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_config_path);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_user_path);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cmd_line);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 655, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_config_path = values[0];
    __pyx_v_user_path = values[1];
    __pyx_v_cmd_line = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 655, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyOptions.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyOptions___init__(((struct __pyx_obj_12libopenzwave_PyOptions *)__pyx_v_self), __pyx_v_config_path, __pyx_v_user_path, __pyx_v_cmd_line);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_12libopenzwave_9PyOptions___init__(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_config_path, PyObject *__pyx_v_user_path, PyObject *__pyx_v_cmd_line) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  __Pyx_RefNannySetupContext("__init__", 0);
  __Pyx_INCREF(__pyx_v_config_path);
  __Pyx_INCREF(__pyx_v_user_path);
  __Pyx_INCREF(__pyx_v_cmd_line);

  /* "libopenzwave.pyx":669
 * 
 *         """
 *         if config_path is None:             # <<<<<<<<<<<<<<
 *             config_path = self.getConfigPath()
 *         if config_path is None:
 */
  __pyx_t_1 = (__pyx_v_config_path == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":670
 *         """
 *         if config_path is None:
 *             config_path = self.getConfigPath()             # <<<<<<<<<<<<<<
 *         if config_path is None:
 *             raise LibZWaveException("Can't autoconfigure path to config")
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_getConfigPath); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 670, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (__pyx_t_5) {
      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 670, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else {
      __pyx_t_3 = __Pyx_PyObject_CallNoArg(__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 670, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF_SET(__pyx_v_config_path, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "libopenzwave.pyx":669
 * 
 *         """
 *         if config_path is None:             # <<<<<<<<<<<<<<
 *             config_path = self.getConfigPath()
 *         if config_path is None:
 */
  }

  /* "libopenzwave.pyx":671
 *         if config_path is None:
 *             config_path = self.getConfigPath()
 *         if config_path is None:             # <<<<<<<<<<<<<<
 *             raise LibZWaveException("Can't autoconfigure path to config")
 *         if os.path.exists(config_path):
 */
  __pyx_t_2 = (__pyx_v_config_path == Py_None);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":672
 *             config_path = self.getConfigPath()
 *         if config_path is None:
 *             raise LibZWaveException("Can't autoconfigure path to config")             # <<<<<<<<<<<<<<
 *         if os.path.exists(config_path):
 *             if not os.path.exists(os.path.join(config_path, "zwcfg.xsd")):
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_LibZWaveException); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 672, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__30, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 672, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 672, __pyx_L1_error)

    /* "libopenzwave.pyx":671
 *         if config_path is None:
 *             config_path = self.getConfigPath()
 *         if config_path is None:             # <<<<<<<<<<<<<<
 *             raise LibZWaveException("Can't autoconfigure path to config")
 *         if os.path.exists(config_path):
 */
  }

  /* "libopenzwave.pyx":673
 *         if config_path is None:
 *             raise LibZWaveException("Can't autoconfigure path to config")
 *         if os.path.exists(config_path):             # <<<<<<<<<<<<<<
 *             if not os.path.exists(os.path.join(config_path, "zwcfg.xsd")):
 *                 raise LibZWaveException("Can't retrieve zwcfg.xsd from %s" % config_path)
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 673, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_path); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 673, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_exists); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 673, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_5) {
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_config_path); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 673, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_v_config_path};
      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 673, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_v_config_path};
      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 673, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else
    #endif
    {
      __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 673, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __pyx_t_5 = NULL;
      __Pyx_INCREF(__pyx_v_config_path);
      __Pyx_GIVEREF(__pyx_v_config_path);
      PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_v_config_path);
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 673, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 673, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":674
 *             raise LibZWaveException("Can't autoconfigure path to config")
 *         if os.path.exists(config_path):
 *             if not os.path.exists(os.path.join(config_path, "zwcfg.xsd")):             # <<<<<<<<<<<<<<
 *                 raise LibZWaveException("Can't retrieve zwcfg.xsd from %s" % config_path)
 *             self._config_path = config_path
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 674, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_path); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 674, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_exists); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 674, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 674, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_path); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 674, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_join); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 674, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_config_path, __pyx_kp_s_zwcfg_xsd};
      __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 674, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_6);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_config_path, __pyx_kp_s_zwcfg_xsd};
      __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 674, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_6);
    } else
    #endif
    {
      __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 674, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      if (__pyx_t_7) {
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_7); __pyx_t_7 = NULL;
      }
      __Pyx_INCREF(__pyx_v_config_path);
      __Pyx_GIVEREF(__pyx_v_config_path);
      PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_v_config_path);
      __Pyx_INCREF(__pyx_kp_s_zwcfg_xsd);
      __Pyx_GIVEREF(__pyx_kp_s_zwcfg_xsd);
      PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_kp_s_zwcfg_xsd);
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 674, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_5) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 674, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_t_6};
        __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 674, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_t_6};
        __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 674, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      } else
      #endif
      {
        __pyx_t_9 = PyTuple_New(1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 674, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_5); __pyx_t_5 = NULL;
        __Pyx_GIVEREF(__pyx_t_6);
        PyTuple_SET_ITEM(__pyx_t_9, 0+1, __pyx_t_6);
        __pyx_t_6 = 0;
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_9, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 674, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 674, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_2 = ((!__pyx_t_1) != 0);
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":675
 *         if os.path.exists(config_path):
 *             if not os.path.exists(os.path.join(config_path, "zwcfg.xsd")):
 *                 raise LibZWaveException("Can't retrieve zwcfg.xsd from %s" % config_path)             # <<<<<<<<<<<<<<
 *             self._config_path = config_path
 *         else:
 */
      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_LibZWaveException); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 675, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_9 = __Pyx_PyString_Format(__pyx_kp_s_Can_t_retrieve_zwcfg_xsd_from_s, __pyx_v_config_path); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 675, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __pyx_t_6 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_6)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_6);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (!__pyx_t_6) {
        __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_9); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 675, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        __Pyx_GOTREF(__pyx_t_4);
      } else {
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_t_9};
          __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 675, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_t_9};
          __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 675, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        } else
        #endif
        {
          __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 675, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_6); __pyx_t_6 = NULL;
          __Pyx_GIVEREF(__pyx_t_9);
          PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_9);
          __pyx_t_9 = 0;
          __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 675, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        }
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 675, __pyx_L1_error)

      /* "libopenzwave.pyx":674
 *             raise LibZWaveException("Can't autoconfigure path to config")
 *         if os.path.exists(config_path):
 *             if not os.path.exists(os.path.join(config_path, "zwcfg.xsd")):             # <<<<<<<<<<<<<<
 *                 raise LibZWaveException("Can't retrieve zwcfg.xsd from %s" % config_path)
 *             self._config_path = config_path
 */
    }

    /* "libopenzwave.pyx":676
 *             if not os.path.exists(os.path.join(config_path, "zwcfg.xsd")):
 *                 raise LibZWaveException("Can't retrieve zwcfg.xsd from %s" % config_path)
 *             self._config_path = config_path             # <<<<<<<<<<<<<<
 *         else:
 *             raise LibZWaveException("Can't find config directory %s" % config_path)
 */
    if (!(likely(PyString_CheckExact(__pyx_v_config_path))||((__pyx_v_config_path) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_v_config_path)->tp_name), 0))) __PYX_ERR(0, 676, __pyx_L1_error)
    __pyx_t_4 = __pyx_v_config_path;
    __Pyx_INCREF(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __Pyx_GOTREF(__pyx_v_self->_config_path);
    __Pyx_DECREF(__pyx_v_self->_config_path);
    __pyx_v_self->_config_path = ((PyObject*)__pyx_t_4);
    __pyx_t_4 = 0;

    /* "libopenzwave.pyx":673
 *         if config_path is None:
 *             raise LibZWaveException("Can't autoconfigure path to config")
 *         if os.path.exists(config_path):             # <<<<<<<<<<<<<<
 *             if not os.path.exists(os.path.join(config_path, "zwcfg.xsd")):
 *                 raise LibZWaveException("Can't retrieve zwcfg.xsd from %s" % config_path)
 */
    goto __pyx_L5;
  }

  /* "libopenzwave.pyx":678
 *             self._config_path = config_path
 *         else:
 *             raise LibZWaveException("Can't find config directory %s" % config_path)             # <<<<<<<<<<<<<<
 *         if user_path is None:
 *             user_path = "."
 */
  /*else*/ {
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_LibZWaveException); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 678, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_Can_t_find_config_directory_s, __pyx_v_config_path); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 678, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_9 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_9)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_9);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_9) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 678, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_9, __pyx_t_5};
        __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 678, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_9, __pyx_t_5};
        __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 678, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else
      #endif
      {
        __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 678, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_GIVEREF(__pyx_t_9); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_9); __pyx_t_9 = NULL;
        __Pyx_GIVEREF(__pyx_t_5);
        PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_t_5);
        __pyx_t_5 = 0;
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 678, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 678, __pyx_L1_error)
  }
  __pyx_L5:;

  /* "libopenzwave.pyx":679
 *         else:
 *             raise LibZWaveException("Can't find config directory %s" % config_path)
 *         if user_path is None:             # <<<<<<<<<<<<<<
 *             user_path = "."
 *         if os.path.exists(user_path):
 */
  __pyx_t_2 = (__pyx_v_user_path == Py_None);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":680
 *             raise LibZWaveException("Can't find config directory %s" % config_path)
 *         if user_path is None:
 *             user_path = "."             # <<<<<<<<<<<<<<
 *         if os.path.exists(user_path):
 *             if os.access(user_path, os.W_OK)==True and os.access(user_path, os.R_OK)==True:
 */
    __Pyx_INCREF(__pyx_kp_s__29);
    __Pyx_DECREF_SET(__pyx_v_user_path, __pyx_kp_s__29);

    /* "libopenzwave.pyx":679
 *         else:
 *             raise LibZWaveException("Can't find config directory %s" % config_path)
 *         if user_path is None:             # <<<<<<<<<<<<<<
 *             user_path = "."
 *         if os.path.exists(user_path):
 */
  }

  /* "libopenzwave.pyx":681
 *         if user_path is None:
 *             user_path = "."
 *         if os.path.exists(user_path):             # <<<<<<<<<<<<<<
 *             if os.access(user_path, os.W_OK)==True and os.access(user_path, os.R_OK)==True:
 *                 self._user_path = user_path
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 681, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_path); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 681, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_exists); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 681, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_6 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_6) {
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_user_path); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 681, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_v_user_path};
      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 681, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_v_user_path};
      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 681, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else
    #endif
    {
      __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 681, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_6); __pyx_t_6 = NULL;
      __Pyx_INCREF(__pyx_v_user_path);
      __Pyx_GIVEREF(__pyx_v_user_path);
      PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_v_user_path);
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 681, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 681, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":682
 *             user_path = "."
 *         if os.path.exists(user_path):
 *             if os.access(user_path, os.W_OK)==True and os.access(user_path, os.R_OK)==True:             # <<<<<<<<<<<<<<
 *                 self._user_path = user_path
 *             else:
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 682, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_access); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 682, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 682, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_W_OK); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 682, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_user_path, __pyx_t_6};
      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 682, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_user_path, __pyx_t_6};
      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 682, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else
    #endif
    {
      __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 682, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      if (__pyx_t_3) {
        __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_3); __pyx_t_3 = NULL;
      }
      __Pyx_INCREF(__pyx_v_user_path);
      __Pyx_GIVEREF(__pyx_v_user_path);
      PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_v_user_path);
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_t_6);
      __pyx_t_6 = 0;
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 682, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = PyObject_RichCompare(__pyx_t_4, Py_True, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 682, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 682, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (__pyx_t_2) {
    } else {
      __pyx_t_1 = __pyx_t_2;
      goto __pyx_L10_bool_binop_done;
    }
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 682, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_access); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 682, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 682, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_R_OK); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 682, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_9))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_9);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_9, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_9)) {
      PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_user_path, __pyx_t_6};
      __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_9, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 682, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_9)) {
      PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_user_path, __pyx_t_6};
      __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_9, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 682, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else
    #endif
    {
      __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 682, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      if (__pyx_t_4) {
        __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4); __pyx_t_4 = NULL;
      }
      __Pyx_INCREF(__pyx_v_user_path);
      __Pyx_GIVEREF(__pyx_v_user_path);
      PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_8, __pyx_v_user_path);
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_8, __pyx_t_6);
      __pyx_t_6 = 0;
      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_t_3, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 682, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    }
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_9 = PyObject_RichCompare(__pyx_t_5, Py_True, Py_EQ); __Pyx_XGOTREF(__pyx_t_9); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 682, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 682, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_1 = __pyx_t_2;
    __pyx_L10_bool_binop_done:;
    if (__pyx_t_1) {

      /* "libopenzwave.pyx":683
 *         if os.path.exists(user_path):
 *             if os.access(user_path, os.W_OK)==True and os.access(user_path, os.R_OK)==True:
 *                 self._user_path = user_path             # <<<<<<<<<<<<<<
 *             else:
 *                 raise LibZWaveException("Can't write in user directory %s" % user_path)
 */
      if (!(likely(PyString_CheckExact(__pyx_v_user_path))||((__pyx_v_user_path) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_v_user_path)->tp_name), 0))) __PYX_ERR(0, 683, __pyx_L1_error)
      __pyx_t_9 = __pyx_v_user_path;
      __Pyx_INCREF(__pyx_t_9);
      __Pyx_GIVEREF(__pyx_t_9);
      __Pyx_GOTREF(__pyx_v_self->_user_path);
      __Pyx_DECREF(__pyx_v_self->_user_path);
      __pyx_v_self->_user_path = ((PyObject*)__pyx_t_9);
      __pyx_t_9 = 0;

      /* "libopenzwave.pyx":682
 *             user_path = "."
 *         if os.path.exists(user_path):
 *             if os.access(user_path, os.W_OK)==True and os.access(user_path, os.R_OK)==True:             # <<<<<<<<<<<<<<
 *                 self._user_path = user_path
 *             else:
 */
      goto __pyx_L9;
    }

    /* "libopenzwave.pyx":685
 *                 self._user_path = user_path
 *             else:
 *                 raise LibZWaveException("Can't write in user directory %s" % user_path)             # <<<<<<<<<<<<<<
 *         else:
 *             raise LibZWaveException("Can't find user directory %s" % user_path)
 */
    /*else*/ {
      __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_LibZWaveException); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 685, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_Can_t_write_in_user_directory_s, __pyx_v_user_path); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 685, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_6 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_6)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_6);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
        }
      }
      if (!__pyx_t_6) {
        __pyx_t_9 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_3); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 685, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_GOTREF(__pyx_t_9);
      } else {
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_5)) {
          PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_t_3};
          __pyx_t_9 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 685, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
          __Pyx_GOTREF(__pyx_t_9);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
          PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_t_3};
          __pyx_t_9 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 685, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
          __Pyx_GOTREF(__pyx_t_9);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        } else
        #endif
        {
          __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 685, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_6); __pyx_t_6 = NULL;
          __Pyx_GIVEREF(__pyx_t_3);
          PyTuple_SET_ITEM(__pyx_t_4, 0+1, __pyx_t_3);
          __pyx_t_3 = 0;
          __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_4, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 685, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_9);
          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        }
      }
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_Raise(__pyx_t_9, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __PYX_ERR(0, 685, __pyx_L1_error)
    }
    __pyx_L9:;

    /* "libopenzwave.pyx":681
 *         if user_path is None:
 *             user_path = "."
 *         if os.path.exists(user_path):             # <<<<<<<<<<<<<<
 *             if os.access(user_path, os.W_OK)==True and os.access(user_path, os.R_OK)==True:
 *                 self._user_path = user_path
 */
    goto __pyx_L8;
  }

  /* "libopenzwave.pyx":687
 *                 raise LibZWaveException("Can't write in user directory %s" % user_path)
 *         else:
 *             raise LibZWaveException("Can't find user directory %s" % user_path)             # <<<<<<<<<<<<<<
 *         if cmd_line is None:
 *             cmd_line=""
 */
  /*else*/ {
    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_LibZWaveException); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 687, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Can_t_find_user_directory_s, __pyx_v_user_path); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 687, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    if (!__pyx_t_3) {
      __pyx_t_9 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 687, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_9);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_5)) {
        PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_t_4};
        __pyx_t_9 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 687, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
        PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_t_4};
        __pyx_t_9 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 687, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else
      #endif
      {
        __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 687, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;
        __Pyx_GIVEREF(__pyx_t_4);
        PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_t_4);
        __pyx_t_4 = 0;
        __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 687, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_Raise(__pyx_t_9, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __PYX_ERR(0, 687, __pyx_L1_error)
  }
  __pyx_L8:;

  /* "libopenzwave.pyx":688
 *         else:
 *             raise LibZWaveException("Can't find user directory %s" % user_path)
 *         if cmd_line is None:             # <<<<<<<<<<<<<<
 *             cmd_line=""
 *         self._cmd_line = cmd_line
 */
  __pyx_t_1 = (__pyx_v_cmd_line == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":689
 *             raise LibZWaveException("Can't find user directory %s" % user_path)
 *         if cmd_line is None:
 *             cmd_line=""             # <<<<<<<<<<<<<<
 *         self._cmd_line = cmd_line
 *         self.create(self._config_path, self._user_path, self._cmd_line)
 */
    __Pyx_INCREF(__pyx_kp_s__6);
    __Pyx_DECREF_SET(__pyx_v_cmd_line, __pyx_kp_s__6);

    /* "libopenzwave.pyx":688
 *         else:
 *             raise LibZWaveException("Can't find user directory %s" % user_path)
 *         if cmd_line is None:             # <<<<<<<<<<<<<<
 *             cmd_line=""
 *         self._cmd_line = cmd_line
 */
  }

  /* "libopenzwave.pyx":690
 *         if cmd_line is None:
 *             cmd_line=""
 *         self._cmd_line = cmd_line             # <<<<<<<<<<<<<<
 *         self.create(self._config_path, self._user_path, self._cmd_line)
 * 
 */
  if (!(likely(PyString_CheckExact(__pyx_v_cmd_line))||((__pyx_v_cmd_line) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_v_cmd_line)->tp_name), 0))) __PYX_ERR(0, 690, __pyx_L1_error)
  __pyx_t_9 = __pyx_v_cmd_line;
  __Pyx_INCREF(__pyx_t_9);
  __Pyx_GIVEREF(__pyx_t_9);
  __Pyx_GOTREF(__pyx_v_self->_cmd_line);
  __Pyx_DECREF(__pyx_v_self->_cmd_line);
  __pyx_v_self->_cmd_line = ((PyObject*)__pyx_t_9);
  __pyx_t_9 = 0;

  /* "libopenzwave.pyx":691
 *             cmd_line=""
 *         self._cmd_line = cmd_line
 *         self.create(self._config_path, self._user_path, self._cmd_line)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_create); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 691, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = NULL;
  __pyx_t_8 = 0;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
      __pyx_t_8 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_5)) {
    PyObject *__pyx_temp[4] = {__pyx_t_6, __pyx_v_self->_config_path, __pyx_v_self->_user_path, __pyx_v_self->_cmd_line};
    __pyx_t_9 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 3+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 691, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GOTREF(__pyx_t_9);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
    PyObject *__pyx_temp[4] = {__pyx_t_6, __pyx_v_self->_config_path, __pyx_v_self->_user_path, __pyx_v_self->_cmd_line};
    __pyx_t_9 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 3+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 691, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GOTREF(__pyx_t_9);
  } else
  #endif
  {
    __pyx_t_4 = PyTuple_New(3+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 691, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    if (__pyx_t_6) {
      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_6); __pyx_t_6 = NULL;
    }
    __Pyx_INCREF(__pyx_v_self->_config_path);
    __Pyx_GIVEREF(__pyx_v_self->_config_path);
    PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_8, __pyx_v_self->_config_path);
    __Pyx_INCREF(__pyx_v_self->_user_path);
    __Pyx_GIVEREF(__pyx_v_self->_user_path);
    PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_8, __pyx_v_self->_user_path);
    __Pyx_INCREF(__pyx_v_self->_cmd_line);
    __Pyx_GIVEREF(__pyx_v_self->_cmd_line);
    PyTuple_SET_ITEM(__pyx_t_4, 2+__pyx_t_8, __pyx_v_self->_cmd_line);
    __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_4, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 691, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;

  /* "libopenzwave.pyx":655
 *     cdef Options *options
 * 
 *     def __init__(self, config_path=None, user_path=".", cmd_line=""):             # <<<<<<<<<<<<<<
 *         """
 *         Create an option object and check that parameters are valid.
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("libopenzwave.PyOptions.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_config_path);
  __Pyx_XDECREF(__pyx_v_user_path);
  __Pyx_XDECREF(__pyx_v_cmd_line);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":694
 * 
 * 
 *     def create(self, str a, str b, str c):             # <<<<<<<<<<<<<<
 *         """
 *         .. _createoptions:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_3create(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyOptions_2create[] = "\n        .. _createoptions:\n\n        Create an option object used to start the manager\n\n        :param a: The path of the config directory\n        :type a: str\n        :param b: The path of the user directory\n        :type b: str\n        :param c: The \"command line\" options of the openzwave library\n        :type c: str\n\n        :see: destroyoptions_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_3create(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_a = 0;
  PyObject *__pyx_v_b = 0;
  PyObject *__pyx_v_c = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("create (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_b,&__pyx_n_s_c,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("create", 1, 3, 3, 1); __PYX_ERR(0, 694, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_c)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("create", 1, 3, 3, 2); __PYX_ERR(0, 694, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "create") < 0)) __PYX_ERR(0, 694, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_a = ((PyObject*)values[0]);
    __pyx_v_b = ((PyObject*)values[1]);
    __pyx_v_c = ((PyObject*)values[2]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("create", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 694, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyOptions.create", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_a), (&PyString_Type), 1, "a", 1))) __PYX_ERR(0, 694, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_b), (&PyString_Type), 1, "b", 1))) __PYX_ERR(0, 694, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_c), (&PyString_Type), 1, "c", 1))) __PYX_ERR(0, 694, __pyx_L1_error)
  __pyx_r = __pyx_pf_12libopenzwave_9PyOptions_2create(((struct __pyx_obj_12libopenzwave_PyOptions *)__pyx_v_self), __pyx_v_a, __pyx_v_b, __pyx_v_c);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyOptions_2create(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("create", 0);

  /* "libopenzwave.pyx":710
 * 
 *         """
 *         self.options = CreateOptions(             # <<<<<<<<<<<<<<
 *             str_to_cppstr(a), str_to_cppstr(b), str_to_cppstr(c))
 *         return True
 */
  __pyx_v_self->options = OpenZWave::Options::Create(__pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_a), __pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_b), __pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_c));

  /* "libopenzwave.pyx":712
 *         self.options = CreateOptions(
 *             str_to_cppstr(a), str_to_cppstr(b), str_to_cppstr(c))
 *         return True             # <<<<<<<<<<<<<<
 * 
 *     def destroy(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_True);
  __pyx_r = Py_True;
  goto __pyx_L0;

  /* "libopenzwave.pyx":694
 * 
 * 
 *     def create(self, str a, str b, str c):             # <<<<<<<<<<<<<<
 *         """
 *         .. _createoptions:
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":714
 *         return True
 * 
 *     def destroy(self):             # <<<<<<<<<<<<<<
 *         """
 *         .. _destroyoptions:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_5destroy(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyOptions_4destroy[] = "\n        .. _destroyoptions:\n\n         Deletes the Options and cleans up any associated objects.\n         The application is responsible for destroying the Options object,\n         but this must not be done until after the Manager object has been\n         destroyed.\n\n        :return: The result of the operation.\n        :rtype: bool\n\n        :see: createoptions_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_5destroy(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("destroy (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyOptions_4destroy(((struct __pyx_obj_12libopenzwave_PyOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyOptions_4destroy(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("destroy", 0);

  /* "libopenzwave.pyx":729
 * 
 *         """
 *         return self.options.Destroy()             # <<<<<<<<<<<<<<
 * 
 *     def lock(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->options->Destroy()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 729, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":714
 *         return True
 * 
 *     def destroy(self):             # <<<<<<<<<<<<<<
 *         """
 *         .. _destroyoptions:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyOptions.destroy", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":731
 *         return self.options.Destroy()
 * 
 *     def lock(self):             # <<<<<<<<<<<<<<
 *         """
 *         .. _lock:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_7lock(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyOptions_6lock[] = "\n        .. _lock:\n\n        Lock the options. Needed to start the manager\n\n        :return: The result of the operation.\n        :rtype: bool\n\n        :see: areLocked_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_7lock(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("lock (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyOptions_6lock(((struct __pyx_obj_12libopenzwave_PyOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyOptions_6lock(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  int __pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  __Pyx_RefNannySetupContext("lock", 0);

  /* "libopenzwave.pyx":743
 * 
 *         """
 *         if not os.path.isfile(os.path.join(self._user_path,'options.xml')):             # <<<<<<<<<<<<<<
 *             if os.path.isfile(os.path.join(self._config_path,'options.xml')):
 *                 copyfile(os.path.join(self._config_path,'options.xml'), os.path.join(self._user_path,'options.xml'))
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 743, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_path); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 743, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_isfile); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 743, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 743, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 743, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_join); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 743, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = NULL;
  __pyx_t_6 = 0;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
      __pyx_t_6 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_self->_user_path, __pyx_kp_s_options_xml};
    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 743, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_3);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_self->_user_path, __pyx_kp_s_options_xml};
    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 743, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_3);
  } else
  #endif
  {
    __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 743, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    if (__pyx_t_5) {
      __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __pyx_t_5 = NULL;
    }
    __Pyx_INCREF(__pyx_v_self->_user_path);
    __Pyx_GIVEREF(__pyx_v_self->_user_path);
    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_v_self->_user_path);
    __Pyx_INCREF(__pyx_kp_s_options_xml);
    __Pyx_GIVEREF(__pyx_kp_s_options_xml);
    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_kp_s_options_xml);
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 743, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_4) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 743, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_t_3};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 743, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_t_3};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 743, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else
    #endif
    {
      __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 743, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_t_3);
      __pyx_t_3 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 743, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 743, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_9 = ((!__pyx_t_8) != 0);
  if (__pyx_t_9) {

    /* "libopenzwave.pyx":744
 *         """
 *         if not os.path.isfile(os.path.join(self._user_path,'options.xml')):
 *             if os.path.isfile(os.path.join(self._config_path,'options.xml')):             # <<<<<<<<<<<<<<
 *                 copyfile(os.path.join(self._config_path,'options.xml'), os.path.join(self._user_path,'options.xml'))
 *             else:
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 744, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_path); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 744, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_isfile); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 744, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 744, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_path); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 744, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_join); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 744, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = NULL;
    __pyx_t_6 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
        __pyx_t_6 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_self->_config_path, __pyx_kp_s_options_xml};
      __pyx_t_7 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 744, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_7);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_self->_config_path, __pyx_kp_s_options_xml};
      __pyx_t_7 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 744, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_7);
    } else
    #endif
    {
      __pyx_t_5 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 744, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      if (__pyx_t_4) {
        __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
      }
      __Pyx_INCREF(__pyx_v_self->_config_path);
      __Pyx_GIVEREF(__pyx_v_self->_config_path);
      PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_6, __pyx_v_self->_config_path);
      __Pyx_INCREF(__pyx_kp_s_options_xml);
      __Pyx_GIVEREF(__pyx_kp_s_options_xml);
      PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_6, __pyx_kp_s_options_xml);
      __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 744, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    if (!__pyx_t_3) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 744, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_2)) {
        PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_t_7};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 744, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
        PyObject *__pyx_temp[2] = {__pyx_t_3, __pyx_t_7};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 744, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      } else
      #endif
      {
        __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 744, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
        __Pyx_GIVEREF(__pyx_t_7);
        PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_7);
        __pyx_t_7 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 744, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 744, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (__pyx_t_9) {

      /* "libopenzwave.pyx":745
 *         if not os.path.isfile(os.path.join(self._user_path,'options.xml')):
 *             if os.path.isfile(os.path.join(self._config_path,'options.xml')):
 *                 copyfile(os.path.join(self._config_path,'options.xml'), os.path.join(self._user_path,'options.xml'))             # <<<<<<<<<<<<<<
 *             else:
 *                 logger.warning("Can't find options.xml in %s"%self._config_path)
 */
      __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_copyfile); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 745, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 745, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_path); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 745, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_join); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 745, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = NULL;
      __pyx_t_6 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_7);
        if (likely(__pyx_t_3)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
          __Pyx_INCREF(__pyx_t_3);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_7, function);
          __pyx_t_6 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_7)) {
        PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_self->_config_path, __pyx_kp_s_options_xml};
        __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 745, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_GOTREF(__pyx_t_5);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_7)) {
        PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_self->_config_path, __pyx_kp_s_options_xml};
        __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 745, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_GOTREF(__pyx_t_5);
      } else
      #endif
      {
        __pyx_t_4 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 745, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        if (__pyx_t_3) {
          __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3); __pyx_t_3 = NULL;
        }
        __Pyx_INCREF(__pyx_v_self->_config_path);
        __Pyx_GIVEREF(__pyx_v_self->_config_path);
        PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_6, __pyx_v_self->_config_path);
        __Pyx_INCREF(__pyx_kp_s_options_xml);
        __Pyx_GIVEREF(__pyx_kp_s_options_xml);
        PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_6, __pyx_kp_s_options_xml);
        __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 745, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      }
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 745, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_path); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 745, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_join); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 745, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = NULL;
      __pyx_t_6 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_3)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_3);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
          __pyx_t_6 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_self->_user_path, __pyx_kp_s_options_xml};
        __pyx_t_7 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 745, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_GOTREF(__pyx_t_7);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_self->_user_path, __pyx_kp_s_options_xml};
        __pyx_t_7 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 745, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_GOTREF(__pyx_t_7);
      } else
      #endif
      {
        __pyx_t_10 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 745, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_10);
        if (__pyx_t_3) {
          __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_3); __pyx_t_3 = NULL;
        }
        __Pyx_INCREF(__pyx_v_self->_user_path);
        __Pyx_GIVEREF(__pyx_v_self->_user_path);
        PyTuple_SET_ITEM(__pyx_t_10, 0+__pyx_t_6, __pyx_v_self->_user_path);
        __Pyx_INCREF(__pyx_kp_s_options_xml);
        __Pyx_GIVEREF(__pyx_kp_s_options_xml);
        PyTuple_SET_ITEM(__pyx_t_10, 1+__pyx_t_6, __pyx_kp_s_options_xml);
        __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_10, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 745, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
      }
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = NULL;
      __pyx_t_6 = 0;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_2, function);
          __pyx_t_6 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_2)) {
        PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_t_5, __pyx_t_7};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 745, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
        PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_t_5, __pyx_t_7};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 745, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      } else
      #endif
      {
        __pyx_t_10 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 745, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_10);
        if (__pyx_t_4) {
          __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_4); __pyx_t_4 = NULL;
        }
        __Pyx_GIVEREF(__pyx_t_5);
        PyTuple_SET_ITEM(__pyx_t_10, 0+__pyx_t_6, __pyx_t_5);
        __Pyx_GIVEREF(__pyx_t_7);
        PyTuple_SET_ITEM(__pyx_t_10, 1+__pyx_t_6, __pyx_t_7);
        __pyx_t_5 = 0;
        __pyx_t_7 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 745, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
      }
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "libopenzwave.pyx":744
 *         """
 *         if not os.path.isfile(os.path.join(self._user_path,'options.xml')):
 *             if os.path.isfile(os.path.join(self._config_path,'options.xml')):             # <<<<<<<<<<<<<<
 *                 copyfile(os.path.join(self._config_path,'options.xml'), os.path.join(self._user_path,'options.xml'))
 *             else:
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":747
 *                 copyfile(os.path.join(self._config_path,'options.xml'), os.path.join(self._user_path,'options.xml'))
 *             else:
 *                 logger.warning("Can't find options.xml in %s"%self._config_path)             # <<<<<<<<<<<<<<
 *         return self.options.Lock()
 * 
 */
    /*else*/ {
      __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 747, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_warning); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 747, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_10);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_Can_t_find_options_xml_in_s, __pyx_v_self->_config_path); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 747, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_7 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_10))) {
        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_10);
        if (likely(__pyx_t_7)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
          __Pyx_INCREF(__pyx_t_7);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_10, function);
        }
      }
      if (!__pyx_t_7) {
        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_10, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 747, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else {
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_10)) {
          PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_t_2};
          __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_10, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 747, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_10)) {
          PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_t_2};
          __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_10, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 747, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        } else
        #endif
        {
          __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 747, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_7); __pyx_t_7 = NULL;
          __Pyx_GIVEREF(__pyx_t_2);
          PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_2);
          __pyx_t_2 = 0;
          __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_10, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 747, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        }
      }
      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    }
    __pyx_L4:;

    /* "libopenzwave.pyx":743
 * 
 *         """
 *         if not os.path.isfile(os.path.join(self._user_path,'options.xml')):             # <<<<<<<<<<<<<<
 *             if os.path.isfile(os.path.join(self._config_path,'options.xml')):
 *                 copyfile(os.path.join(self._config_path,'options.xml'), os.path.join(self._user_path,'options.xml'))
 */
  }

  /* "libopenzwave.pyx":748
 *             else:
 *                 logger.warning("Can't find options.xml in %s"%self._config_path)
 *         return self.options.Lock()             # <<<<<<<<<<<<<<
 * 
 *     def areLocked(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->options->Lock()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 748, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":731
 *         return self.options.Destroy()
 * 
 *     def lock(self):             # <<<<<<<<<<<<<<
 *         """
 *         .. _lock:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_AddTraceback("libopenzwave.PyOptions.lock", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":750
 *         return self.options.Lock()
 * 
 *     def areLocked(self):             # <<<<<<<<<<<<<<
 *         '''
 *         .. _areLocked:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_9areLocked(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyOptions_8areLocked[] = "\n        .. _areLocked:\n\n         Test whether the options have been locked.\n\n        :return: true if the options have been locked.\n        :rtype: boolean\n\n        :see: lock_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_9areLocked(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("areLocked (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyOptions_8areLocked(((struct __pyx_obj_12libopenzwave_PyOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyOptions_8areLocked(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("areLocked", 0);

  /* "libopenzwave.pyx":762
 * 
 *         '''
 *         return self.options.AreLocked()             # <<<<<<<<<<<<<<
 * 
 *     def addOptionBool(self, str name, value):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->options->AreLocked()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 762, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":750
 *         return self.options.Lock()
 * 
 *     def areLocked(self):             # <<<<<<<<<<<<<<
 *         '''
 *         .. _areLocked:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyOptions.areLocked", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":764
 *         return self.options.AreLocked()
 * 
 *     def addOptionBool(self, str name, value):             # <<<<<<<<<<<<<<
 *         """
 *         .. _addOptionBool:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_11addOptionBool(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyOptions_10addOptionBool[] = "\n        .. _addOptionBool:\n\n        Add a boolean option.\n\n        :param name: The name of the option.\n        :type name: str\n        :param value: The value of the option.\n        :type value: boolean\n        :return: The result of the operation.\n        :rtype: bool\n\n        :see: addOption_, addOptionInt_, addOptionString_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_11addOptionBool(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_name = 0;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("addOptionBool (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_name,&__pyx_n_s_value,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("addOptionBool", 1, 2, 2, 1); __PYX_ERR(0, 764, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "addOptionBool") < 0)) __PYX_ERR(0, 764, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_name = ((PyObject*)values[0]);
    __pyx_v_value = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("addOptionBool", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 764, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyOptions.addOptionBool", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_name), (&PyString_Type), 1, "name", 1))) __PYX_ERR(0, 764, __pyx_L1_error)
  __pyx_r = __pyx_pf_12libopenzwave_9PyOptions_10addOptionBool(((struct __pyx_obj_12libopenzwave_PyOptions *)__pyx_v_self), __pyx_v_name, __pyx_v_value);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyOptions_10addOptionBool(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name, PyObject *__pyx_v_value) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  bool __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("addOptionBool", 0);

  /* "libopenzwave.pyx":780
 * 
 *         """
 *         return self.options.AddOptionBool(str_to_cppstr(name), value)             # <<<<<<<<<<<<<<
 * 
 *     def addOptionInt(self, str name, value):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_1 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 780, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->options->AddOptionBool(__pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_name), __pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 780, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":764
 *         return self.options.AreLocked()
 * 
 *     def addOptionBool(self, str name, value):             # <<<<<<<<<<<<<<
 *         """
 *         .. _addOptionBool:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyOptions.addOptionBool", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":782
 *         return self.options.AddOptionBool(str_to_cppstr(name), value)
 * 
 *     def addOptionInt(self, str name, value):             # <<<<<<<<<<<<<<
 *         """
 *         .. _addOptionInt:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_13addOptionInt(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyOptions_12addOptionInt[] = "\n        .. _addOptionInt:\n\n        Add an integer option.\n\n        :param name: The name of the option.\n        :type name: str\n        :param value: The value of the option.\n        :type value: boolean\n        :return: The result of the operation.\n        :rtype: bool\n\n        :see: addOption_, addOptionBool_, addOptionString_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_13addOptionInt(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_name = 0;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("addOptionInt (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_name,&__pyx_n_s_value,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("addOptionInt", 1, 2, 2, 1); __PYX_ERR(0, 782, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "addOptionInt") < 0)) __PYX_ERR(0, 782, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_name = ((PyObject*)values[0]);
    __pyx_v_value = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("addOptionInt", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 782, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyOptions.addOptionInt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_name), (&PyString_Type), 1, "name", 1))) __PYX_ERR(0, 782, __pyx_L1_error)
  __pyx_r = __pyx_pf_12libopenzwave_9PyOptions_12addOptionInt(((struct __pyx_obj_12libopenzwave_PyOptions *)__pyx_v_self), __pyx_v_name, __pyx_v_value);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyOptions_12addOptionInt(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name, PyObject *__pyx_v_value) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("addOptionInt", 0);

  /* "libopenzwave.pyx":798
 * 
 *         """
 *         return self.options.AddOptionInt(str_to_cppstr(name), value)             # <<<<<<<<<<<<<<
 * 
 *     def addOptionString(self, str name, str value, append=False):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_int32_t(__pyx_v_value); if (unlikely((__pyx_t_1 == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 798, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->options->AddOptionInt(__pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_name), __pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":782
 *         return self.options.AddOptionBool(str_to_cppstr(name), value)
 * 
 *     def addOptionInt(self, str name, value):             # <<<<<<<<<<<<<<
 *         """
 *         .. _addOptionInt:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyOptions.addOptionInt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":800
 *         return self.options.AddOptionInt(str_to_cppstr(name), value)
 * 
 *     def addOptionString(self, str name, str value, append=False):             # <<<<<<<<<<<<<<
 *         """
 *         .. _addOptionString:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_15addOptionString(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyOptions_14addOptionString[] = "\n        .. _addOptionString:\n\n        Add a string option.\n\n        :param name: The name of the option.  Option names are case insensitive and must be unique.\n        :type name: str\n        :param value: The value of the option.\n        :type value: str\n        :param append: Setting append to true will cause values read from the command line\n         or XML file to be concatenated into a comma delimited set.  If _append is false,\n         newer values will overwrite older ones.\n        :type append: boolean\n        :return: The result of the operation.\n        :rtype: bool\n\n        :see: addOption_, addOptionBool_, addOptionInt_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_15addOptionString(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_name = 0;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_v_append = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("addOptionString (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_name,&__pyx_n_s_value,&__pyx_n_s_append,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("addOptionString", 0, 2, 3, 1); __PYX_ERR(0, 800, __pyx_L3_error)
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_append);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "addOptionString") < 0)) __PYX_ERR(0, 800, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_name = ((PyObject*)values[0]);
    __pyx_v_value = ((PyObject*)values[1]);
    __pyx_v_append = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("addOptionString", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 800, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyOptions.addOptionString", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_name), (&PyString_Type), 1, "name", 1))) __PYX_ERR(0, 800, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_value), (&PyString_Type), 1, "value", 1))) __PYX_ERR(0, 800, __pyx_L1_error)
  __pyx_r = __pyx_pf_12libopenzwave_9PyOptions_14addOptionString(((struct __pyx_obj_12libopenzwave_PyOptions *)__pyx_v_self), __pyx_v_name, __pyx_v_value, __pyx_v_append);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyOptions_14addOptionString(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name, PyObject *__pyx_v_value, PyObject *__pyx_v_append) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  bool __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("addOptionString", 0);

  /* "libopenzwave.pyx":820
 * 
 *         """
 *         return self.options.AddOptionString(             # <<<<<<<<<<<<<<
 *             str_to_cppstr(name), str_to_cppstr(value), append)
 * 
 */
  __Pyx_XDECREF(__pyx_r);

  /* "libopenzwave.pyx":821
 *         """
 *         return self.options.AddOptionString(
 *             str_to_cppstr(name), str_to_cppstr(value), append)             # <<<<<<<<<<<<<<
 * 
 *     def addOption(self, name, value):
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_append); if (unlikely((__pyx_t_1 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 821, __pyx_L1_error)

  /* "libopenzwave.pyx":820
 * 
 *         """
 *         return self.options.AddOptionString(             # <<<<<<<<<<<<<<
 *             str_to_cppstr(name), str_to_cppstr(value), append)
 * 
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->options->AddOptionString(__pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_name), __pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_value), __pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 820, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":800
 *         return self.options.AddOptionInt(str_to_cppstr(name), value)
 * 
 *     def addOptionString(self, str name, str value, append=False):             # <<<<<<<<<<<<<<
 *         """
 *         .. _addOptionString:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyOptions.addOptionString", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":823
 *             str_to_cppstr(name), str_to_cppstr(value), append)
 * 
 *     def addOption(self, name, value):             # <<<<<<<<<<<<<<
 *         """
 *         .. _addOption:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_17addOption(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyOptions_16addOption[] = "\n        .. _addOption:\n\n        Add an option.\n\n        :param name: The name of the option.\n        :type name: string\n        :param value: The value of the option.\n        :type value: boolean, integer, string\n        :return: The result of the operation.\n        :rtype: bool\n\n        :see: addOptionBool_, addOptionInt_, addOptionString_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_17addOption(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_name = 0;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("addOption (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_name,&__pyx_n_s_value,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("addOption", 1, 2, 2, 1); __PYX_ERR(0, 823, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "addOption") < 0)) __PYX_ERR(0, 823, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_name = values[0];
    __pyx_v_value = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("addOption", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 823, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyOptions.addOption", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyOptions_16addOption(((struct __pyx_obj_12libopenzwave_PyOptions *)__pyx_v_self), __pyx_v_name, __pyx_v_value);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyOptions_16addOption(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name, PyObject *__pyx_v_value) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  __Pyx_RefNannySetupContext("addOption", 0);

  /* "libopenzwave.pyx":839
 * 
 *         """
 *         if name not in PyOptionList:             # <<<<<<<<<<<<<<
 *             return False
 *         if PyOptionList[name]['type'] == "String":
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyOptionList); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 839, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_v_name, __pyx_t_1, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 839, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {

    /* "libopenzwave.pyx":840
 *         """
 *         if name not in PyOptionList:
 *             return False             # <<<<<<<<<<<<<<
 *         if PyOptionList[name]['type'] == "String":
 *             return self.addOptionString(name, value)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;

    /* "libopenzwave.pyx":839
 * 
 *         """
 *         if name not in PyOptionList:             # <<<<<<<<<<<<<<
 *             return False
 *         if PyOptionList[name]['type'] == "String":
 */
  }

  /* "libopenzwave.pyx":841
 *         if name not in PyOptionList:
 *             return False
 *         if PyOptionList[name]['type'] == "String":             # <<<<<<<<<<<<<<
 *             return self.addOptionString(name, value)
 *         elif PyOptionList[name]['type'] == "Bool":
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyOptionList); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 841, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = PyObject_GetItem(__pyx_t_1, __pyx_v_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 841, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyObject_GetItem(__pyx_t_4, __pyx_n_s_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 841, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_String, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 841, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_3) {

    /* "libopenzwave.pyx":842
 *             return False
 *         if PyOptionList[name]['type'] == "String":
 *             return self.addOptionString(name, value)             # <<<<<<<<<<<<<<
 *         elif PyOptionList[name]['type'] == "Bool":
 *             return self.addOptionBool(name, value)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_addOptionString); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 842, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    __pyx_t_6 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
        __pyx_t_6 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_name, __pyx_v_value};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 842, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_name, __pyx_v_value};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 842, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 842, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      if (__pyx_t_5) {
        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __pyx_t_5 = NULL;
      }
      __Pyx_INCREF(__pyx_v_name);
      __Pyx_GIVEREF(__pyx_v_name);
      PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_v_name);
      __Pyx_INCREF(__pyx_v_value);
      __Pyx_GIVEREF(__pyx_v_value);
      PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_v_value);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 842, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":841
 *         if name not in PyOptionList:
 *             return False
 *         if PyOptionList[name]['type'] == "String":             # <<<<<<<<<<<<<<
 *             return self.addOptionString(name, value)
 *         elif PyOptionList[name]['type'] == "Bool":
 */
  }

  /* "libopenzwave.pyx":843
 *         if PyOptionList[name]['type'] == "String":
 *             return self.addOptionString(name, value)
 *         elif PyOptionList[name]['type'] == "Bool":             # <<<<<<<<<<<<<<
 *             return self.addOptionBool(name, value)
 *         elif PyOptionList[name]['type'] == "Int":
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyOptionList); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 843, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = PyObject_GetItem(__pyx_t_1, __pyx_v_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 843, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyObject_GetItem(__pyx_t_4, __pyx_n_s_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 843, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_Bool, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 843, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_3) {

    /* "libopenzwave.pyx":844
 *             return self.addOptionString(name, value)
 *         elif PyOptionList[name]['type'] == "Bool":
 *             return self.addOptionBool(name, value)             # <<<<<<<<<<<<<<
 *         elif PyOptionList[name]['type'] == "Int":
 *             return self.addOptionInt(name, value)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_addOptionBool); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 844, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = NULL;
    __pyx_t_6 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
        __pyx_t_6 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_name, __pyx_v_value};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 844, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_name, __pyx_v_value};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 844, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_5 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 844, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      if (__pyx_t_7) {
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_7); __pyx_t_7 = NULL;
      }
      __Pyx_INCREF(__pyx_v_name);
      __Pyx_GIVEREF(__pyx_v_name);
      PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_6, __pyx_v_name);
      __Pyx_INCREF(__pyx_v_value);
      __Pyx_GIVEREF(__pyx_v_value);
      PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_6, __pyx_v_value);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 844, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":843
 *         if PyOptionList[name]['type'] == "String":
 *             return self.addOptionString(name, value)
 *         elif PyOptionList[name]['type'] == "Bool":             # <<<<<<<<<<<<<<
 *             return self.addOptionBool(name, value)
 *         elif PyOptionList[name]['type'] == "Int":
 */
  }

  /* "libopenzwave.pyx":845
 *         elif PyOptionList[name]['type'] == "Bool":
 *             return self.addOptionBool(name, value)
 *         elif PyOptionList[name]['type'] == "Int":             # <<<<<<<<<<<<<<
 *             return self.addOptionInt(name, value)
 *         return False
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyOptionList); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 845, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = PyObject_GetItem(__pyx_t_1, __pyx_v_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 845, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyObject_GetItem(__pyx_t_4, __pyx_n_s_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 845, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_Int, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 845, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_3) {

    /* "libopenzwave.pyx":846
 *             return self.addOptionBool(name, value)
 *         elif PyOptionList[name]['type'] == "Int":
 *             return self.addOptionInt(name, value)             # <<<<<<<<<<<<<<
 *         return False
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_addOptionInt); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 846, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    __pyx_t_6 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
        __pyx_t_6 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_name, __pyx_v_value};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 846, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_name, __pyx_v_value};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 846, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 846, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      if (__pyx_t_5) {
        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __pyx_t_5 = NULL;
      }
      __Pyx_INCREF(__pyx_v_name);
      __Pyx_GIVEREF(__pyx_v_name);
      PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_v_name);
      __Pyx_INCREF(__pyx_v_value);
      __Pyx_GIVEREF(__pyx_v_value);
      PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_v_value);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 846, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":845
 *         elif PyOptionList[name]['type'] == "Bool":
 *             return self.addOptionBool(name, value)
 *         elif PyOptionList[name]['type'] == "Int":             # <<<<<<<<<<<<<<
 *             return self.addOptionInt(name, value)
 *         return False
 */
  }

  /* "libopenzwave.pyx":847
 *         elif PyOptionList[name]['type'] == "Int":
 *             return self.addOptionInt(name, value)
 *         return False             # <<<<<<<<<<<<<<
 * 
 *     def getOption(self, name):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_False);
  __pyx_r = Py_False;
  goto __pyx_L0;

  /* "libopenzwave.pyx":823
 *             str_to_cppstr(name), str_to_cppstr(value), append)
 * 
 *     def addOption(self, name, value):             # <<<<<<<<<<<<<<
 *         """
 *         .. _addOption:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("libopenzwave.PyOptions.addOption", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":849
 *         return False
 * 
 *     def getOption(self, name):             # <<<<<<<<<<<<<<
 *         """
 *         .. _getOption:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_19getOption(PyObject *__pyx_v_self, PyObject *__pyx_v_name); /*proto*/
static char __pyx_doc_12libopenzwave_9PyOptions_18getOption[] = "\n        .. _getOption:\n\n        Retrieve option of a value.\n\n        :param name: The name of the option.\n        :type name: string\n        :return: The value\n        :rtype: boolean, integer, string or None\n\n        :see: getOptionAsBool_, getOptionAsInt_, getOptionAsString_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_19getOption(PyObject *__pyx_v_self, PyObject *__pyx_v_name) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getOption (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyOptions_18getOption(((struct __pyx_obj_12libopenzwave_PyOptions *)__pyx_v_self), ((PyObject *)__pyx_v_name));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyOptions_18getOption(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannySetupContext("getOption", 0);

  /* "libopenzwave.pyx":863
 * 
 *         """
 *         if name not in PyOptionList:             # <<<<<<<<<<<<<<
 *             return None
 *         if PyOptionList[name]['type'] == "String":
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyOptionList); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 863, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_v_name, __pyx_t_1, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 863, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {

    /* "libopenzwave.pyx":864
 *         """
 *         if name not in PyOptionList:
 *             return None             # <<<<<<<<<<<<<<
 *         if PyOptionList[name]['type'] == "String":
 *             return self.getOptionAsString(name)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;

    /* "libopenzwave.pyx":863
 * 
 *         """
 *         if name not in PyOptionList:             # <<<<<<<<<<<<<<
 *             return None
 *         if PyOptionList[name]['type'] == "String":
 */
  }

  /* "libopenzwave.pyx":865
 *         if name not in PyOptionList:
 *             return None
 *         if PyOptionList[name]['type'] == "String":             # <<<<<<<<<<<<<<
 *             return self.getOptionAsString(name)
 *         elif PyOptionList[name]['type'] == "Bool":
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyOptionList); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 865, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = PyObject_GetItem(__pyx_t_1, __pyx_v_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 865, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyObject_GetItem(__pyx_t_4, __pyx_n_s_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 865, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_String, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 865, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_3) {

    /* "libopenzwave.pyx":866
 *             return None
 *         if PyOptionList[name]['type'] == "String":
 *             return self.getOptionAsString(name)             # <<<<<<<<<<<<<<
 *         elif PyOptionList[name]['type'] == "Bool":
 *             return self.getOptionAsBool(name)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_getOptionAsString); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 866, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_5) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 866, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_v_name};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 866, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_v_name};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 866, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else
      #endif
      {
        __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 866, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __pyx_t_5 = NULL;
        __Pyx_INCREF(__pyx_v_name);
        __Pyx_GIVEREF(__pyx_v_name);
        PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_v_name);
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 866, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":865
 *         if name not in PyOptionList:
 *             return None
 *         if PyOptionList[name]['type'] == "String":             # <<<<<<<<<<<<<<
 *             return self.getOptionAsString(name)
 *         elif PyOptionList[name]['type'] == "Bool":
 */
  }

  /* "libopenzwave.pyx":867
 *         if PyOptionList[name]['type'] == "String":
 *             return self.getOptionAsString(name)
 *         elif PyOptionList[name]['type'] == "Bool":             # <<<<<<<<<<<<<<
 *             return self.getOptionAsBool(name)
 *         elif PyOptionList[name]['type'] == "Int":
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyOptionList); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 867, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = PyObject_GetItem(__pyx_t_1, __pyx_v_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 867, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyObject_GetItem(__pyx_t_4, __pyx_n_s_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 867, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_Bool, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 867, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_3) {

    /* "libopenzwave.pyx":868
 *             return self.getOptionAsString(name)
 *         elif PyOptionList[name]['type'] == "Bool":
 *             return self.getOptionAsBool(name)             # <<<<<<<<<<<<<<
 *         elif PyOptionList[name]['type'] == "Int":
 *             return self.getOptionAsInt(name)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_getOptionAsBool); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 868, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_6) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 868, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_v_name};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 868, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_v_name};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 868, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else
      #endif
      {
        __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 868, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_6); __pyx_t_6 = NULL;
        __Pyx_INCREF(__pyx_v_name);
        __Pyx_GIVEREF(__pyx_v_name);
        PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_v_name);
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 868, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":867
 *         if PyOptionList[name]['type'] == "String":
 *             return self.getOptionAsString(name)
 *         elif PyOptionList[name]['type'] == "Bool":             # <<<<<<<<<<<<<<
 *             return self.getOptionAsBool(name)
 *         elif PyOptionList[name]['type'] == "Int":
 */
  }

  /* "libopenzwave.pyx":869
 *         elif PyOptionList[name]['type'] == "Bool":
 *             return self.getOptionAsBool(name)
 *         elif PyOptionList[name]['type'] == "Int":             # <<<<<<<<<<<<<<
 *             return self.getOptionAsInt(name)
 *         return False
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyOptionList); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 869, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = PyObject_GetItem(__pyx_t_1, __pyx_v_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 869, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyObject_GetItem(__pyx_t_4, __pyx_n_s_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 869, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_Int, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 869, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_3) {

    /* "libopenzwave.pyx":870
 *             return self.getOptionAsBool(name)
 *         elif PyOptionList[name]['type'] == "Int":
 *             return self.getOptionAsInt(name)             # <<<<<<<<<<<<<<
 *         return False
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_getOptionAsInt); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 870, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_5) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 870, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_v_name};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 870, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_v_name};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 870, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else
      #endif
      {
        __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 870, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __pyx_t_5 = NULL;
        __Pyx_INCREF(__pyx_v_name);
        __Pyx_GIVEREF(__pyx_v_name);
        PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_v_name);
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 870, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":869
 *         elif PyOptionList[name]['type'] == "Bool":
 *             return self.getOptionAsBool(name)
 *         elif PyOptionList[name]['type'] == "Int":             # <<<<<<<<<<<<<<
 *             return self.getOptionAsInt(name)
 *         return False
 */
  }

  /* "libopenzwave.pyx":871
 *         elif PyOptionList[name]['type'] == "Int":
 *             return self.getOptionAsInt(name)
 *         return False             # <<<<<<<<<<<<<<
 * 
 *     def getOptionAsBool(self, name):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_False);
  __pyx_r = Py_False;
  goto __pyx_L0;

  /* "libopenzwave.pyx":849
 *         return False
 * 
 *     def getOption(self, name):             # <<<<<<<<<<<<<<
 *         """
 *         .. _getOption:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("libopenzwave.PyOptions.getOption", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":873
 *         return False
 * 
 *     def getOptionAsBool(self, name):             # <<<<<<<<<<<<<<
 *         """
 *         .. _getOptionAsBool:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_21getOptionAsBool(PyObject *__pyx_v_self, PyObject *__pyx_v_name); /*proto*/
static char __pyx_doc_12libopenzwave_9PyOptions_20getOptionAsBool[] = "\n        .. _getOptionAsBool:\n\n        Retrieve boolean value of an option.\n\n        :param name: The name of the option.\n        :type name: string\n        :return: The value or None\n        :rtype: boolean or None\n\n        :see: getOption_, getOptionAsInt_, getOptionAsString_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_21getOptionAsBool(PyObject *__pyx_v_self, PyObject *__pyx_v_name) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getOptionAsBool (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyOptions_20getOptionAsBool(((struct __pyx_obj_12libopenzwave_PyOptions *)__pyx_v_self), ((PyObject *)__pyx_v_name));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyOptions_20getOptionAsBool(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name) {
  bool __pyx_v_type_bool;
  bool __pyx_v_cret;
  PyObject *__pyx_v_ret = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("getOptionAsBool", 0);

  /* "libopenzwave.pyx":888
 *         """
 *         cdef bool type_bool
 *         cret = self.options.GetOptionAsBool(str_to_cppstr(name), &type_bool)             # <<<<<<<<<<<<<<
 *         ret = type_bool if cret==True else None
 *         return ret
 */
  if (!(likely(PyString_CheckExact(__pyx_v_name))||((__pyx_v_name) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_v_name)->tp_name), 0))) __PYX_ERR(0, 888, __pyx_L1_error)
  __pyx_v_cret = __pyx_v_self->options->GetOptionAsBool(__pyx_f_12libopenzwave_str_to_cppstr(((PyObject*)__pyx_v_name)), (&__pyx_v_type_bool));

  /* "libopenzwave.pyx":889
 *         cdef bool type_bool
 *         cret = self.options.GetOptionAsBool(str_to_cppstr(name), &type_bool)
 *         ret = type_bool if cret==True else None             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
  if (((__pyx_v_cret == 1) != 0)) {
    __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_type_bool); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 889, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = __pyx_t_2;
    __pyx_t_2 = 0;
  } else {
    __Pyx_INCREF(Py_None);
    __pyx_t_1 = Py_None;
  }
  __pyx_v_ret = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "libopenzwave.pyx":890
 *         cret = self.options.GetOptionAsBool(str_to_cppstr(name), &type_bool)
 *         ret = type_bool if cret==True else None
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def getOptionAsInt(self, name):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "libopenzwave.pyx":873
 *         return False
 * 
 *     def getOptionAsBool(self, name):             # <<<<<<<<<<<<<<
 *         """
 *         .. _getOptionAsBool:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyOptions.getOptionAsBool", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_ret);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":892
 *         return ret
 * 
 *     def getOptionAsInt(self, name):             # <<<<<<<<<<<<<<
 *         """
 *         .. _getOptionAsInt:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_23getOptionAsInt(PyObject *__pyx_v_self, PyObject *__pyx_v_name); /*proto*/
static char __pyx_doc_12libopenzwave_9PyOptions_22getOptionAsInt[] = "\n        .. _getOptionAsInt:\n\n        Retrieve integer value of an option.\n\n        :param name: The name of the option.\n        :type name: string\n        :return: The value or None\n        :rtype: Integer or None\n\n        :see: getOption_, getOptionAsBool_, getOptionAsString_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_23getOptionAsInt(PyObject *__pyx_v_self, PyObject *__pyx_v_name) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getOptionAsInt (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyOptions_22getOptionAsInt(((struct __pyx_obj_12libopenzwave_PyOptions *)__pyx_v_self), ((PyObject *)__pyx_v_name));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyOptions_22getOptionAsInt(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name) {
  int32_t __pyx_v_type_int;
  bool __pyx_v_cret;
  PyObject *__pyx_v_ret = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("getOptionAsInt", 0);

  /* "libopenzwave.pyx":907
 *         """
 *         cdef int32_t type_int
 *         cret = self.options.GetOptionAsInt(str_to_cppstr(name), &type_int)             # <<<<<<<<<<<<<<
 *         ret = type_int if cret==True else None
 *         return ret
 */
  if (!(likely(PyString_CheckExact(__pyx_v_name))||((__pyx_v_name) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_v_name)->tp_name), 0))) __PYX_ERR(0, 907, __pyx_L1_error)
  __pyx_v_cret = __pyx_v_self->options->GetOptionAsInt(__pyx_f_12libopenzwave_str_to_cppstr(((PyObject*)__pyx_v_name)), (&__pyx_v_type_int));

  /* "libopenzwave.pyx":908
 *         cdef int32_t type_int
 *         cret = self.options.GetOptionAsInt(str_to_cppstr(name), &type_int)
 *         ret = type_int if cret==True else None             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
  if (((__pyx_v_cret == 1) != 0)) {
    __pyx_t_2 = __Pyx_PyInt_From_int32_t(__pyx_v_type_int); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 908, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = __pyx_t_2;
    __pyx_t_2 = 0;
  } else {
    __Pyx_INCREF(Py_None);
    __pyx_t_1 = Py_None;
  }
  __pyx_v_ret = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "libopenzwave.pyx":909
 *         cret = self.options.GetOptionAsInt(str_to_cppstr(name), &type_int)
 *         ret = type_int if cret==True else None
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def getOptionAsString(self, name):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "libopenzwave.pyx":892
 *         return ret
 * 
 *     def getOptionAsInt(self, name):             # <<<<<<<<<<<<<<
 *         """
 *         .. _getOptionAsInt:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyOptions.getOptionAsInt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_ret);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":911
 *         return ret
 * 
 *     def getOptionAsString(self, name):             # <<<<<<<<<<<<<<
 *         """
 *         .. _getOptionAsString:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_25getOptionAsString(PyObject *__pyx_v_self, PyObject *__pyx_v_name); /*proto*/
static char __pyx_doc_12libopenzwave_9PyOptions_24getOptionAsString[] = "\n        .. _getOptionAsString:\n\n        Retrieve string value of an option.\n\n        :param name: The name of the option.\n        :type name: string\n        :return: The value or None\n        :rtype: String or None\n\n        :see: getOption_, getOptionAsBool_, getOptionAsInt_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_25getOptionAsString(PyObject *__pyx_v_self, PyObject *__pyx_v_name) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getOptionAsString (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyOptions_24getOptionAsString(((struct __pyx_obj_12libopenzwave_PyOptions *)__pyx_v_self), ((PyObject *)__pyx_v_name));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyOptions_24getOptionAsString(struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self, PyObject *__pyx_v_name) {
  std::string __pyx_v_type_string;
  bool __pyx_v_cret;
  PyObject *__pyx_v_ret = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getOptionAsString", 0);

  /* "libopenzwave.pyx":926
 *         """
 *         cdef string type_string
 *         cret = self.options.GetOptionAsString(str_to_cppstr(name), &type_string)             # <<<<<<<<<<<<<<
 *         ret = cstr_to_str(type_string.c_str()) if cret==True else None
 *         return ret
 */
  if (!(likely(PyString_CheckExact(__pyx_v_name))||((__pyx_v_name) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_v_name)->tp_name), 0))) __PYX_ERR(0, 926, __pyx_L1_error)
  __pyx_v_cret = __pyx_v_self->options->GetOptionAsString(__pyx_f_12libopenzwave_str_to_cppstr(((PyObject*)__pyx_v_name)), (&__pyx_v_type_string));

  /* "libopenzwave.pyx":927
 *         cdef string type_string
 *         cret = self.options.GetOptionAsString(str_to_cppstr(name), &type_string)
 *         ret = cstr_to_str(type_string.c_str()) if cret==True else None             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
  if (((__pyx_v_cret == 1) != 0)) {
    __pyx_t_2 = __Pyx_PyUnicode_FromString(__pyx_v_type_string.c_str()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 927, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 927, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_1 = __pyx_t_3;
    __pyx_t_3 = 0;
  } else {
    __Pyx_INCREF(Py_None);
    __pyx_t_1 = Py_None;
  }
  __pyx_v_ret = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "libopenzwave.pyx":928
 *         cret = self.options.GetOptionAsString(str_to_cppstr(name), &type_string)
 *         ret = cstr_to_str(type_string.c_str()) if cret==True else None
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def getConfigPath(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "libopenzwave.pyx":911
 *         return ret
 * 
 *     def getOptionAsString(self, name):             # <<<<<<<<<<<<<<
 *         """
 *         .. _getOptionAsString:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyOptions.getOptionAsString", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_ret);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":930
 *         return ret
 * 
 *     def getConfigPath(self):             # <<<<<<<<<<<<<<
 *         '''
 *         .. _getConfigPath:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_27getConfigPath(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyOptions_26getConfigPath[] = "\n        .. _getConfigPath:\n\n        Retrieve the config path. This directory hold the xml files.\n\n        :return: A string containing the library config path or None.\n        :rtype: str\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyOptions_27getConfigPath(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getConfigPath (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyOptions_26getConfigPath(((struct __pyx_obj_12libopenzwave_PyOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyOptions_26getConfigPath(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getConfigPath", 0);

  /* "libopenzwave.pyx":940
 * 
 *         '''
 *         return configPath()             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_configPath); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 940, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 940, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 940, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":930
 *         return ret
 * 
 *     def getConfigPath(self):             # <<<<<<<<<<<<<<
 *         '''
 *         .. _getConfigPath:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyOptions.getConfigPath", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":953
 *     cdef uint8_t* data
 * 
 *     def __cinit__(self,  uint32_t siz):             # <<<<<<<<<<<<<<
 *         self.siz = siz
 *         self.data = <uint8_t*>malloc(sizeof(uint8_t) * siz)
 */

/* Python wrapper */
static int __pyx_pw_12libopenzwave_8RetAlloc_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_12libopenzwave_8RetAlloc_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  uint32_t __pyx_v_siz;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_siz,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_siz)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 953, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_siz = __Pyx_PyInt_As_uint32_t(values[0]); if (unlikely((__pyx_v_siz == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 953, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 953, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.RetAlloc.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_8RetAlloc___cinit__(((struct __pyx_obj_12libopenzwave_RetAlloc *)__pyx_v_self), __pyx_v_siz);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_12libopenzwave_8RetAlloc___cinit__(struct __pyx_obj_12libopenzwave_RetAlloc *__pyx_v_self, uint32_t __pyx_v_siz) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "libopenzwave.pyx":954
 * 
 *     def __cinit__(self,  uint32_t siz):
 *         self.siz = siz             # <<<<<<<<<<<<<<
 *         self.data = <uint8_t*>malloc(sizeof(uint8_t) * siz)
 * 
 */
  __pyx_v_self->siz = __pyx_v_siz;

  /* "libopenzwave.pyx":955
 *     def __cinit__(self,  uint32_t siz):
 *         self.siz = siz
 *         self.data = <uint8_t*>malloc(sizeof(uint8_t) * siz)             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_v_self->data = ((uint8_t *)malloc(((sizeof(uint8_t)) * __pyx_v_siz)));

  /* "libopenzwave.pyx":953
 *     cdef uint8_t* data
 * 
 *     def __cinit__(self,  uint32_t siz):             # <<<<<<<<<<<<<<
 *         self.siz = siz
 *         self.data = <uint8_t*>malloc(sizeof(uint8_t) * siz)
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":957
 *         self.data = <uint8_t*>malloc(sizeof(uint8_t) * siz)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         free(self.data)
 * 
 */

/* Python wrapper */
static void __pyx_pw_12libopenzwave_8RetAlloc_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_12libopenzwave_8RetAlloc_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_12libopenzwave_8RetAlloc_2__dealloc__(((struct __pyx_obj_12libopenzwave_RetAlloc *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_12libopenzwave_8RetAlloc_2__dealloc__(struct __pyx_obj_12libopenzwave_RetAlloc *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "libopenzwave.pyx":958
 * 
 *     def __dealloc__(self):
 *         free(self.data)             # <<<<<<<<<<<<<<
 * 
 * cdef class InstanceAssociationAlloc:
 */
  free(__pyx_v_self->data);

  /* "libopenzwave.pyx":957
 *         self.data = <uint8_t*>malloc(sizeof(uint8_t) * siz)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         free(self.data)
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "libopenzwave.pyx":970
 *     cdef uint8_t* data
 * 
 *     def __cinit__(self,  uint32_t siz):             # <<<<<<<<<<<<<<
 *         self.siz = siz
 *         self.data = <uint8_t*>malloc(sizeof(uint8_t) * siz * 2)
 */

/* Python wrapper */
static int __pyx_pw_12libopenzwave_24InstanceAssociationAlloc_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_12libopenzwave_24InstanceAssociationAlloc_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  uint32_t __pyx_v_siz;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_siz,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_siz)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 970, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_siz = __Pyx_PyInt_As_uint32_t(values[0]); if (unlikely((__pyx_v_siz == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 970, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 970, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.InstanceAssociationAlloc.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_24InstanceAssociationAlloc___cinit__(((struct __pyx_obj_12libopenzwave_InstanceAssociationAlloc *)__pyx_v_self), __pyx_v_siz);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_12libopenzwave_24InstanceAssociationAlloc___cinit__(struct __pyx_obj_12libopenzwave_InstanceAssociationAlloc *__pyx_v_self, uint32_t __pyx_v_siz) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "libopenzwave.pyx":971
 * 
 *     def __cinit__(self,  uint32_t siz):
 *         self.siz = siz             # <<<<<<<<<<<<<<
 *         self.data = <uint8_t*>malloc(sizeof(uint8_t) * siz * 2)
 * 
 */
  __pyx_v_self->siz = __pyx_v_siz;

  /* "libopenzwave.pyx":972
 *     def __cinit__(self,  uint32_t siz):
 *         self.siz = siz
 *         self.data = <uint8_t*>malloc(sizeof(uint8_t) * siz * 2)             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_v_self->data = ((uint8_t *)malloc((((sizeof(uint8_t)) * __pyx_v_siz) * 2)));

  /* "libopenzwave.pyx":970
 *     cdef uint8_t* data
 * 
 *     def __cinit__(self,  uint32_t siz):             # <<<<<<<<<<<<<<
 *         self.siz = siz
 *         self.data = <uint8_t*>malloc(sizeof(uint8_t) * siz * 2)
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":974
 *         self.data = <uint8_t*>malloc(sizeof(uint8_t) * siz * 2)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         free(self.data)
 * 
 */

/* Python wrapper */
static void __pyx_pw_12libopenzwave_24InstanceAssociationAlloc_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_12libopenzwave_24InstanceAssociationAlloc_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_12libopenzwave_24InstanceAssociationAlloc_2__dealloc__(((struct __pyx_obj_12libopenzwave_InstanceAssociationAlloc *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_12libopenzwave_24InstanceAssociationAlloc_2__dealloc__(struct __pyx_obj_12libopenzwave_InstanceAssociationAlloc *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "libopenzwave.pyx":975
 * 
 *     def __dealloc__(self):
 *         free(self.data)             # <<<<<<<<<<<<<<
 * 
 * cdef class PyManager:
 */
  free(__pyx_v_self->data);

  /* "libopenzwave.pyx":974
 *         self.data = <uint8_t*>malloc(sizeof(uint8_t) * siz * 2)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         free(self.data)
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "libopenzwave.pyx":1132
 *     cdef object _controllerCallback
 * 
 *     def create(self):             # <<<<<<<<<<<<<<
 *         '''
 * .. _create:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_1create(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_create[] = "\n.. _create:\n\nCreates the Manager singleton object.\n\nThe Manager provides the public interface to OpenZWave, exposing all the\nfunctionality required to add Z-Wave support to an application. There can be\nonly one Manager in an OpenZWave application.  An Options object must be\ncreated and Locked first, otherwise the call to Manager::Create will fail.\nOnce the Manager has been created, call AddWatcher to install a notification\ncallback handler, and then call the AddDriver method for each attached PC\nZ-Wave controller in turn.\n\n:see: destroy_\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_1create(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("create (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_create(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_create(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("create", 0);

  /* "libopenzwave.pyx":1149
 *         '''
 *         #Commented to try to fix seg fault at import
 *         Py_Initialize()             # <<<<<<<<<<<<<<
 *         PyEval_InitThreads()
 *         self.manager = CreateManager()
 */
  Py_Initialize();

  /* "libopenzwave.pyx":1150
 *         #Commented to try to fix seg fault at import
 *         Py_Initialize()
 *         PyEval_InitThreads()             # <<<<<<<<<<<<<<
 *         self.manager = CreateManager()
 * 
 */
  PyEval_InitThreads();

  /* "libopenzwave.pyx":1151
 *         Py_Initialize()
 *         PyEval_InitThreads()
 *         self.manager = CreateManager()             # <<<<<<<<<<<<<<
 * 
 *     def destroy(self):
 */
  __pyx_v_self->manager = OpenZWave::Manager::Create();

  /* "libopenzwave.pyx":1132
 *     cdef object _controllerCallback
 * 
 *     def create(self):             # <<<<<<<<<<<<<<
 *         '''
 * .. _create:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1153
 *         self.manager = CreateManager()
 * 
 *     def destroy(self):             # <<<<<<<<<<<<<<
 *         '''
 * .. _destroy:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_3destroy(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_2destroy[] = "\n.. _destroy:\n\nDeletes the Manager and cleans up any associated objects.\n\n:see: create_\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_3destroy(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("destroy (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_2destroy(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_2destroy(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("destroy", 0);

  /* "libopenzwave.pyx":1161
 * :see: create_
 *         '''
 *         self.manager.Destroy()             # <<<<<<<<<<<<<<
 * 
 * #
 */
  __pyx_v_self->manager->Destroy();

  /* "libopenzwave.pyx":1153
 *         self.manager = CreateManager()
 * 
 *     def destroy(self):             # <<<<<<<<<<<<<<
 *         '''
 * .. _destroy:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1170
 * # polled every time the application starts.
 * #
 *     def writeConfig(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * Saves the configuration of a PC Controller's Z-Wave network to the
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_5writeConfig(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_4writeConfig[] = "\nSaves the configuration of a PC Controller's Z-Wave network to the\napplication's user data folder.\n\nThis method does not normally need to be called, since OpenZWave will save the\nstate automatically during the shutdown process.  It is provided here only as\nan aid to development. The configuration of each PC Controller's Z-Wave network\nis stored in a separate file.  The filename consists of the 8 digit hexadecimal\nversion of the controller's Home ID, prefixed with the string \"zwcfg_*\".  This\nconvention allows OpenZWave to find the correct configuration file for a\ncontroller, even if it is attached to a different serial port, USB device path,\netc.\n\n:param homeid: The Home ID of the Z-Wave controller to save.\n:type homeid: int\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_5writeConfig(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("writeConfig (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_4writeConfig(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_4writeConfig(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  __Pyx_RefNannySetupContext("writeConfig", 0);

  /* "libopenzwave.pyx":1188
 * 
 *         '''
 *         self.manager.WriteConfig(homeid)             # <<<<<<<<<<<<<<
 * #
 * # -----------------------------------------------------------------------------
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1188, __pyx_L1_error)
  __pyx_v_self->manager->WriteConfig(__pyx_t_1);

  /* "libopenzwave.pyx":1170
 * # polled every time the application starts.
 * #
 *     def writeConfig(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * Saves the configuration of a PC Controller's Z-Wave network to the
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.writeConfig", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1195
 * # Methods for adding and removing drivers and obtaining basic controller information.
 * #
 *     def addDriver(self, str serialport):             # <<<<<<<<<<<<<<
 *         '''
 * .. _addDriver:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_7addDriver(PyObject *__pyx_v_self, PyObject *__pyx_v_serialport); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_6addDriver[] = "\n.. _addDriver:\n\nCreates a new driver for a Z-Wave controller.\n\nThis method creates a Driver object for handling communications with a single\nZ-Wave controller.  In the background, the driver first tries to read\nconfiguration data saved during a previous run.  It then queries the controller\ndirectly for any missing information, and a refresh of the set of nodes that\nit controls.  Once this information has been received, a DriverReady\nnotification callback is sent, containing the Home ID of the controller.  This\nHome ID is required by most of the OpenZWave Manager class methods.\n\n:param serialport: The string used to open the controller.  On Windows this might be something like \"\\.\\COM3\", or on Linux \"/dev/ttyUSB0\".\n:type serialport: str\n:return: True if a new driver was created\n:rtype: bool\n:see: removeDriver_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_7addDriver(PyObject *__pyx_v_self, PyObject *__pyx_v_serialport) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("addDriver (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_serialport), (&PyString_Type), 1, "serialport", 1))) __PYX_ERR(0, 1195, __pyx_L1_error)
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_6addDriver(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject*)__pyx_v_serialport));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_6addDriver(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_serialport) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("addDriver", 0);

  /* "libopenzwave.pyx":1216
 * 
 *         '''
 *         self.manager.AddDriver(str_to_cppstr(serialport))             # <<<<<<<<<<<<<<
 * 
 *     def removeDriver(self, str serialport):
 */
  __pyx_v_self->manager->AddDriver(__pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_serialport));

  /* "libopenzwave.pyx":1195
 * # Methods for adding and removing drivers and obtaining basic controller information.
 * #
 *     def addDriver(self, str serialport):             # <<<<<<<<<<<<<<
 *         '''
 * .. _addDriver:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1218
 *         self.manager.AddDriver(str_to_cppstr(serialport))
 * 
 *     def removeDriver(self, str serialport):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeDriver:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_9removeDriver(PyObject *__pyx_v_self, PyObject *__pyx_v_serialport); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_8removeDriver[] = "\n.. _removeDriver:\n\nRemoves the driver for a Z-Wave controller, and closes the controller.\n\nDrivers do not need to be explicitly removed before calling Destroy - this is\nhandled automatically.\n\n:param serialport: The same string as was passed in the original call toAddDriver.\n:type serialport: str\n:return: True if the driver was removed, False if it could not be found.\n:rtype: bool\n:see: addDriver_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_9removeDriver(PyObject *__pyx_v_self, PyObject *__pyx_v_serialport) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("removeDriver (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_serialport), (&PyString_Type), 1, "serialport", 1))) __PYX_ERR(0, 1218, __pyx_L1_error)
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_8removeDriver(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject*)__pyx_v_serialport));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_8removeDriver(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_serialport) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("removeDriver", 0);

  /* "libopenzwave.pyx":1234
 * 
 *         '''
 *         self.manager.RemoveDriver(str_to_cppstr(serialport))             # <<<<<<<<<<<<<<
 * 
 *     def getControllerInterfaceType(self, homeid):
 */
  __pyx_v_self->manager->RemoveDriver(__pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_serialport));

  /* "libopenzwave.pyx":1218
 *         self.manager.AddDriver(str_to_cppstr(serialport))
 * 
 *     def removeDriver(self, str serialport):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeDriver:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1236
 *         self.manager.RemoveDriver(str_to_cppstr(serialport))
 * 
 *     def getControllerInterfaceType(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .._getControllerInterfaceType:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_11getControllerInterfaceType(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_10getControllerInterfaceType[] = "\n.._getControllerInterfaceType:\nRetrieve controller interface type, Unknown, Serial, Hid\n\n:param homeId: The Home ID of the Z-Wave controller.\n:return: The controller interface type\n:rtype: str\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_11getControllerInterfaceType(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getControllerInterfaceType (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_10getControllerInterfaceType(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_10getControllerInterfaceType(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  enum OpenZWave::Driver::ControllerInterface __pyx_v_type;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getControllerInterfaceType", 0);

  /* "libopenzwave.pyx":1246
 * 
 *         '''
 *         type = self.manager.GetControllerInterfaceType(homeid)             # <<<<<<<<<<<<<<
 *         return PyControllerInterface[type]
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1246, __pyx_L1_error)
  __pyx_v_type = __pyx_v_self->manager->GetControllerInterfaceType(__pyx_t_1);

  /* "libopenzwave.pyx":1247
 *         '''
 *         type = self.manager.GetControllerInterfaceType(homeid)
 *         return PyControllerInterface[type]             # <<<<<<<<<<<<<<
 * 
 *     def getControllerPath(self, homeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyControllerInterface); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerInterface(__pyx_v_type); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PyObject_GetItem(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1236
 *         self.manager.RemoveDriver(str_to_cppstr(serialport))
 * 
 *     def getControllerInterfaceType(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .._getControllerInterfaceType:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getControllerInterfaceType", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1249
 *         return PyControllerInterface[type]
 * 
 *     def getControllerPath(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .._getControllerPath:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_13getControllerPath(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_12getControllerPath[] = "\n.._getControllerPath:\nRetrieve controller interface path, name or path used to open the controller hardware\n\n:param homeId: The Home ID of the Z-Wave controller.\n:return: The controller interface type\n:rtype: str\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_13getControllerPath(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getControllerPath (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_12getControllerPath(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_12getControllerPath(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getControllerPath", 0);

  /* "libopenzwave.pyx":1259
 * 
 *         '''
 *         cdef string c_string = self.manager.GetControllerPath(homeid)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1259, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetControllerPath(__pyx_t_1);

  /* "libopenzwave.pyx":1260
 *         '''
 *         cdef string c_string = self.manager.GetControllerPath(homeid)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getControllerNodeId(self, homeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1260, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1260, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1249
 *         return PyControllerInterface[type]
 * 
 *     def getControllerPath(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .._getControllerPath:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getControllerPath", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1262
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getControllerNodeId(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getControllerNodeId:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_15getControllerNodeId(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_14getControllerNodeId[] = "\n.. _getControllerNodeId:\n\nGet the node ID of the Z-Wave controller.\n\n:param homeId: The Home ID of the Z-Wave controller.\n:type homeId: int\n:return: The node ID of the Z-Wave controller\n:rtype: int\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_15getControllerNodeId(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getControllerNodeId (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_14getControllerNodeId(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_14getControllerNodeId(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("getControllerNodeId", 0);

  /* "libopenzwave.pyx":1274
 * 
 *         '''
 *         return self.manager.GetControllerNodeId(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def getSUCNodeId(self, homeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1274, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_From_uint8_t(__pyx_v_self->manager->GetControllerNodeId(__pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1274, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1262
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getControllerNodeId(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getControllerNodeId:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.getControllerNodeId", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1276
 *         return self.manager.GetControllerNodeId(homeid)
 * 
 *     def getSUCNodeId(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getSUCNodeId:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_17getSUCNodeId(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_16getSUCNodeId[] = "\n.. _getSUCNodeId:\n\nGet the node ID of the Static Update Controller.\n\n:param homeId: The Home ID of the Z-Wave controller.\n:type homeId: int\n:return: the node ID of the Z-Wave controller.\n:rtype: int\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_17getSUCNodeId(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getSUCNodeId (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_16getSUCNodeId(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_16getSUCNodeId(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("getSUCNodeId", 0);

  /* "libopenzwave.pyx":1288
 * 
 *         '''
 *         return self.manager.GetSUCNodeId(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def isPrimaryController(self, homeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1288, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_From_uint8_t(__pyx_v_self->manager->GetSUCNodeId(__pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1288, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1276
 *         return self.manager.GetControllerNodeId(homeid)
 * 
 *     def getSUCNodeId(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getSUCNodeId:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.getSUCNodeId", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1290
 *         return self.manager.GetSUCNodeId(homeid)
 * 
 *     def isPrimaryController(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isPrimaryController:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_19isPrimaryController(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_18isPrimaryController[] = "\n.. _isPrimaryController:\n\nQuery if the controller is a primary controller.\n\nThe primary controller is the main device used to configure and control a\nZ-Wave network.  There can only be one primary controller - all other\ncontrollers are secondary controllers.\n\nThe only difference between a primary and secondary controller is that the\nprimary is the only one that can be used to add or remove other devices.  For\nthis reason, it is usually better for the promary controller to be portable,\nsince most devices must be added when installed in their final location.\n\nCalls to BeginControllerCommand will fail if the controller is not the primary.\n\n:param homeId: The Home ID of the Z-Wave controller.\n:type homeId: int\n:return: True if it is a primary controller, False if not.\n:rtype: bool\n:see: isBridgeController_, isStaticUpdateController_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_19isPrimaryController(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isPrimaryController (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_18isPrimaryController(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_18isPrimaryController(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("isPrimaryController", 0);

  /* "libopenzwave.pyx":1314
 * 
 *         '''
 *         return self.manager.IsPrimaryController(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def isStaticUpdateController(self, homeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1314, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsPrimaryController(__pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1314, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1290
 *         return self.manager.GetSUCNodeId(homeid)
 * 
 *     def isPrimaryController(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isPrimaryController:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.isPrimaryController", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1316
 *         return self.manager.IsPrimaryController(homeid)
 * 
 *     def isStaticUpdateController(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isStaticUpdateController:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_21isStaticUpdateController(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_20isStaticUpdateController[] = "\n.. _isStaticUpdateController:\n\nQuery if the controller is a static update controller (SUC).\n\nA Static Update Controller (SUC) is a controller that must never be moved in\nnormal operation and which can be used by other nodes to receive information\nabout network changes.\n\n:param homeId: The Home ID of the Z-Wave controller.\n:type homeId: int\n:return: True if it is a static update controller, False if not.\n:rtype: bool\n:see: isBridgeController_, isPrimaryController_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_21isStaticUpdateController(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isStaticUpdateController (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_20isStaticUpdateController(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_20isStaticUpdateController(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("isStaticUpdateController", 0);

  /* "libopenzwave.pyx":1333
 * 
 *         '''
 *         return self.manager.IsStaticUpdateController(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def isBridgeController(self, homeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1333, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsStaticUpdateController(__pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1333, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1316
 *         return self.manager.IsPrimaryController(homeid)
 * 
 *     def isStaticUpdateController(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isStaticUpdateController:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.isStaticUpdateController", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1335
 *         return self.manager.IsStaticUpdateController(homeid)
 * 
 *     def isBridgeController(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isBridgeController:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_23isBridgeController(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_22isBridgeController[] = "\n.. _isBridgeController:\n\nQuery if the controller is using the bridge controller library.\n\nA bridge controller is able to create virtual nodes that can be associated\nwith other controllers to enable events to be passed on.\n\n:param homeId: The Home ID of the Z-Wave controller.\n:type homeId: int\n:return: True if it is a bridge controller, False if not.\n:rtype: bool\n:see: isPrimaryController_, isStaticUpdateController_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_23isBridgeController(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isBridgeController (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_22isBridgeController(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_22isBridgeController(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("isBridgeController", 0);

  /* "libopenzwave.pyx":1351
 * 
 *         '''
 *         return self.manager.IsBridgeController(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def getLibraryVersion(self, homeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1351, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsBridgeController(__pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1351, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1335
 *         return self.manager.IsStaticUpdateController(homeid)
 * 
 *     def isBridgeController(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isBridgeController:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.isBridgeController", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1353
 *         return self.manager.IsBridgeController(homeid)
 * 
 *     def getLibraryVersion(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getLibraryVersion:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_25getLibraryVersion(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_24getLibraryVersion[] = "\n.. _getLibraryVersion:\n\nGet the version of the Z-Wave API library used by a controller.\n\n:param homeId: The Home ID of the Z-Wave controller.\n:type homeId: int\n:return: A string containing the library version. For example, \"Z-Wave 2.48\".\n:rtype: str\n:see: getPythonLibraryVersion_, getLibraryTypeName_, getOzwLibraryVersion_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_25getLibraryVersion(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getLibraryVersion (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_24getLibraryVersion(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_24getLibraryVersion(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getLibraryVersion", 0);

  /* "libopenzwave.pyx":1366
 * 
 *         '''
 *         cdef string c_string = self.manager.GetLibraryVersion(homeid)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1366, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetLibraryVersion(__pyx_t_1);

  /* "libopenzwave.pyx":1367
 *         '''
 *         cdef string c_string = self.manager.GetLibraryVersion(homeid)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getPythonLibraryVersion(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1367, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1367, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1353
 *         return self.manager.IsBridgeController(homeid)
 * 
 *     def getLibraryVersion(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getLibraryVersion:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getLibraryVersion", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1369
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getPythonLibraryVersion(self):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getPythonLibraryVersion:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_27getPythonLibraryVersion(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_26getPythonLibraryVersion[] = "\n.. _getPythonLibraryVersion:\n\nGet the version of the python library.\n\n:return: A string containing the python library version. For example, \"python-openzwave version 0.1\".\n:rtype: str\n:see: getLibraryTypeName_, getLibraryVersion_, getOzwLibraryVersion_, getOzwLibraryLongVersion\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_27getPythonLibraryVersion(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getPythonLibraryVersion (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_26getPythonLibraryVersion(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_26getPythonLibraryVersion(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannySetupContext("getPythonLibraryVersion", 0);

  /* "libopenzwave.pyx":1380
 * 
 *         '''
 *         return "python_openzwave version %s (%s-%s / %s - %s)" % (PYLIBRARY, PY_LIB_FLAVOR_STRING, PY_LIB_BACKEND_STRING, PY_LIB_DATE_STRING, PY_LIB_TIME_STRING)             # <<<<<<<<<<<<<<
 * 
 *     def getPythonLibraryVersionNumber(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PYLIBRARY); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1380, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_PyUnicode_string_to_py_std__in_string(PY_LIB_FLAVOR_STRING); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1380, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __pyx_convert_PyUnicode_string_to_py_std__in_string(PY_LIB_BACKEND_STRING); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1380, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_convert_PyUnicode_string_to_py_std__in_string(PY_LIB_DATE_STRING); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1380, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = __pyx_convert_PyUnicode_string_to_py_std__in_string(PY_LIB_TIME_STRING); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1380, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = PyTuple_New(5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1380, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_6, 2, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_6, 3, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_5);
  PyTuple_SET_ITEM(__pyx_t_6, 4, __pyx_t_5);
  __pyx_t_1 = 0;
  __pyx_t_2 = 0;
  __pyx_t_3 = 0;
  __pyx_t_4 = 0;
  __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_python_openzwave_version_s_s_s_s, __pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1380, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_r = __pyx_t_5;
  __pyx_t_5 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1369
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getPythonLibraryVersion(self):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getPythonLibraryVersion:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("libopenzwave.PyManager.getPythonLibraryVersion", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1382
 *         return "python_openzwave version %s (%s-%s / %s - %s)" % (PYLIBRARY, PY_LIB_FLAVOR_STRING, PY_LIB_BACKEND_STRING, PY_LIB_DATE_STRING, PY_LIB_TIME_STRING)
 * 
 *     def getPythonLibraryVersionNumber(self):             # <<<<<<<<<<<<<<
 *         """
 * .. _getPythonLibraryVersionNumber:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_29getPythonLibraryVersionNumber(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_28getPythonLibraryVersionNumber[] = "\n.. _getPythonLibraryVersionNumber:\n\nGet the python library version number\n\n:return: A string containing the python library version. For example, \"0.1\".\n:rtype: str\n:see: getLibraryTypeName_, getLibraryVersion_, getOzwLibraryVersion_, getOzwLibraryLongVersion\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_29getPythonLibraryVersionNumber(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getPythonLibraryVersionNumber (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_28getPythonLibraryVersionNumber(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_28getPythonLibraryVersionNumber(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("getPythonLibraryVersionNumber", 0);

  /* "libopenzwave.pyx":1393
 * 
 *         """
 *         return PYLIBRARY             # <<<<<<<<<<<<<<
 * 
 *     def getOzwLibraryVersion(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PYLIBRARY); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1393, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1382
 *         return "python_openzwave version %s (%s-%s / %s - %s)" % (PYLIBRARY, PY_LIB_FLAVOR_STRING, PY_LIB_BACKEND_STRING, PY_LIB_DATE_STRING, PY_LIB_TIME_STRING)
 * 
 *     def getPythonLibraryVersionNumber(self):             # <<<<<<<<<<<<<<
 *         """
 * .. _getPythonLibraryVersionNumber:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.getPythonLibraryVersionNumber", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1395
 *         return PYLIBRARY
 * 
 *     def getOzwLibraryVersion(self):             # <<<<<<<<<<<<<<
 *         """
 * .. _getOzwLibraryVersion:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_31getOzwLibraryVersion(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_30getOzwLibraryVersion[] = "\n.. _getOzwLibraryVersion:\n\nGet a string containing the openzwave library version.\n\n:return: A string containing the library type.\n:rtype: str\n:see: getLibraryVersion_, getPythonLibraryVersion_, getLibraryTypeName_, getOzwLibraryLongVersion_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_31getOzwLibraryVersion(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getOzwLibraryVersion (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_30getOzwLibraryVersion(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_30getOzwLibraryVersion(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("getOzwLibraryVersion", 0);

  /* "libopenzwave.pyx":1406
 * 
 *         """
 *         cdef string c_string = self.manager.getVersionAsString()             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_v_c_string = __pyx_v_self->manager->getVersionAsString();

  /* "libopenzwave.pyx":1407
 *         """
 *         cdef string c_string = self.manager.getVersionAsString()
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getOzwLibraryLongVersion(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1407, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1407, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1395
 *         return PYLIBRARY
 * 
 *     def getOzwLibraryVersion(self):             # <<<<<<<<<<<<<<
 *         """
 * .. _getOzwLibraryVersion:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.getOzwLibraryVersion", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1409
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getOzwLibraryLongVersion(self):             # <<<<<<<<<<<<<<
 *         """
 * .. _getOzwLibraryLongVersion:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_33getOzwLibraryLongVersion(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_32getOzwLibraryLongVersion[] = "\n.. _getOzwLibraryLongVersion:\n\nGet a string containing the openzwave library version.\n\n:return: A string containing the library type.\n:rtype: str\n:see: getLibraryVersion_, getPythonLibraryVersion_, getLibraryTypeName_, getOzwLibraryVersion_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_33getOzwLibraryLongVersion(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getOzwLibraryLongVersion (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_32getOzwLibraryLongVersion(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_32getOzwLibraryLongVersion(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("getOzwLibraryLongVersion", 0);

  /* "libopenzwave.pyx":1420
 * 
 *         """
 *         cdef string c_string = self.manager.getVersionLongAsString()             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_v_c_string = __pyx_v_self->manager->getVersionLongAsString();

  /* "libopenzwave.pyx":1421
 *         """
 *         cdef string c_string = self.manager.getVersionLongAsString()
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getOzwLibraryVersionNumber(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1421, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1421, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1409
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getOzwLibraryLongVersion(self):             # <<<<<<<<<<<<<<
 *         """
 * .. _getOzwLibraryLongVersion:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.getOzwLibraryLongVersion", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1423
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getOzwLibraryVersionNumber(self):             # <<<<<<<<<<<<<<
 *         '''
 * _getOzwLibraryVersionNumber: Get the openzwave library version number.
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_35getOzwLibraryVersionNumber(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_34getOzwLibraryVersionNumber[] = "\n_getOzwLibraryVersionNumber: Get the openzwave library version number.\n\n:return: A string containing the library type.\n:rtype: str\n:see: getLibraryVersion_, getPythonLibraryVersion_, getLibraryTypeName_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_35getOzwLibraryVersionNumber(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getOzwLibraryVersionNumber (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_34getOzwLibraryVersionNumber(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_34getOzwLibraryVersionNumber(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("getOzwLibraryVersionNumber", 0);

  /* "libopenzwave.pyx":1432
 * 
 *         '''
 *         cdef string c_string = self.manager.getVersionAsString()             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_v_c_string = __pyx_v_self->manager->getVersionAsString();

  /* "libopenzwave.pyx":1433
 *         '''
 *         cdef string c_string = self.manager.getVersionAsString()
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getLibraryTypeName(self, homeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1433, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1433, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1423
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getOzwLibraryVersionNumber(self):             # <<<<<<<<<<<<<<
 *         '''
 * _getOzwLibraryVersionNumber: Get the openzwave library version number.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.getOzwLibraryVersionNumber", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1435
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getLibraryTypeName(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getLibraryTypeName:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_37getLibraryTypeName(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_36getLibraryTypeName[] = "\n.. _getLibraryTypeName:\n\nGet a string containing the Z-Wave API library type used by a controller.\n\nThe possible library types are:\n\n    - Static Controller\n    - Controller\n    - Enhanced Slave\n    - Slave\n    - Installer\n    - Routing Slave\n    - Bridge Controller\n    - Device Under Test\n\nThe controller should never return a slave library type.  For a more efficient\ntest of whether a controller is a Bridge Controller, use the IsBridgeController\nmethod.\n\n:param homeId: The Home ID of the Z-Wave controller.\n:type homeId: int\n:return: A string containing the library type.\n:rtype: str\n:see: getLibraryVersion_, getPythonLibraryVersion_, getOzwLibraryVersion_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_37getLibraryTypeName(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getLibraryTypeName (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_36getLibraryTypeName(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_36getLibraryTypeName(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getLibraryTypeName", 0);

  /* "libopenzwave.pyx":1463
 * 
 *         '''
 *         cdef string c_string = self.manager.GetLibraryTypeName(homeid)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1463, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetLibraryTypeName(__pyx_t_1);

  /* "libopenzwave.pyx":1464
 *         '''
 *         cdef string c_string = self.manager.GetLibraryTypeName(homeid)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getSendQueueCount(self, homeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1464, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1464, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1435
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getLibraryTypeName(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getLibraryTypeName:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getLibraryTypeName", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1466
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getSendQueueCount(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getSendQueueCount:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_39getSendQueueCount(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_38getSendQueueCount[] = "\n.. _getSendQueueCount:\n\nGet count of messages in the outgoing send queue.\n\n:param homeId: The Home ID of the Z-Wave controller.\n:type homeId: int\n:return: Message count\n:rtype: int\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_39getSendQueueCount(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getSendQueueCount (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_38getSendQueueCount(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_38getSendQueueCount(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("getSendQueueCount", 0);

  /* "libopenzwave.pyx":1478
 * 
 *         '''
 *         return self.manager.GetSendQueueCount(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def logDriverStatistics(self, homeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1478, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_From_int32_t(__pyx_v_self->manager->GetSendQueueCount(__pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1478, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1466
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getSendQueueCount(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getSendQueueCount:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.getSendQueueCount", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1480
 *         return self.manager.GetSendQueueCount(homeid)
 * 
 *     def logDriverStatistics(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _logDriverStatistics:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_41logDriverStatistics(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_40logDriverStatistics[] = "\n.. _logDriverStatistics:\n\nSend current driver statistics to the log file.\n\n:param homeid: The Home ID of the Z-Wave controller.\n:type homeid: int\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_41logDriverStatistics(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("logDriverStatistics (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_40logDriverStatistics(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_40logDriverStatistics(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  __Pyx_RefNannySetupContext("logDriverStatistics", 0);

  /* "libopenzwave.pyx":1490
 * 
 *         '''
 *         self.manager.LogDriverStatistics(homeid)             # <<<<<<<<<<<<<<
 * 
 * #-----------------------------------------------------------------------------
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1490, __pyx_L1_error)
  __pyx_v_self->manager->LogDriverStatistics(__pyx_t_1);

  /* "libopenzwave.pyx":1480
 *         return self.manager.GetSendQueueCount(homeid)
 * 
 *     def logDriverStatistics(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _logDriverStatistics:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.logDriverStatistics", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1495
 * # Statistics interface
 * #-----------------------------------------------------------------------------
 *     def getDriverStatistics(self, homeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getDriverStatistics:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_43getDriverStatistics(PyObject *__pyx_v_self, PyObject *__pyx_v_homeId); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_42getDriverStatistics[] = "\n.. _getDriverStatistics:\n\nRetrieve statistics from driver.\n\nStatistics:\n\n    * SOFCnt : Number of SOF bytes received\n    * ACKWaiting : Number of unsolicited messages while waiting for an ACK\n    * readAborts : Number of times read were aborted due to timeouts\n    * badChecksum : Number of bad checksums\n    * readCnt : Number of messages successfully read\n    * writeCnt : Number of messages successfully sent\n    * CANCnt : Number of CAN bytes received\n    * NAKCnt : Number of NAK bytes received\n    * ACKCnt : Number of ACK bytes received\n    * OOFCnt : Number of bytes out of framing\n    * dropped : Number of messages dropped & not delivered\n    * retries : Number of messages retransmitted\n    * callbacks : Number of unexpected callbacks\n    * badroutes : Number of failed messages due to bad route response\n    * noack : Number of no ACK returned errors\n    * netbusy : Number of network busy/failure messages\n    * nondelivery : Number of messages not delivered to network\n    * routedbusy : Number of messages received with routed busy status\n    * broadcastReadCnt : Number of broadcasts read\n    * broadcastWriteCnt : Number of broadcasts sent\n\n:param homeId: The Home ID of the Z-Wave controller.\n:type homeId: int\n:param data: Pointer to structure DriverData to return values\n:type data: int\n:return: A dict containing statistics of the driver.\n:rtype: dict()\n:see: getNodeStatistics_\n\n       ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_43getDriverStatistics(PyObject *__pyx_v_self, PyObject *__pyx_v_homeId) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getDriverStatistics (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_42getDriverStatistics(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeId));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_42getDriverStatistics(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId) {
  __pyx_t_6driver_DriverData_t __pyx_v_data;
  PyObject *__pyx_v_ret = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("getDriverStatistics", 0);

  /* "libopenzwave.pyx":1534
 *        '''
 *         cdef DriverData_t data
 *         self.manager.GetDriverStatistics( homeId, &data );             # <<<<<<<<<<<<<<
 *         ret = {}
 *         ret['SOFCnt'] = data.m_SOFCnt
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeId); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1534, __pyx_L1_error)
  __pyx_v_self->manager->GetDriverStatistics(__pyx_t_1, (&__pyx_v_data));

  /* "libopenzwave.pyx":1535
 *         cdef DriverData_t data
 *         self.manager.GetDriverStatistics( homeId, &data );
 *         ret = {}             # <<<<<<<<<<<<<<
 *         ret['SOFCnt'] = data.m_SOFCnt
 *         ret['ACKWaiting'] = data.m_ACKWaiting
 */
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1535, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_v_ret = ((PyObject*)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1536
 *         self.manager.GetDriverStatistics( homeId, &data );
 *         ret = {}
 *         ret['SOFCnt'] = data.m_SOFCnt             # <<<<<<<<<<<<<<
 *         ret['ACKWaiting'] = data.m_ACKWaiting
 *         ret['readAborts'] = data.m_readAborts
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_SOFCnt); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1536, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_SOFCnt, __pyx_t_2) < 0)) __PYX_ERR(0, 1536, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1537
 *         ret = {}
 *         ret['SOFCnt'] = data.m_SOFCnt
 *         ret['ACKWaiting'] = data.m_ACKWaiting             # <<<<<<<<<<<<<<
 *         ret['readAborts'] = data.m_readAborts
 *         ret['badChecksum'] = data.m_badChecksum
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_ACKWaiting); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1537, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_ACKWaiting, __pyx_t_2) < 0)) __PYX_ERR(0, 1537, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1538
 *         ret['SOFCnt'] = data.m_SOFCnt
 *         ret['ACKWaiting'] = data.m_ACKWaiting
 *         ret['readAborts'] = data.m_readAborts             # <<<<<<<<<<<<<<
 *         ret['badChecksum'] = data.m_badChecksum
 *         ret['readCnt'] = data.m_readCnt
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_readAborts); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1538, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_readAborts, __pyx_t_2) < 0)) __PYX_ERR(0, 1538, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1539
 *         ret['ACKWaiting'] = data.m_ACKWaiting
 *         ret['readAborts'] = data.m_readAborts
 *         ret['badChecksum'] = data.m_badChecksum             # <<<<<<<<<<<<<<
 *         ret['readCnt'] = data.m_readCnt
 *         ret['writeCnt'] = data.m_writeCnt
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_badChecksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1539, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_badChecksum, __pyx_t_2) < 0)) __PYX_ERR(0, 1539, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1540
 *         ret['readAborts'] = data.m_readAborts
 *         ret['badChecksum'] = data.m_badChecksum
 *         ret['readCnt'] = data.m_readCnt             # <<<<<<<<<<<<<<
 *         ret['writeCnt'] = data.m_writeCnt
 *         ret['CANCnt'] = data.m_CANCnt
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_readCnt); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1540, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_readCnt, __pyx_t_2) < 0)) __PYX_ERR(0, 1540, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1541
 *         ret['badChecksum'] = data.m_badChecksum
 *         ret['readCnt'] = data.m_readCnt
 *         ret['writeCnt'] = data.m_writeCnt             # <<<<<<<<<<<<<<
 *         ret['CANCnt'] = data.m_CANCnt
 *         ret['NAKCnt'] = data.m_NAKCnt
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_writeCnt); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1541, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_writeCnt, __pyx_t_2) < 0)) __PYX_ERR(0, 1541, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1542
 *         ret['readCnt'] = data.m_readCnt
 *         ret['writeCnt'] = data.m_writeCnt
 *         ret['CANCnt'] = data.m_CANCnt             # <<<<<<<<<<<<<<
 *         ret['NAKCnt'] = data.m_NAKCnt
 *         ret['ACKCnt'] = data.m_ACKCnt
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_CANCnt); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1542, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_CANCnt, __pyx_t_2) < 0)) __PYX_ERR(0, 1542, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1543
 *         ret['writeCnt'] = data.m_writeCnt
 *         ret['CANCnt'] = data.m_CANCnt
 *         ret['NAKCnt'] = data.m_NAKCnt             # <<<<<<<<<<<<<<
 *         ret['ACKCnt'] = data.m_ACKCnt
 *         ret['OOFCnt'] = data.m_OOFCnt
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_NAKCnt); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1543, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_NAKCnt, __pyx_t_2) < 0)) __PYX_ERR(0, 1543, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1544
 *         ret['CANCnt'] = data.m_CANCnt
 *         ret['NAKCnt'] = data.m_NAKCnt
 *         ret['ACKCnt'] = data.m_ACKCnt             # <<<<<<<<<<<<<<
 *         ret['OOFCnt'] = data.m_OOFCnt
 *         ret['dropped'] = data.m_dropped
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_ACKCnt); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1544, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_ACKCnt, __pyx_t_2) < 0)) __PYX_ERR(0, 1544, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1545
 *         ret['NAKCnt'] = data.m_NAKCnt
 *         ret['ACKCnt'] = data.m_ACKCnt
 *         ret['OOFCnt'] = data.m_OOFCnt             # <<<<<<<<<<<<<<
 *         ret['dropped'] = data.m_dropped
 *         ret['retries'] = data.m_retries
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_OOFCnt); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1545, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_OOFCnt, __pyx_t_2) < 0)) __PYX_ERR(0, 1545, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1546
 *         ret['ACKCnt'] = data.m_ACKCnt
 *         ret['OOFCnt'] = data.m_OOFCnt
 *         ret['dropped'] = data.m_dropped             # <<<<<<<<<<<<<<
 *         ret['retries'] = data.m_retries
 *         ret['callbacks'] = data.m_callbacks
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_dropped); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1546, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_dropped, __pyx_t_2) < 0)) __PYX_ERR(0, 1546, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1547
 *         ret['OOFCnt'] = data.m_OOFCnt
 *         ret['dropped'] = data.m_dropped
 *         ret['retries'] = data.m_retries             # <<<<<<<<<<<<<<
 *         ret['callbacks'] = data.m_callbacks
 *         ret['badroutes'] = data.m_badroutes
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_retries); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1547, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_retries, __pyx_t_2) < 0)) __PYX_ERR(0, 1547, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1548
 *         ret['dropped'] = data.m_dropped
 *         ret['retries'] = data.m_retries
 *         ret['callbacks'] = data.m_callbacks             # <<<<<<<<<<<<<<
 *         ret['badroutes'] = data.m_badroutes
 *         ret['noack'] = data.m_noack
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_callbacks); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1548, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_callbacks, __pyx_t_2) < 0)) __PYX_ERR(0, 1548, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1549
 *         ret['retries'] = data.m_retries
 *         ret['callbacks'] = data.m_callbacks
 *         ret['badroutes'] = data.m_badroutes             # <<<<<<<<<<<<<<
 *         ret['noack'] = data.m_noack
 *         ret['netbusy'] = data.m_netbusy
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_badroutes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1549, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_badroutes, __pyx_t_2) < 0)) __PYX_ERR(0, 1549, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1550
 *         ret['callbacks'] = data.m_callbacks
 *         ret['badroutes'] = data.m_badroutes
 *         ret['noack'] = data.m_noack             # <<<<<<<<<<<<<<
 *         ret['netbusy'] = data.m_netbusy
 *         ret['nondelivery'] = data.m_nondelivery
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_noack); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1550, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_noack, __pyx_t_2) < 0)) __PYX_ERR(0, 1550, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1551
 *         ret['badroutes'] = data.m_badroutes
 *         ret['noack'] = data.m_noack
 *         ret['netbusy'] = data.m_netbusy             # <<<<<<<<<<<<<<
 *         ret['nondelivery'] = data.m_nondelivery
 *         ret['routedbusy'] = data.m_routedbusy
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_netbusy); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1551, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_netbusy, __pyx_t_2) < 0)) __PYX_ERR(0, 1551, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1552
 *         ret['noack'] = data.m_noack
 *         ret['netbusy'] = data.m_netbusy
 *         ret['nondelivery'] = data.m_nondelivery             # <<<<<<<<<<<<<<
 *         ret['routedbusy'] = data.m_routedbusy
 *         ret['broadcastReadCnt'] = data.m_broadcastReadCnt
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_nondelivery); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1552, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_nondelivery, __pyx_t_2) < 0)) __PYX_ERR(0, 1552, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1553
 *         ret['netbusy'] = data.m_netbusy
 *         ret['nondelivery'] = data.m_nondelivery
 *         ret['routedbusy'] = data.m_routedbusy             # <<<<<<<<<<<<<<
 *         ret['broadcastReadCnt'] = data.m_broadcastReadCnt
 *         ret['broadcastWriteCnt'] = data.m_broadcastWriteCnt
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_routedbusy); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1553, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_routedbusy, __pyx_t_2) < 0)) __PYX_ERR(0, 1553, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1554
 *         ret['nondelivery'] = data.m_nondelivery
 *         ret['routedbusy'] = data.m_routedbusy
 *         ret['broadcastReadCnt'] = data.m_broadcastReadCnt             # <<<<<<<<<<<<<<
 *         ret['broadcastWriteCnt'] = data.m_broadcastWriteCnt
 *         return ret
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_broadcastReadCnt); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1554, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_broadcastReadCnt, __pyx_t_2) < 0)) __PYX_ERR(0, 1554, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1555
 *         ret['routedbusy'] = data.m_routedbusy
 *         ret['broadcastReadCnt'] = data.m_broadcastReadCnt
 *         ret['broadcastWriteCnt'] = data.m_broadcastWriteCnt             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_broadcastWriteCnt); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1555, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_broadcastWriteCnt, __pyx_t_2) < 0)) __PYX_ERR(0, 1555, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":1556
 *         ret['broadcastReadCnt'] = data.m_broadcastReadCnt
 *         ret['broadcastWriteCnt'] = data.m_broadcastWriteCnt
 *         return ret             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1495
 * # Statistics interface
 * #-----------------------------------------------------------------------------
 *     def getDriverStatistics(self, homeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getDriverStatistics:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.getDriverStatistics", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_ret);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1567
 * 
 * 
 *     def testNetworkNode(self, homeid, nodeid, count):             # <<<<<<<<<<<<<<
 *         '''
 * .. _testNetworkNode:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_45testNetworkNode(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_44testNetworkNode[] = "\n.. _testNetworkNode:\n\nTest network node.\n\nSends a series of messages to a network node for testing network reliability.\n\n:param homeid: The Home ID of the Z-Wave controller that manages the node.\n:type homeid: int\n:param nodeid: The ID of the node to query.\n:type nodeid: int\n:param count: This is the number of test messages to send.\n:type count: int\n:see: testNetwork_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_45testNetworkNode(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_count = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("testNetworkNode (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_count,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("testNetworkNode", 1, 3, 3, 1); __PYX_ERR(0, 1567, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_count)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("testNetworkNode", 1, 3, 3, 2); __PYX_ERR(0, 1567, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "testNetworkNode") < 0)) __PYX_ERR(0, 1567, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_count = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("testNetworkNode", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1567, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.testNetworkNode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_44testNetworkNode(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_count);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_44testNetworkNode(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_count) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  uint32_t __pyx_t_3;
  __Pyx_RefNannySetupContext("testNetworkNode", 0);

  /* "libopenzwave.pyx":1584
 * 
 *         '''
 *         self.manager.TestNetworkNode(homeid, nodeid, count)             # <<<<<<<<<<<<<<
 * 
 *     def testNetwork(self, homeid, count):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1584, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1584, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_As_uint32_t(__pyx_v_count); if (unlikely((__pyx_t_3 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1584, __pyx_L1_error)
  __pyx_v_self->manager->TestNetworkNode(__pyx_t_1, __pyx_t_2, __pyx_t_3);

  /* "libopenzwave.pyx":1567
 * 
 * 
 *     def testNetworkNode(self, homeid, nodeid, count):             # <<<<<<<<<<<<<<
 *         '''
 * .. _testNetworkNode:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.testNetworkNode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1586
 *         self.manager.TestNetworkNode(homeid, nodeid, count)
 * 
 *     def testNetwork(self, homeid, count):             # <<<<<<<<<<<<<<
 *         '''
 * .. _testNetwork:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_47testNetwork(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_46testNetwork[] = "\n.. _testNetwork:\n\nTest network.\n\nSends a series of messages to every node on the network for testing network reliability.\n\n:param homeid: The Home ID of the Z-Wave controller that manages the node.\n:type homeid: int\n:param count: This is the number of test messages to send.\n:type count: int\n:see: testNetworkNode_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_47testNetwork(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_count = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("testNetwork (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_count,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_count)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("testNetwork", 1, 2, 2, 1); __PYX_ERR(0, 1586, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "testNetwork") < 0)) __PYX_ERR(0, 1586, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_count = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("testNetwork", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1586, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.testNetwork", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_46testNetwork(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_count);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_46testNetwork(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_count) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint32_t __pyx_t_2;
  __Pyx_RefNannySetupContext("testNetwork", 0);

  /* "libopenzwave.pyx":1601
 * 
 *         '''
 *         self.manager.TestNetwork(homeid, count)             # <<<<<<<<<<<<<<
 * 
 *     def healNetworkNode(self, homeid, nodeid,  upNodeRoute = False):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1601, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint32_t(__pyx_v_count); if (unlikely((__pyx_t_2 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1601, __pyx_L1_error)
  __pyx_v_self->manager->TestNetwork(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":1586
 *         self.manager.TestNetworkNode(homeid, nodeid, count)
 * 
 *     def testNetwork(self, homeid, count):             # <<<<<<<<<<<<<<
 *         '''
 * .. _testNetwork:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.testNetwork", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1603
 *         self.manager.TestNetwork(homeid, count)
 * 
 *     def healNetworkNode(self, homeid, nodeid,  upNodeRoute = False):             # <<<<<<<<<<<<<<
 *         '''
 * .. _healNetworkNode:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_49healNetworkNode(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_48healNetworkNode[] = "\n.. _healNetworkNode:\n\nHeal network node by requesting the node rediscover their neighbors.\nSends a ControllerCommand_RequestNodeNeighborUpdate to the node.\n\n:param homeid: The Home ID of the Z-Wave controller that manages the node.\n:type homeid: int\n:param nodeid: The ID of the node to query.\n:type nodeid: int\n:param upNodeRoute: Optional Whether to perform return routes initialization. (default = false).\n:type upNodeRoute: bool\n:see: healNetwork_\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_49healNetworkNode(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_upNodeRoute = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("healNetworkNode (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_upNodeRoute,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("healNetworkNode", 0, 2, 3, 1); __PYX_ERR(0, 1603, __pyx_L3_error)
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_upNodeRoute);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "healNetworkNode") < 0)) __PYX_ERR(0, 1603, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_upNodeRoute = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("healNetworkNode", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1603, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.healNetworkNode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_48healNetworkNode(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_upNodeRoute);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_48healNetworkNode(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_upNodeRoute) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint32_t __pyx_t_2;
  bool __pyx_t_3;
  __Pyx_RefNannySetupContext("healNetworkNode", 0);

  /* "libopenzwave.pyx":1618
 * :see: healNetwork_
 *         '''
 *         self.manager.HealNetworkNode(homeid, nodeid,  upNodeRoute)             # <<<<<<<<<<<<<<
 * 
 *     def healNetwork(self, homeid, upNodeRoute = False):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1618, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint32_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1618, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_upNodeRoute); if (unlikely((__pyx_t_3 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1618, __pyx_L1_error)
  __pyx_v_self->manager->HealNetworkNode(__pyx_t_1, __pyx_t_2, __pyx_t_3);

  /* "libopenzwave.pyx":1603
 *         self.manager.TestNetwork(homeid, count)
 * 
 *     def healNetworkNode(self, homeid, nodeid,  upNodeRoute = False):             # <<<<<<<<<<<<<<
 *         '''
 * .. _healNetworkNode:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.healNetworkNode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1620
 *         self.manager.HealNetworkNode(homeid, nodeid,  upNodeRoute)
 * 
 *     def healNetwork(self, homeid, upNodeRoute = False):             # <<<<<<<<<<<<<<
 *         '''
 * .. _healNetwork:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_51healNetwork(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_50healNetwork[] = "\n.. _healNetwork:\n\nHeal network by requesting nodes rediscover their neighbors.\nSends a ControllerCommand_RequestNodeNeighborUpdate to every node.\nCan take a while on larger networks.\n\n:param homeid: The Home ID of the Z-Wave controller that manages the node.\n:type homeid: int\n:param upNodeRoute: Optional Whether to perform return routes initialization. (default = false).\n:type upNodeRoute: bool\n:see: healNetworkNode_\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_51healNetwork(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_upNodeRoute = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("healNetwork (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_upNodeRoute,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_upNodeRoute);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "healNetwork") < 0)) __PYX_ERR(0, 1620, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_homeid = values[0];
    __pyx_v_upNodeRoute = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("healNetwork", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1620, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.healNetwork", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_50healNetwork(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_upNodeRoute);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_50healNetwork(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_upNodeRoute) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  bool __pyx_t_2;
  __Pyx_RefNannySetupContext("healNetwork", 0);

  /* "libopenzwave.pyx":1634
 * :see: healNetworkNode_
 *         '''
 *         self.manager.HealNetwork(homeid, upNodeRoute)             # <<<<<<<<<<<<<<
 * 
 * # -----------------------------------------------------------------------------
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1634, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_upNodeRoute); if (unlikely((__pyx_t_2 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1634, __pyx_L1_error)
  __pyx_v_self->manager->HealNetwork(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":1620
 *         self.manager.HealNetworkNode(homeid, nodeid,  upNodeRoute)
 * 
 *     def healNetwork(self, homeid, upNodeRoute = False):             # <<<<<<<<<<<<<<
 *         '''
 * .. _healNetwork:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.healNetwork", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1643
 * # detect status changes.
 * #
 *     def getPollInterval(self):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getPollInterval:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_53getPollInterval(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_52getPollInterval[] = "\n.. _getPollInterval:\n\nGet the time period between polls of a nodes state\n\n:return: The number of milliseconds between polls\n:rtype: int\n:see: setPollInterval_, enablePoll_, isPolled_, setPollIntensity_, disablePoll_, getPollIntensity_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_53getPollInterval(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getPollInterval (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_52getPollInterval(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_52getPollInterval(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("getPollInterval", 0);

  /* "libopenzwave.pyx":1654
 * 
 *         '''
 *         return self.manager.GetPollInterval()             # <<<<<<<<<<<<<<
 * 
 *     def setPollInterval(self, milliseconds, bIntervalBetweenPolls ):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(__pyx_v_self->manager->GetPollInterval()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1654, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1643
 * # detect status changes.
 * #
 *     def getPollInterval(self):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getPollInterval:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.getPollInterval", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1656
 *         return self.manager.GetPollInterval()
 * 
 *     def setPollInterval(self, milliseconds, bIntervalBetweenPolls ):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setPollInterval:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_55setPollInterval(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_54setPollInterval[] = "\n.. _setPollInterval:\n\nSet the time period between polls of a nodes state.\n\nDue to patent concerns, some devices do not report state changes automatically\nto the controller.  These devices need to have their state polled at regular\nintervals.  The length of the interval is the same for all devices.  To even\nout the Z-Wave network traffic generated by polling, OpenZWave divides the\npolling interval by the number of devices that have polling enabled, and polls\neach in turn.  It is recommended that if possible, the interval should not be\nset shorter than the number of polled devices in seconds (so that the network\ndoes not have to cope with more than one poll per second).\n\n:param milliseconds: The length of the polling interval in milliseconds.\n:type milliseconds: int\n:param bIntervalBetweenPolls: If set to true (via SetPollInterval), the pollInterval will be interspersed between each poll (so a much smaller m_pollInterval like 100, 500, or 1,000 may be appropriate). If false, the library attempts to complete all polls within m_pollInterval\n:type bIntervalBetweenPolls: bool\n:see: getPollInterval_, enablePoll_, isPolled_, setPollIntensity_, disablePoll_, getPollIntensity_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_55setPollInterval(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_milliseconds = 0;
  PyObject *__pyx_v_bIntervalBetweenPolls = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setPollInterval (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_milliseconds,&__pyx_n_s_bIntervalBetweenPolls,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_milliseconds)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_bIntervalBetweenPolls)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setPollInterval", 1, 2, 2, 1); __PYX_ERR(0, 1656, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setPollInterval") < 0)) __PYX_ERR(0, 1656, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_milliseconds = values[0];
    __pyx_v_bIntervalBetweenPolls = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setPollInterval", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1656, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setPollInterval", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_54setPollInterval(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_milliseconds, __pyx_v_bIntervalBetweenPolls);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_54setPollInterval(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_milliseconds, PyObject *__pyx_v_bIntervalBetweenPolls) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  __Pyx_RefNannySetupContext("setPollInterval", 0);

  /* "libopenzwave.pyx":1678
 * 
 *         '''
 *         self.manager.SetPollInterval(milliseconds, bIntervalBetweenPolls)             # <<<<<<<<<<<<<<
 * 
 *     def enablePoll(self, id, intensity = 1):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_milliseconds); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1678, __pyx_L1_error)
  __pyx_v_self->manager->SetPollInterval(__pyx_t_1, __pyx_v_bIntervalBetweenPolls);

  /* "libopenzwave.pyx":1656
 *         return self.manager.GetPollInterval()
 * 
 *     def setPollInterval(self, milliseconds, bIntervalBetweenPolls ):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setPollInterval:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setPollInterval", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1680
 *         self.manager.SetPollInterval(milliseconds, bIntervalBetweenPolls)
 * 
 *     def enablePoll(self, id, intensity = 1):             # <<<<<<<<<<<<<<
 *         '''
 * .. _enablePoll:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_57enablePoll(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_56enablePoll[] = "\n.. _enablePoll:\n\nEnable the polling of a device's state.\n\n:param id: The ID of the value to start polling\n:type id: int\n:param intensity: The intensity of the poll\n:type intensity: int\n:return: True if polling was enabled.\n:rtype: bool\n:see: getPollInterval_, setPollInterval_, isPolled_, setPollIntensity_, disablePoll_, getPollIntensity_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_57enablePoll(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_id = 0;
  PyObject *__pyx_v_intensity = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("enablePoll (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_intensity,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_intensity);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "enablePoll") < 0)) __PYX_ERR(0, 1680, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_id = values[0];
    __pyx_v_intensity = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("enablePoll", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1680, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.enablePoll", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_56enablePoll(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_id, __pyx_v_intensity);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_56enablePoll(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_intensity) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  uint8_t __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("enablePoll", 0);

  /* "libopenzwave.pyx":1695
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.EnablePoll(values_map.at(id), intensity)
 *         else :
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1695, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":1696
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.EnablePoll(values_map.at(id), intensity)             # <<<<<<<<<<<<<<
 *         else :
 *             return False
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1696, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 1696, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyInt_As_uint8_t(__pyx_v_intensity); if (unlikely((__pyx_t_4 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1696, __pyx_L1_error)
    __pyx_t_5 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->EnablePoll(__pyx_t_3, __pyx_t_4)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1696, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_r = __pyx_t_5;
    __pyx_t_5 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":1695
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.EnablePoll(values_map.at(id), intensity)
 *         else :
 */
  }

  /* "libopenzwave.pyx":1698
 *             return self.manager.EnablePoll(values_map.at(id), intensity)
 *         else :
 *             return False             # <<<<<<<<<<<<<<
 * 
 *     def disablePoll(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":1680
 *         self.manager.SetPollInterval(milliseconds, bIntervalBetweenPolls)
 * 
 *     def enablePoll(self, id, intensity = 1):             # <<<<<<<<<<<<<<
 *         '''
 * .. _enablePoll:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("libopenzwave.PyManager.enablePoll", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1700
 *             return False
 * 
 *     def disablePoll(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _disablePoll:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_59disablePoll(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_58disablePoll[] = "\n.. _disablePoll:\n\nDisable polling of a value.\n\n:param id: The ID of the value to disable polling.\n:type id: int\n:return: True if polling was disabled.\n:rtype: bool\n:see: getPollInterval_, setPollInterval_, enablePoll_, isPolled_, setPollIntensity_, getPollIntensity_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_59disablePoll(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("disablePoll (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_58disablePoll(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_58disablePoll(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("disablePoll", 0);

  /* "libopenzwave.pyx":1713
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.DisablePoll(values_map.at(id))
 *         else :
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1713, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":1714
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.DisablePoll(values_map.at(id))             # <<<<<<<<<<<<<<
 *         else :
 *             return False
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1714, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 1714, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->DisablePoll(__pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1714, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":1713
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.DisablePoll(values_map.at(id))
 *         else :
 */
  }

  /* "libopenzwave.pyx":1716
 *             return self.manager.DisablePoll(values_map.at(id))
 *         else :
 *             return False             # <<<<<<<<<<<<<<
 * 
 *     def isPolled(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":1700
 *             return False
 * 
 *     def disablePoll(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _disablePoll:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.disablePoll", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1718
 *             return False
 * 
 *     def isPolled(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isPolled:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_61isPolled(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_60isPolled[] = "\n.. _isPolled:\n\nCheck polling status of a value\n\n:param id: The ID of the value to check polling.\n:type id: int\n:return: True if polling is active.\n:rtype: bool\n:see: getPollInterval_, setPollInterval_, enablePoll_, setPollIntensity_, disablePoll_, getPollIntensity_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_61isPolled(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isPolled (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_60isPolled(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_60isPolled(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("isPolled", 0);

  /* "libopenzwave.pyx":1731
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.isPolled(values_map.at(id))
 *         else :
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1731, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":1732
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.isPolled(values_map.at(id))             # <<<<<<<<<<<<<<
 *         else :
 *             return False
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1732, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 1732, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->isPolled(__pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1732, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":1731
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.isPolled(values_map.at(id))
 *         else :
 */
  }

  /* "libopenzwave.pyx":1734
 *             return self.manager.isPolled(values_map.at(id))
 *         else :
 *             return False             # <<<<<<<<<<<<<<
 * 
 *     def getPollIntensity(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":1718
 *             return False
 * 
 *     def isPolled(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isPolled:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.isPolled", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1736
 *             return False
 * 
 *     def getPollIntensity(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getPollIntensity:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_63getPollIntensity(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_62getPollIntensity[] = "\n.. _getPollIntensity:\n\nGet the intensity with which this value is polled (0=none, 1=every time through the list, 2-every other time, etc).\n:param id: The ID of a value.\n:type id: int\n:return: A integer containing the poll intensity\n:rtype: int\n:see: getPollInterval_, setPollInterval_, enablePoll_, setPollIntensity_, disablePoll_, isPolled_\n\n       ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_63getPollIntensity(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getPollIntensity (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_62getPollIntensity(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_62getPollIntensity(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  uint8_t __pyx_v_intensity;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getPollIntensity", 0);

  /* "libopenzwave.pyx":1748
 * 
 *        '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             intensity = self.manager.GetPollIntensity(values_map.at(id))
 *             return intensity
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1748, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":1749
 *        '''
 *         if values_map.find(id) != values_map.end():
 *             intensity = self.manager.GetPollIntensity(values_map.at(id))             # <<<<<<<<<<<<<<
 *             return intensity
 *         else :
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1749, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 1749, __pyx_L1_error)
    }
    __pyx_v_intensity = __pyx_v_self->manager->GetPollIntensity(__pyx_t_3);

    /* "libopenzwave.pyx":1750
 *         if values_map.find(id) != values_map.end():
 *             intensity = self.manager.GetPollIntensity(values_map.at(id))
 *             return intensity             # <<<<<<<<<<<<<<
 *         else :
 *             return 0
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyInt_From_uint8_t(__pyx_v_intensity); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1750, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":1748
 * 
 *        '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             intensity = self.manager.GetPollIntensity(values_map.at(id))
 *             return intensity
 */
  }

  /* "libopenzwave.pyx":1752
 *             return intensity
 *         else :
 *             return 0             # <<<<<<<<<<<<<<
 * 
 *     def setPollIntensity(self, id, intensity):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_0);
    __pyx_r = __pyx_int_0;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":1736
 *             return False
 * 
 *     def getPollIntensity(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getPollIntensity:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getPollIntensity", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1754
 *             return 0
 * 
 *     def setPollIntensity(self, id, intensity):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setPollIntensity:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_65setPollIntensity(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_64setPollIntensity[] = "\n.. _setPollIntensity:\n\nSet the frequency of polling (0=none, 1=every time through the set, 2-every other time, etc)\n\n:param id: The ID of the value whose intensity should be set\n:type id: int\n:param intensity: the intensity of the poll\n:type intensity: int\n:see: getPollInterval_, setPollInterval_, enablePoll_, isPolled_, disablePoll_, getPollIntensity_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_65setPollIntensity(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_id = 0;
  PyObject *__pyx_v_intensity = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setPollIntensity (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_intensity,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_intensity)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setPollIntensity", 1, 2, 2, 1); __PYX_ERR(0, 1754, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setPollIntensity") < 0)) __PYX_ERR(0, 1754, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_id = values[0];
    __pyx_v_intensity = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setPollIntensity", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1754, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setPollIntensity", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_64setPollIntensity(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_id, __pyx_v_intensity);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_64setPollIntensity(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_intensity) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  uint8_t __pyx_t_4;
  __Pyx_RefNannySetupContext("setPollIntensity", 0);

  /* "libopenzwave.pyx":1767
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             self.manager.SetPollIntensity(values_map.at(id), intensity)
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1767, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":1768
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             self.manager.SetPollIntensity(values_map.at(id), intensity)             # <<<<<<<<<<<<<<
 * 
 * #
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1768, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 1768, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyInt_As_uint8_t(__pyx_v_intensity); if (unlikely((__pyx_t_4 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1768, __pyx_L1_error)
    __pyx_v_self->manager->SetPollIntensity(__pyx_t_3, __pyx_t_4);

    /* "libopenzwave.pyx":1767
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             self.manager.SetPollIntensity(values_map.at(id), intensity)
 * 
 */
  }

  /* "libopenzwave.pyx":1754
 *             return 0
 * 
 *     def setPollIntensity(self, id, intensity):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setPollIntensity:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setPollIntensity", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1777
 * #
 * 
 *     def getNodeStatistics(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeStatistics:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_67getNodeStatistics(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_66getNodeStatistics[] = "\n.. _getNodeStatistics:\n\nRetrieve statistics per node\n\nStatistics:\n\n    cdef struct NodeData:\n        * sentCnt                              # Number of messages sent from this node.\n        * sentFailed                           # Number of sent messages failed\n        * retries                                # Number of message retries\n        * receivedCnt                        # Number of messages received from this node.\n        * receivedDups                      # Number of duplicated messages received;\n        * receivedUnsolicited             # Number of messages received unsolicited\n        * sentTS                                # Last message sent time\n        * receivedTS                          # Last message received time\n        * lastRequestRTT                    # Last message request RTT\n        * averageRequestRTT             # Average Request Round Trip Time (ms).\n        * lastResponseRTT                  # Last message response RTT\n        * averageResponseRTT           #Average Reponse round trip time.\n        * quality                                # Node quality measure\n        * lastReceivedMessage[254]   # Place to hold last received message\n        * ccData                                # List of statistic\n              * commandClassId               # Num of commandClass id.\n              * sentCnt                             # Number of messages sent from this CommandClass.\n              * receivedCnt                       # Number of messages received from this CommandClass.\n\n:param homeId: The Home ID of the Z-Wave controller.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:param data: Pointer to structure NodeData to return values\n:type data: int\n:return: A dict containing statistics of the node.\n:rtype: dict()\n:see: getDriverStatistics_\n\n       ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_67getNodeStatistics(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeId = 0;
  PyObject *__pyx_v_nodeId = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeStatistics (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeId,&__pyx_n_s_nodeId,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeId)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeId)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeStatistics", 1, 2, 2, 1); __PYX_ERR(0, 1777, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeStatistics") < 0)) __PYX_ERR(0, 1777, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeId = values[0];
    __pyx_v_nodeId = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeStatistics", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1777, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeStatistics", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_66getNodeStatistics(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeId, __pyx_v_nodeId);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_66getNodeStatistics(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId) {
  __pyx_t_4node_NodeData_t __pyx_v_data;
  PyObject *__pyx_v_ret = NULL;
  long __pyx_v_i;
  PyObject *__pyx_v_listccdata = NULL;
  PyObject *__pyx_v_ccd = NULL;
  struct OpenZWave::Node::CommandClassData __pyx_v_temp;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  long __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  __Pyx_RefNannySetupContext("getNodeStatistics", 0);

  /* "libopenzwave.pyx":1818
 * 
 *         cdef NodeData_t data
 *         self.manager.GetNodeStatistics( homeId, nodeId, &data );             # <<<<<<<<<<<<<<
 *         ret = {}
 *         ret['sentCnt'] = data.m_sentCnt
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeId); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1818, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeId); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1818, __pyx_L1_error)
  __pyx_v_self->manager->GetNodeStatistics(__pyx_t_1, __pyx_t_2, (&__pyx_v_data));

  /* "libopenzwave.pyx":1819
 *         cdef NodeData_t data
 *         self.manager.GetNodeStatistics( homeId, nodeId, &data );
 *         ret = {}             # <<<<<<<<<<<<<<
 *         ret['sentCnt'] = data.m_sentCnt
 *         ret['sentFailed'] = data.m_sentFailed
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1819, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_v_ret = ((PyObject*)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1820
 *         self.manager.GetNodeStatistics( homeId, nodeId, &data );
 *         ret = {}
 *         ret['sentCnt'] = data.m_sentCnt             # <<<<<<<<<<<<<<
 *         ret['sentFailed'] = data.m_sentFailed
 *         ret['retries'] = data.m_retries
 */
  __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_sentCnt); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1820, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_sentCnt, __pyx_t_3) < 0)) __PYX_ERR(0, 1820, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1821
 *         ret = {}
 *         ret['sentCnt'] = data.m_sentCnt
 *         ret['sentFailed'] = data.m_sentFailed             # <<<<<<<<<<<<<<
 *         ret['retries'] = data.m_retries
 *         ret['receivedCnt'] = data.m_receivedCnt
 */
  __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_sentFailed); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1821, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_sentFailed, __pyx_t_3) < 0)) __PYX_ERR(0, 1821, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1822
 *         ret['sentCnt'] = data.m_sentCnt
 *         ret['sentFailed'] = data.m_sentFailed
 *         ret['retries'] = data.m_retries             # <<<<<<<<<<<<<<
 *         ret['receivedCnt'] = data.m_receivedCnt
 *         ret['receivedDups'] = data.m_receivedDups
 */
  __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_retries); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1822, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_retries, __pyx_t_3) < 0)) __PYX_ERR(0, 1822, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1823
 *         ret['sentFailed'] = data.m_sentFailed
 *         ret['retries'] = data.m_retries
 *         ret['receivedCnt'] = data.m_receivedCnt             # <<<<<<<<<<<<<<
 *         ret['receivedDups'] = data.m_receivedDups
 *         ret['receivedUnsolicited'] = data.m_receivedUnsolicited
 */
  __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_receivedCnt); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1823, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_receivedCnt, __pyx_t_3) < 0)) __PYX_ERR(0, 1823, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1824
 *         ret['retries'] = data.m_retries
 *         ret['receivedCnt'] = data.m_receivedCnt
 *         ret['receivedDups'] = data.m_receivedDups             # <<<<<<<<<<<<<<
 *         ret['receivedUnsolicited'] = data.m_receivedUnsolicited
 *         ret['sentTS'] = data.m_sentTS.c_str()
 */
  __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_receivedDups); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1824, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_receivedDups, __pyx_t_3) < 0)) __PYX_ERR(0, 1824, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1825
 *         ret['receivedCnt'] = data.m_receivedCnt
 *         ret['receivedDups'] = data.m_receivedDups
 *         ret['receivedUnsolicited'] = data.m_receivedUnsolicited             # <<<<<<<<<<<<<<
 *         ret['sentTS'] = data.m_sentTS.c_str()
 *         ret['receivedTS'] = data.m_receivedTS.c_str()
 */
  __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_receivedUnsolicited); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1825, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_receivedUnsolicited, __pyx_t_3) < 0)) __PYX_ERR(0, 1825, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1826
 *         ret['receivedDups'] = data.m_receivedDups
 *         ret['receivedUnsolicited'] = data.m_receivedUnsolicited
 *         ret['sentTS'] = data.m_sentTS.c_str()             # <<<<<<<<<<<<<<
 *         ret['receivedTS'] = data.m_receivedTS.c_str()
 *         ret['lastRequestRTT'] = data.m_lastRequestRTT
 */
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_data.m_sentTS.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1826, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_sentTS, __pyx_t_3) < 0)) __PYX_ERR(0, 1826, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1827
 *         ret['receivedUnsolicited'] = data.m_receivedUnsolicited
 *         ret['sentTS'] = data.m_sentTS.c_str()
 *         ret['receivedTS'] = data.m_receivedTS.c_str()             # <<<<<<<<<<<<<<
 *         ret['lastRequestRTT'] = data.m_lastRequestRTT
 *         ret['averageRequestRTT'] = data.m_averageRequestRTT
 */
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_data.m_receivedTS.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1827, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_receivedTS, __pyx_t_3) < 0)) __PYX_ERR(0, 1827, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1828
 *         ret['sentTS'] = data.m_sentTS.c_str()
 *         ret['receivedTS'] = data.m_receivedTS.c_str()
 *         ret['lastRequestRTT'] = data.m_lastRequestRTT             # <<<<<<<<<<<<<<
 *         ret['averageRequestRTT'] = data.m_averageRequestRTT
 *         ret['lastResponseRTT'] = data.m_lastResponseRTT
 */
  __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_lastRequestRTT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1828, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_lastRequestRTT, __pyx_t_3) < 0)) __PYX_ERR(0, 1828, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1829
 *         ret['receivedTS'] = data.m_receivedTS.c_str()
 *         ret['lastRequestRTT'] = data.m_lastRequestRTT
 *         ret['averageRequestRTT'] = data.m_averageRequestRTT             # <<<<<<<<<<<<<<
 *         ret['lastResponseRTT'] = data.m_lastResponseRTT
 *         ret['averageResponseRTT'] = data.m_averageResponseRTT
 */
  __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_averageRequestRTT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1829, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_averageRequestRTT, __pyx_t_3) < 0)) __PYX_ERR(0, 1829, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1830
 *         ret['lastRequestRTT'] = data.m_lastRequestRTT
 *         ret['averageRequestRTT'] = data.m_averageRequestRTT
 *         ret['lastResponseRTT'] = data.m_lastResponseRTT             # <<<<<<<<<<<<<<
 *         ret['averageResponseRTT'] = data.m_averageResponseRTT
 *         ret['quality'] = data.m_quality
 */
  __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_lastResponseRTT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1830, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_lastResponseRTT, __pyx_t_3) < 0)) __PYX_ERR(0, 1830, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1831
 *         ret['averageRequestRTT'] = data.m_averageRequestRTT
 *         ret['lastResponseRTT'] = data.m_lastResponseRTT
 *         ret['averageResponseRTT'] = data.m_averageResponseRTT             # <<<<<<<<<<<<<<
 *         ret['quality'] = data.m_quality
 *         ret['lastReceivedMessage'] = []
 */
  __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_data.m_averageResponseRTT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1831, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_averageResponseRTT, __pyx_t_3) < 0)) __PYX_ERR(0, 1831, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1832
 *         ret['lastResponseRTT'] = data.m_lastResponseRTT
 *         ret['averageResponseRTT'] = data.m_averageResponseRTT
 *         ret['quality'] = data.m_quality             # <<<<<<<<<<<<<<
 *         ret['lastReceivedMessage'] = []
 *         for i in range( 0, 254) :
 */
  __pyx_t_3 = __Pyx_PyInt_From_uint8_t(__pyx_v_data.m_quality); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1832, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_quality, __pyx_t_3) < 0)) __PYX_ERR(0, 1832, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1833
 *         ret['averageResponseRTT'] = data.m_averageResponseRTT
 *         ret['quality'] = data.m_quality
 *         ret['lastReceivedMessage'] = []             # <<<<<<<<<<<<<<
 *         for i in range( 0, 254) :
 *             ret['lastReceivedMessage'] .append(data.m_lastReceivedMessage[i])
 */
  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1833, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_lastReceivedMessage, __pyx_t_3) < 0)) __PYX_ERR(0, 1833, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "libopenzwave.pyx":1834
 *         ret['quality'] = data.m_quality
 *         ret['lastReceivedMessage'] = []
 *         for i in range( 0, 254) :             # <<<<<<<<<<<<<<
 *             ret['lastReceivedMessage'] .append(data.m_lastReceivedMessage[i])
 *         listccdata =[]
 */
  for (__pyx_t_4 = 0; __pyx_t_4 < 0xFE; __pyx_t_4+=1) {
    __pyx_v_i = __pyx_t_4;

    /* "libopenzwave.pyx":1835
 *         ret['lastReceivedMessage'] = []
 *         for i in range( 0, 254) :
 *             ret['lastReceivedMessage'] .append(data.m_lastReceivedMessage[i])             # <<<<<<<<<<<<<<
 *         listccdata =[]
 *         while not data.m_ccData.empty() :
 */
    __pyx_t_3 = __Pyx_PyDict_GetItem(__pyx_v_ret, __pyx_n_s_lastReceivedMessage); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1835, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = __Pyx_PyInt_From_uint8_t((__pyx_v_data.m_lastReceivedMessage[__pyx_v_i])); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1835, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = __Pyx_PyObject_Append(__pyx_t_3, __pyx_t_5); if (unlikely(__pyx_t_6 == -1)) __PYX_ERR(0, 1835, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }

  /* "libopenzwave.pyx":1836
 *         for i in range( 0, 254) :
 *             ret['lastReceivedMessage'] .append(data.m_lastReceivedMessage[i])
 *         listccdata =[]             # <<<<<<<<<<<<<<
 *         while not data.m_ccData.empty() :
 *             ccd = {}
 */
  __pyx_t_5 = PyList_New(0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1836, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_v_listccdata = ((PyObject*)__pyx_t_5);
  __pyx_t_5 = 0;

  /* "libopenzwave.pyx":1837
 *             ret['lastReceivedMessage'] .append(data.m_lastReceivedMessage[i])
 *         listccdata =[]
 *         while not data.m_ccData.empty() :             # <<<<<<<<<<<<<<
 *             ccd = {}
 *             temp = data.m_ccData.back()
 */
  while (1) {
    __pyx_t_7 = ((!(__pyx_v_data.m_ccData.empty() != 0)) != 0);
    if (!__pyx_t_7) break;

    /* "libopenzwave.pyx":1838
 *         listccdata =[]
 *         while not data.m_ccData.empty() :
 *             ccd = {}             # <<<<<<<<<<<<<<
 *             temp = data.m_ccData.back()
 *             ccd['commandClassId'] = temp.m_commandClassId
 */
    __pyx_t_5 = PyDict_New(); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1838, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_XDECREF_SET(__pyx_v_ccd, ((PyObject*)__pyx_t_5));
    __pyx_t_5 = 0;

    /* "libopenzwave.pyx":1839
 *         while not data.m_ccData.empty() :
 *             ccd = {}
 *             temp = data.m_ccData.back()             # <<<<<<<<<<<<<<
 *             ccd['commandClassId'] = temp.m_commandClassId
 *             ccd['sentCnt'] = temp.m_sentCnt
 */
    __pyx_v_temp = __pyx_v_data.m_ccData.back();

    /* "libopenzwave.pyx":1840
 *             ccd = {}
 *             temp = data.m_ccData.back()
 *             ccd['commandClassId'] = temp.m_commandClassId             # <<<<<<<<<<<<<<
 *             ccd['sentCnt'] = temp.m_sentCnt
 *             ccd['receivedCnt']  = temp.m_receivedCnt
 */
    __pyx_t_5 = __Pyx_PyInt_From_uint8_t(__pyx_v_temp.m_commandClassId); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1840, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (unlikely(PyDict_SetItem(__pyx_v_ccd, __pyx_n_s_commandClassId, __pyx_t_5) < 0)) __PYX_ERR(0, 1840, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "libopenzwave.pyx":1841
 *             temp = data.m_ccData.back()
 *             ccd['commandClassId'] = temp.m_commandClassId
 *             ccd['sentCnt'] = temp.m_sentCnt             # <<<<<<<<<<<<<<
 *             ccd['receivedCnt']  = temp.m_receivedCnt
 *             listccdata.append(ccd)
 */
    __pyx_t_5 = __Pyx_PyInt_From_uint32_t(__pyx_v_temp.m_sentCnt); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1841, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (unlikely(PyDict_SetItem(__pyx_v_ccd, __pyx_n_s_sentCnt, __pyx_t_5) < 0)) __PYX_ERR(0, 1841, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "libopenzwave.pyx":1842
 *             ccd['commandClassId'] = temp.m_commandClassId
 *             ccd['sentCnt'] = temp.m_sentCnt
 *             ccd['receivedCnt']  = temp.m_receivedCnt             # <<<<<<<<<<<<<<
 *             listccdata.append(ccd)
 *             data.m_ccData.pop_back();
 */
    __pyx_t_5 = __Pyx_PyInt_From_uint32_t(__pyx_v_temp.m_receivedCnt); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1842, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (unlikely(PyDict_SetItem(__pyx_v_ccd, __pyx_n_s_receivedCnt, __pyx_t_5) < 0)) __PYX_ERR(0, 1842, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "libopenzwave.pyx":1843
 *             ccd['sentCnt'] = temp.m_sentCnt
 *             ccd['receivedCnt']  = temp.m_receivedCnt
 *             listccdata.append(ccd)             # <<<<<<<<<<<<<<
 *             data.m_ccData.pop_back();
 *         ret['ccData'] = listccdata
 */
    __pyx_t_6 = __Pyx_PyList_Append(__pyx_v_listccdata, __pyx_v_ccd); if (unlikely(__pyx_t_6 == -1)) __PYX_ERR(0, 1843, __pyx_L1_error)

    /* "libopenzwave.pyx":1844
 *             ccd['receivedCnt']  = temp.m_receivedCnt
 *             listccdata.append(ccd)
 *             data.m_ccData.pop_back();             # <<<<<<<<<<<<<<
 *         ret['ccData'] = listccdata
 *         return ret
 */
    __pyx_v_data.m_ccData.pop_back();
  }

  /* "libopenzwave.pyx":1845
 *             listccdata.append(ccd)
 *             data.m_ccData.pop_back();
 *         ret['ccData'] = listccdata             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
  if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_n_s_ccData, __pyx_v_listccdata) < 0)) __PYX_ERR(0, 1845, __pyx_L1_error)

  /* "libopenzwave.pyx":1846
 *             data.m_ccData.pop_back();
 *         ret['ccData'] = listccdata
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def requestNodeDynamic(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1777
 * #
 * 
 *     def getNodeStatistics(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeStatistics:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeStatistics", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_ret);
  __Pyx_XDECREF(__pyx_v_listccdata);
  __Pyx_XDECREF(__pyx_v_ccd);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1848
 *         return ret
 * 
 *     def requestNodeDynamic(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _requestNodeDynamic:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_69requestNodeDynamic(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_68requestNodeDynamic[] = "\n.. _requestNodeDynamic:\n\nTrigger the fetching of fixed data about a node.\n\nCauses the nodes data to be obtained from the Z-Wave network in the same way\nas if it had just been added.  This method would normally be called\nautomatically by OpenZWave, but if you know that a node has been changed,\ncalling this method will force a refresh of the data held by the library.  This\ncan be especially useful for devices that were asleep when the application was\nfirst run.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_69requestNodeDynamic(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("requestNodeDynamic (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("requestNodeDynamic", 1, 2, 2, 1); __PYX_ERR(0, 1848, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "requestNodeDynamic") < 0)) __PYX_ERR(0, 1848, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("requestNodeDynamic", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1848, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.requestNodeDynamic", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_68requestNodeDynamic(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_68requestNodeDynamic(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("requestNodeDynamic", 0);

  /* "libopenzwave.pyx":1869
 * 
 *         '''
 *         return self.manager.RequestNodeDynamic(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def refreshNodeInfo(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1869, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1869, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->RequestNodeDynamic(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1869, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1848
 *         return ret
 * 
 *     def requestNodeDynamic(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _requestNodeDynamic:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.requestNodeDynamic", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1871
 *         return self.manager.RequestNodeDynamic(homeid, nodeid)
 * 
 *     def refreshNodeInfo(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _refreshNodeInfo:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_71refreshNodeInfo(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_70refreshNodeInfo[] = "\n.. _refreshNodeInfo:\n\nTrigger the fetching of fixed data about a node.\n\nCauses the nodes data to be obtained from the Z-Wave network in the same way\nas if it had just been added.  This method would normally be called\nautomatically by OpenZWave, but if you know that a node has been changed,\ncalling this method will force a refresh of the data held by the library.  This\ncan be especially useful for devices that were asleep when the application was\nfirst run.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_71refreshNodeInfo(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("refreshNodeInfo (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("refreshNodeInfo", 1, 2, 2, 1); __PYX_ERR(0, 1871, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "refreshNodeInfo") < 0)) __PYX_ERR(0, 1871, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("refreshNodeInfo", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1871, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.refreshNodeInfo", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_70refreshNodeInfo(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_70refreshNodeInfo(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("refreshNodeInfo", 0);

  /* "libopenzwave.pyx":1892
 * 
 *         '''
 *         return self.manager.RefreshNodeInfo(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def requestNodeState(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1892, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1892, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->RefreshNodeInfo(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1892, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1871
 *         return self.manager.RequestNodeDynamic(homeid, nodeid)
 * 
 *     def refreshNodeInfo(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _refreshNodeInfo:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.refreshNodeInfo", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1894
 *         return self.manager.RefreshNodeInfo(homeid, nodeid)
 * 
 *     def requestNodeState(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _requestNodeState:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_73requestNodeState(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_72requestNodeState[] = "\n.. _requestNodeState:\n\nTrigger the fetching of just the dynamic value data for a node.\nCauses the node's values to be requested from the Z-Wave network. This is the\nsame as the query state starting from the dynamic state.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_73requestNodeState(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("requestNodeState (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("requestNodeState", 1, 2, 2, 1); __PYX_ERR(0, 1894, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "requestNodeState") < 0)) __PYX_ERR(0, 1894, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("requestNodeState", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1894, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.requestNodeState", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_72requestNodeState(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_72requestNodeState(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("requestNodeState", 0);

  /* "libopenzwave.pyx":1910
 * 
 *         '''
 *         return self.manager.RequestNodeState(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def isNodeBeamingDevice(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1910, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1910, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->RequestNodeState(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1910, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1894
 *         return self.manager.RefreshNodeInfo(homeid, nodeid)
 * 
 *     def requestNodeState(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _requestNodeState:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.requestNodeState", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1912
 *         return self.manager.RequestNodeState(homeid, nodeid)
 * 
 *     def isNodeBeamingDevice(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isNodeBeamingDevice:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_75isNodeBeamingDevice(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_74isNodeBeamingDevice[] = "\n.. _isNodeBeamingDevice:\n\nGet whether the node is a beam capable device.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the node is a beaming device\n:rtype: bool\n:see: isNodeListeningDevice_, isNodeFrequentListeningDevice_, isNodeSecurityDevice_, isNodeRoutingDevice_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_75isNodeBeamingDevice(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isNodeBeamingDevice (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("isNodeBeamingDevice", 1, 2, 2, 1); __PYX_ERR(0, 1912, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "isNodeBeamingDevice") < 0)) __PYX_ERR(0, 1912, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("isNodeBeamingDevice", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1912, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeBeamingDevice", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_74isNodeBeamingDevice(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_74isNodeBeamingDevice(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("isNodeBeamingDevice", 0);

  /* "libopenzwave.pyx":1927
 * 
 *         '''
 *         return self.manager.IsNodeBeamingDevice(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1927, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1927, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsNodeBeamingDevice(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1927, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1912
 *         return self.manager.RequestNodeState(homeid, nodeid)
 * 
 *     def isNodeBeamingDevice(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isNodeBeamingDevice:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeBeamingDevice", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1930
 * 
 * 
 *     def isNodeListeningDevice(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isNodeListeningDevice:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_77isNodeListeningDevice(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_76isNodeListeningDevice[] = "\n.. _isNodeListeningDevice:\n\nGet whether the node is a setening device that does not go to sleep\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if it is a setening node.\n:rtype: bool\n:see: isNodeBeamingDevice_, isNodeFrequentListeningDevice_, isNodeSecurityDevice_, isNodeRoutingDevice_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_77isNodeListeningDevice(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isNodeListeningDevice (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("isNodeListeningDevice", 1, 2, 2, 1); __PYX_ERR(0, 1930, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "isNodeListeningDevice") < 0)) __PYX_ERR(0, 1930, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("isNodeListeningDevice", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1930, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeListeningDevice", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_76isNodeListeningDevice(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_76isNodeListeningDevice(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("isNodeListeningDevice", 0);

  /* "libopenzwave.pyx":1945
 * 
 *         '''
 *         return self.manager.IsNodeListeningDevice(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def isNodeFrequentListeningDevice(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1945, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1945, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsNodeListeningDevice(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1945, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1930
 * 
 * 
 *     def isNodeListeningDevice(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isNodeListeningDevice:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeListeningDevice", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1947
 *         return self.manager.IsNodeListeningDevice(homeid, nodeid)
 * 
 *     def isNodeFrequentListeningDevice(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isNodeFrequentListeningDevice:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_79isNodeFrequentListeningDevice(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_78isNodeFrequentListeningDevice[] = "\n.. _isNodeFrequentListeningDevice:\n\nGet whether the node is a frequent setening device that goes to sleep but\ncan be woken up by a beam. Useful to determine node and controller consistency.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if it is a frequent setening node.\n:rtype: bool\n:see: isNodeBeamingDevice_, isNodeListeningDevice_, isNodeSecurityDevice_, isNodeRoutingDevice_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_79isNodeFrequentListeningDevice(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isNodeFrequentListeningDevice (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("isNodeFrequentListeningDevice", 1, 2, 2, 1); __PYX_ERR(0, 1947, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "isNodeFrequentListeningDevice") < 0)) __PYX_ERR(0, 1947, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("isNodeFrequentListeningDevice", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1947, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeFrequentListeningDevice", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_78isNodeFrequentListeningDevice(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_78isNodeFrequentListeningDevice(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("isNodeFrequentListeningDevice", 0);

  /* "libopenzwave.pyx":1963
 * 
 *         '''
 *         return self.manager.IsNodeFrequentListeningDevice(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def isNodeSecurityDevice(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1963, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1963, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsNodeFrequentListeningDevice(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1963, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1947
 *         return self.manager.IsNodeListeningDevice(homeid, nodeid)
 * 
 *     def isNodeFrequentListeningDevice(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isNodeFrequentListeningDevice:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeFrequentListeningDevice", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1965
 *         return self.manager.IsNodeFrequentListeningDevice(homeid, nodeid)
 * 
 *     def isNodeSecurityDevice(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isNodeSecurityDevice:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_81isNodeSecurityDevice(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_80isNodeSecurityDevice[] = "\n.. _isNodeSecurityDevice:\n\nGet the security attribute for a node. True if node supports security features.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if security features implemented.\n:rtype: bool\n:see: isNodeBeamingDevice_, isNodeListeningDevice_, isNodeFrequentListeningDevice_, isNodeRoutingDevice_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_81isNodeSecurityDevice(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isNodeSecurityDevice (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("isNodeSecurityDevice", 1, 2, 2, 1); __PYX_ERR(0, 1965, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "isNodeSecurityDevice") < 0)) __PYX_ERR(0, 1965, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("isNodeSecurityDevice", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1965, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeSecurityDevice", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_80isNodeSecurityDevice(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_80isNodeSecurityDevice(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("isNodeSecurityDevice", 0);

  /* "libopenzwave.pyx":1980
 * 
 *         '''
 *         return self.manager.IsNodeSecurityDevice(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def isNodeRoutingDevice(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1980, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1980, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsNodeSecurityDevice(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1980, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1965
 *         return self.manager.IsNodeFrequentListeningDevice(homeid, nodeid)
 * 
 *     def isNodeSecurityDevice(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isNodeSecurityDevice:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeSecurityDevice", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1982
 *         return self.manager.IsNodeSecurityDevice(homeid, nodeid)
 * 
 *     def isNodeRoutingDevice(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isNodeRoutingDevice:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_83isNodeRoutingDevice(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_82isNodeRoutingDevice[] = "\n.. _isNodeRoutingDevice:\n\nGet whether the node is a routing device that passes messages to other nodes\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the node is a routing device\n:rtype: bool\n:see: isNodeBeamingDevice_, isNodeListeningDevice_, isNodeFrequentListeningDevice_, isNodeSecurityDevice_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_83isNodeRoutingDevice(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isNodeRoutingDevice (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("isNodeRoutingDevice", 1, 2, 2, 1); __PYX_ERR(0, 1982, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "isNodeRoutingDevice") < 0)) __PYX_ERR(0, 1982, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("isNodeRoutingDevice", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1982, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeRoutingDevice", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_82isNodeRoutingDevice(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_82isNodeRoutingDevice(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("isNodeRoutingDevice", 0);

  /* "libopenzwave.pyx":1997
 * 
 *         '''
 *         return self.manager.IsNodeRoutingDevice(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def getNodeMaxBaudRate(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1997, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 1997, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsNodeRoutingDevice(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1997, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1982
 *         return self.manager.IsNodeSecurityDevice(homeid, nodeid)
 * 
 *     def isNodeRoutingDevice(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isNodeRoutingDevice:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeRoutingDevice", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":1999
 *         return self.manager.IsNodeRoutingDevice(homeid, nodeid)
 * 
 *     def getNodeMaxBaudRate(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeMaxBaudRate:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_85getNodeMaxBaudRate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_84getNodeMaxBaudRate[] = "\n.. _getNodeMaxBaudRate:\n\nGet the maximum baud rate of a nodes communications\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: The baud rate in bits per second.\n:rtype: int\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_85getNodeMaxBaudRate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeMaxBaudRate (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeMaxBaudRate", 1, 2, 2, 1); __PYX_ERR(0, 1999, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeMaxBaudRate") < 0)) __PYX_ERR(0, 1999, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeMaxBaudRate", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1999, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeMaxBaudRate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_84getNodeMaxBaudRate(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_84getNodeMaxBaudRate(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getNodeMaxBaudRate", 0);

  /* "libopenzwave.pyx":2013
 * 
 *         '''
 *         return self.manager.GetNodeMaxBaudRate(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def getNodeVersion(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2013, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2013, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_self->manager->GetNodeMaxBaudRate(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2013, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":1999
 *         return self.manager.IsNodeRoutingDevice(homeid, nodeid)
 * 
 *     def getNodeMaxBaudRate(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeMaxBaudRate:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeMaxBaudRate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2015
 *         return self.manager.GetNodeMaxBaudRate(homeid, nodeid)
 * 
 *     def getNodeVersion(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeVersion:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_87getNodeVersion(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_86getNodeVersion[] = "\n.. _getNodeVersion:\n\nGet the version number of a node\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: The node version number\n:rtype: int\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_87getNodeVersion(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeVersion (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeVersion", 1, 2, 2, 1); __PYX_ERR(0, 2015, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeVersion") < 0)) __PYX_ERR(0, 2015, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeVersion", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2015, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeVersion", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_86getNodeVersion(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_86getNodeVersion(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getNodeVersion", 0);

  /* "libopenzwave.pyx":2029
 * 
 *         '''
 *         return self.manager.GetNodeVersion(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def getNodeSecurity(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2029, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2029, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_From_uint8_t(__pyx_v_self->manager->GetNodeVersion(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2029, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2015
 *         return self.manager.GetNodeMaxBaudRate(homeid, nodeid)
 * 
 *     def getNodeVersion(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeVersion:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeVersion", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2031
 *         return self.manager.GetNodeVersion(homeid, nodeid)
 * 
 *     def getNodeSecurity(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeSecurity:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_89getNodeSecurity(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_88getNodeSecurity[] = "\n.. _getNodeSecurity:\n\nGet the security byte for a node.  Bit meanings are still to be determined.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: The node security byte\n:rtype: int\n:see: getNodeType_, getNodeSpecific_, getNodeGeneric_, getNodeBasic_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_89getNodeSecurity(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeSecurity (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeSecurity", 1, 2, 2, 1); __PYX_ERR(0, 2031, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeSecurity") < 0)) __PYX_ERR(0, 2031, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeSecurity", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2031, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeSecurity", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_88getNodeSecurity(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_88getNodeSecurity(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getNodeSecurity", 0);

  /* "libopenzwave.pyx":2046
 * 
 *         '''
 *         return self.manager.GetNodeSecurity(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def getNodeBasic(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2046, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2046, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_From_uint8_t(__pyx_v_self->manager->GetNodeSecurity(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2046, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2031
 *         return self.manager.GetNodeVersion(homeid, nodeid)
 * 
 *     def getNodeSecurity(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeSecurity:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeSecurity", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2048
 *         return self.manager.GetNodeSecurity(homeid, nodeid)
 * 
 *     def getNodeBasic(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeBasic:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_91getNodeBasic(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_90getNodeBasic[] = "\n.. _getNodeBasic:\n\nGet the basic type of a node.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: The node basic type.\n:rtype: int\n:see: getNodeType_, getNodeSpecific_, getNodeGeneric_, getNodeSecurity_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_91getNodeBasic(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeBasic (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeBasic", 1, 2, 2, 1); __PYX_ERR(0, 2048, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeBasic") < 0)) __PYX_ERR(0, 2048, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeBasic", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2048, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeBasic", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_90getNodeBasic(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_90getNodeBasic(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getNodeBasic", 0);

  /* "libopenzwave.pyx":2063
 * 
 *         '''
 *         return self.manager.GetNodeBasic(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def getNodeGeneric(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2063, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2063, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_From_uint8_t(__pyx_v_self->manager->GetNodeBasic(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2063, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2048
 *         return self.manager.GetNodeSecurity(homeid, nodeid)
 * 
 *     def getNodeBasic(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeBasic:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeBasic", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2065
 *         return self.manager.GetNodeBasic(homeid, nodeid)
 * 
 *     def getNodeGeneric(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeGeneric:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_93getNodeGeneric(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_92getNodeGeneric[] = "\n.. _getNodeGeneric:\n\nGet the generic type of a node.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: The node generic type.\n:rtype: int\n:see: getNodeType_, getNodeSpecific_, getNodeBasic_, getNodeSecurity_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_93getNodeGeneric(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeGeneric (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeGeneric", 1, 2, 2, 1); __PYX_ERR(0, 2065, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeGeneric") < 0)) __PYX_ERR(0, 2065, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeGeneric", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2065, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeGeneric", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_92getNodeGeneric(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_92getNodeGeneric(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getNodeGeneric", 0);

  /* "libopenzwave.pyx":2080
 * 
 *         '''
 *         return self.manager.GetNodeGeneric(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def getNodeSpecific(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2080, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2080, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_From_uint8_t(__pyx_v_self->manager->GetNodeGeneric(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2080, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2065
 *         return self.manager.GetNodeBasic(homeid, nodeid)
 * 
 *     def getNodeGeneric(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeGeneric:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeGeneric", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2082
 *         return self.manager.GetNodeGeneric(homeid, nodeid)
 * 
 *     def getNodeSpecific(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeSpecific:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_95getNodeSpecific(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_94getNodeSpecific[] = "\n.. _getNodeSpecific:\n\nGet the specific type of a node.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type homeId: int\n:return: int -- The node specific type.\n:see: getNodeType_, getNodeGeneric_, getNodeBasic_, getNodeSecurity_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_95getNodeSpecific(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeSpecific (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeSpecific", 1, 2, 2, 1); __PYX_ERR(0, 2082, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeSpecific") < 0)) __PYX_ERR(0, 2082, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeSpecific", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2082, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeSpecific", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_94getNodeSpecific(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_94getNodeSpecific(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getNodeSpecific", 0);

  /* "libopenzwave.pyx":2096
 * 
 *         '''
 *         return self.manager.GetNodeSpecific(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def getNodeType(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2096, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2096, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_From_uint8_t(__pyx_v_self->manager->GetNodeSpecific(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2096, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2082
 *         return self.manager.GetNodeGeneric(homeid, nodeid)
 * 
 *     def getNodeSpecific(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeSpecific:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeSpecific", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2098
 *         return self.manager.GetNodeSpecific(homeid, nodeid)
 * 
 *     def getNodeType(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeType:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_97getNodeType(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_96getNodeType[] = "\n.. _getNodeType:\n\nGet a human-readable label describing the node\n\nThe label is taken from the Z-Wave specific, generic or basic type, depending\non which of those values are specified by the node.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: A string containing the label text.\n:rtype: str\n:see: getNodeSpecific_, getNodeGeneric_, getNodeBasic_, getNodeSecurity_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_97getNodeType(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeType (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeType", 1, 2, 2, 1); __PYX_ERR(0, 2098, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeType") < 0)) __PYX_ERR(0, 2098, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeType", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2098, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeType", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_96getNodeType(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_96getNodeType(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getNodeType", 0);

  /* "libopenzwave.pyx":2116
 * 
 *         '''
 *         cdef string c_string = self.manager.GetNodeType(homeid, nodeid)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2116, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2116, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetNodeType(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":2117
 *         '''
 *         cdef string c_string = self.manager.GetNodeType(homeid, nodeid)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getNodeNeighbors(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2117, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2117, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2098
 *         return self.manager.GetNodeSpecific(homeid, nodeid)
 * 
 *     def getNodeType(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeType:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeType", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2119
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodeNeighbors(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeNeighbors:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_99getNodeNeighbors(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_98getNodeNeighbors[] = "\n.. _getNodeNeighbors:\n\nGet the bitmap of this node's neighbors.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: A set containing neighboring node IDs\n:rtype: set()\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_99getNodeNeighbors(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeNeighbors (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeNeighbors", 1, 2, 2, 1); __PYX_ERR(0, 2119, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeNeighbors") < 0)) __PYX_ERR(0, 2119, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeNeighbors", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2119, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeNeighbors", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_98getNodeNeighbors(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_98getNodeNeighbors(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_v_data = NULL;
  uint8_t **__pyx_v_dbuf;
  uint32_t __pyx_v_count;
  struct __pyx_obj_12libopenzwave_RetAlloc *__pyx_v_retuint8 = 0;
  uint8_t *__pyx_v_p;
  uint32_t __pyx_v_start;
  uint32_t __pyx_v_i;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  uint32_t __pyx_t_2;
  uint8_t __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  uint32_t __pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  int __pyx_t_9;
  char const *__pyx_t_10;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  PyObject *__pyx_t_16 = NULL;
  __Pyx_RefNannySetupContext("getNodeNeighbors", 0);

  /* "libopenzwave.pyx":2133
 * 
 *         '''
 *         data = set()             # <<<<<<<<<<<<<<
 *         #Allocate memory for the c++ function
 *         #Return value is pointer to uint8_t[]
 */
  __pyx_t_1 = PySet_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2133, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_data = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "libopenzwave.pyx":2136
 *         #Allocate memory for the c++ function
 *         #Return value is pointer to uint8_t[]
 *         cdef uint8_t** dbuf = <uint8_t**>malloc(sizeof(uint8_t)*29)             # <<<<<<<<<<<<<<
 *         #Get the number of neigbors
 *         cdef uint32_t count = self.manager.GetNodeNeighbors(homeid, nodeid, dbuf)
 */
  __pyx_v_dbuf = ((uint8_t **)malloc(((sizeof(uint8_t)) * 29)));

  /* "libopenzwave.pyx":2138
 *         cdef uint8_t** dbuf = <uint8_t**>malloc(sizeof(uint8_t)*29)
 *         #Get the number of neigbors
 *         cdef uint32_t count = self.manager.GetNodeNeighbors(homeid, nodeid, dbuf)             # <<<<<<<<<<<<<<
 *         if count == 0:
 *             #Don't need to allocate memory.
 */
  __pyx_t_2 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_2 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2138, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_3 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2138, __pyx_L1_error)
  __pyx_v_count = __pyx_v_self->manager->GetNodeNeighbors(__pyx_t_2, __pyx_t_3, __pyx_v_dbuf);

  /* "libopenzwave.pyx":2139
 *         #Get the number of neigbors
 *         cdef uint32_t count = self.manager.GetNodeNeighbors(homeid, nodeid, dbuf)
 *         if count == 0:             # <<<<<<<<<<<<<<
 *             #Don't need to allocate memory.
 *             free(dbuf)
 */
  __pyx_t_4 = ((__pyx_v_count == 0) != 0);
  if (__pyx_t_4) {

    /* "libopenzwave.pyx":2141
 *         if count == 0:
 *             #Don't need to allocate memory.
 *             free(dbuf)             # <<<<<<<<<<<<<<
 *             return data
 *         #Allocate memory for the returned values
 */
    free(__pyx_v_dbuf);

    /* "libopenzwave.pyx":2142
 *             #Don't need to allocate memory.
 *             free(dbuf)
 *             return data             # <<<<<<<<<<<<<<
 *         #Allocate memory for the returned values
 *         cdef RetAlloc retuint8 = RetAlloc(count)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_data);
    __pyx_r = __pyx_v_data;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2139
 *         #Get the number of neigbors
 *         cdef uint32_t count = self.manager.GetNodeNeighbors(homeid, nodeid, dbuf)
 *         if count == 0:             # <<<<<<<<<<<<<<
 *             #Don't need to allocate memory.
 *             free(dbuf)
 */
  }

  /* "libopenzwave.pyx":2144
 *             return data
 *         #Allocate memory for the returned values
 *         cdef RetAlloc retuint8 = RetAlloc(count)             # <<<<<<<<<<<<<<
 *         cdef uint8_t* p
 *         cdef uint32_t start = 0
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(__pyx_v_count); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2144, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2144, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_12libopenzwave_RetAlloc), __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2144, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_v_retuint8 = ((struct __pyx_obj_12libopenzwave_RetAlloc *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "libopenzwave.pyx":2146
 *         cdef RetAlloc retuint8 = RetAlloc(count)
 *         cdef uint8_t* p
 *         cdef uint32_t start = 0             # <<<<<<<<<<<<<<
 *         if count:
 *             try:
 */
  __pyx_v_start = 0;

  /* "libopenzwave.pyx":2147
 *         cdef uint8_t* p
 *         cdef uint32_t start = 0
 *         if count:             # <<<<<<<<<<<<<<
 *             try:
 *                 p = dbuf[0] # p is now pointing at first element of array
 */
  __pyx_t_4 = (__pyx_v_count != 0);
  if (__pyx_t_4) {

    /* "libopenzwave.pyx":2148
 *         cdef uint32_t start = 0
 *         if count:
 *             try:             # <<<<<<<<<<<<<<
 *                 p = dbuf[0] # p is now pointing at first element of array
 *                 for i in range(start, count):
 */
    /*try:*/ {

      /* "libopenzwave.pyx":2149
 *         if count:
 *             try:
 *                 p = dbuf[0] # p is now pointing at first element of array             # <<<<<<<<<<<<<<
 *                 for i in range(start, count):
 *                     #cdef uint8_t = retuint8[i]
 */
      __pyx_v_p = (__pyx_v_dbuf[0]);

      /* "libopenzwave.pyx":2150
 *             try:
 *                 p = dbuf[0] # p is now pointing at first element of array
 *                 for i in range(start, count):             # <<<<<<<<<<<<<<
 *                     #cdef uint8_t = retuint8[i]
 *                     retuint8.data[i] = p[0]
 */
      __pyx_t_2 = __pyx_v_count;
      for (__pyx_t_6 = __pyx_v_start; __pyx_t_6 < __pyx_t_2; __pyx_t_6+=1) {
        __pyx_v_i = __pyx_t_6;

        /* "libopenzwave.pyx":2152
 *                 for i in range(start, count):
 *                     #cdef uint8_t = retuint8[i]
 *                     retuint8.data[i] = p[0]             # <<<<<<<<<<<<<<
 *                     data.add(retuint8.data[i])
 *                     p += 1
 */
        (__pyx_v_retuint8->data[__pyx_v_i]) = (__pyx_v_p[0]);

        /* "libopenzwave.pyx":2153
 *                     #cdef uint8_t = retuint8[i]
 *                     retuint8.data[i] = p[0]
 *                     data.add(retuint8.data[i])             # <<<<<<<<<<<<<<
 *                     p += 1
 *             finally:
 */
        __pyx_t_1 = __Pyx_PyInt_From_uint8_t((__pyx_v_retuint8->data[__pyx_v_i])); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2153, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_7 = PySet_Add(__pyx_v_data, __pyx_t_1); if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 2153, __pyx_L6_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "libopenzwave.pyx":2154
 *                     retuint8.data[i] = p[0]
 *                     data.add(retuint8.data[i])
 *                     p += 1             # <<<<<<<<<<<<<<
 *             finally:
 *                 #Free memory
 */
        __pyx_v_p = (__pyx_v_p + 1);
      }
    }

    /* "libopenzwave.pyx":2157
 *             finally:
 *                 #Free memory
 *                 free(dbuf)             # <<<<<<<<<<<<<<
 *                 pass
 *         return data
 */
    /*finally:*/ {
      /*normal exit:*/{
        free(__pyx_v_dbuf);
        goto __pyx_L7;
      }
      /*exception exit:*/{
        __Pyx_PyThreadState_declare
        __pyx_L6_error:;
        __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0;
        __Pyx_PyThreadState_assign
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_14, &__pyx_t_15, &__pyx_t_16);
        if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_11, &__pyx_t_12, &__pyx_t_13) < 0)) __Pyx_ErrFetch(&__pyx_t_11, &__pyx_t_12, &__pyx_t_13);
        __Pyx_XGOTREF(__pyx_t_11);
        __Pyx_XGOTREF(__pyx_t_12);
        __Pyx_XGOTREF(__pyx_t_13);
        __Pyx_XGOTREF(__pyx_t_14);
        __Pyx_XGOTREF(__pyx_t_15);
        __Pyx_XGOTREF(__pyx_t_16);
        __pyx_t_8 = __pyx_lineno; __pyx_t_9 = __pyx_clineno; __pyx_t_10 = __pyx_filename;
        {
          free(__pyx_v_dbuf);
        }
        __Pyx_PyThreadState_assign
        if (PY_MAJOR_VERSION >= 3) {
          __Pyx_XGIVEREF(__pyx_t_14);
          __Pyx_XGIVEREF(__pyx_t_15);
          __Pyx_XGIVEREF(__pyx_t_16);
          __Pyx_ExceptionReset(__pyx_t_14, __pyx_t_15, __pyx_t_16);
        }
        __Pyx_XGIVEREF(__pyx_t_11);
        __Pyx_XGIVEREF(__pyx_t_12);
        __Pyx_XGIVEREF(__pyx_t_13);
        __Pyx_ErrRestore(__pyx_t_11, __pyx_t_12, __pyx_t_13);
        __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0;
        __pyx_lineno = __pyx_t_8; __pyx_clineno = __pyx_t_9; __pyx_filename = __pyx_t_10;
        goto __pyx_L1_error;
      }
      __pyx_L7:;
    }

    /* "libopenzwave.pyx":2147
 *         cdef uint8_t* p
 *         cdef uint32_t start = 0
 *         if count:             # <<<<<<<<<<<<<<
 *             try:
 *                 p = dbuf[0] # p is now pointing at first element of array
 */
  }

  /* "libopenzwave.pyx":2159
 *                 free(dbuf)
 *                 pass
 *         return data             # <<<<<<<<<<<<<<
 * 
 *     def getNodeManufacturerName(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_data);
  __pyx_r = __pyx_v_data;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2119
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodeNeighbors(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeNeighbors:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeNeighbors", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_data);
  __Pyx_XDECREF((PyObject *)__pyx_v_retuint8);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2161
 *         return data
 * 
 *     def getNodeManufacturerName(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 *         .. _getNodeManufacturerName:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_101getNodeManufacturerName(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_100getNodeManufacturerName[] = "\n        .. _getNodeManufacturerName:\n\nGet the manufacturer name of a device\n\nThe manufacturer name would normally be handled by the Manufacturer Specific\ncommmand class, taking the manufacturer ID reported by the device and using it\nto look up the name from the manufacturer_specific.xml file in the OpenZWave\nconfig folder.  However, there are some devices that do not support the command\nclass, so to enable the user to manually set the name, it is stored with the\nnode data and accessed via this method rather than being reported via a command\nclass Value object.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: A string containing the nodes manufacturer name.\n:rtype: str\n:see: setNodeManufacturerName_, getNodeProductName_, setNodeProductName_,     getNodeManufacturerId_, getNodeProductId_, getNodeProductType_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_101getNodeManufacturerName(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeManufacturerName (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeManufacturerName", 1, 2, 2, 1); __PYX_ERR(0, 2161, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeManufacturerName") < 0)) __PYX_ERR(0, 2161, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeManufacturerName", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2161, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeManufacturerName", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_100getNodeManufacturerName(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_100getNodeManufacturerName(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  std::string __pyx_v_manufacturer_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getNodeManufacturerName", 0);

  /* "libopenzwave.pyx":2185
 * 
 *         '''
 *         cdef string manufacturer_string = self.manager.GetNodeManufacturerName(homeid, nodeid)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(manufacturer_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2185, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2185, __pyx_L1_error)
  __pyx_v_manufacturer_string = __pyx_v_self->manager->GetNodeManufacturerName(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":2186
 *         '''
 *         cdef string manufacturer_string = self.manager.GetNodeManufacturerName(homeid, nodeid)
 *         return cstr_to_str(manufacturer_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getNodeProductName(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_manufacturer_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2161
 *         return data
 * 
 *     def getNodeManufacturerName(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 *         .. _getNodeManufacturerName:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeManufacturerName", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2188
 *         return cstr_to_str(manufacturer_string.c_str())
 * 
 *     def getNodeProductName(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeProductName:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_103getNodeProductName(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_102getNodeProductName[] = "\n.. _getNodeProductName:\n\nGet the product name of a device\n\nThe product name would normally be handled by the Manufacturer Specific\ncommmand class, taking the product Type and ID reported by the device and using\nit to look up the name from the manufacturer_specific.xml file in the OpenZWave\nconfig folder.  However, there are some devices that do not support the command\nclass, so to enable the user to manually set the name, it is stored with the\nnode data and accessed via this method rather than being reported via a command\nclass Value object.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: str -- A string containing the nodes product name.\n:see: setNodeProductName_, getNodeManufacturerName_, setNodeManufacturerName_,     getNodeManufacturerId_, getNodeProductId_, getNodeProductType_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_103getNodeProductName(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeProductName (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeProductName", 1, 2, 2, 1); __PYX_ERR(0, 2188, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeProductName") < 0)) __PYX_ERR(0, 2188, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeProductName", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2188, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeProductName", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_102getNodeProductName(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_102getNodeProductName(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  std::string __pyx_v_productname_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getNodeProductName", 0);

  /* "libopenzwave.pyx":2211
 * 
 *         '''
 *         cdef string productname_string = self.manager.GetNodeProductName(homeid, nodeid)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(productname_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2211, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2211, __pyx_L1_error)
  __pyx_v_productname_string = __pyx_v_self->manager->GetNodeProductName(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":2212
 *         '''
 *         cdef string productname_string = self.manager.GetNodeProductName(homeid, nodeid)
 *         return cstr_to_str(productname_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getNodeName(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_productname_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2212, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2212, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2188
 *         return cstr_to_str(manufacturer_string.c_str())
 * 
 *     def getNodeProductName(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeProductName:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeProductName", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2214
 *         return cstr_to_str(productname_string.c_str())
 * 
 *     def getNodeName(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeName:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_105getNodeName(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_104getNodeName[] = "\n.. _getNodeName:\n\nGet the name of a node\n\nThe node name is a user-editable label for the node that would normally be\nhandled by the Node Naming commmand class, but many devices do not support it.\nSo that a node can always be named, OpenZWave stores it with the node data, and\nprovides access through this method and SetNodeName, rather than reporting it\nvia a command class Value object.  The maximum length of a node name is 16\ncharacters.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: str -- A string containing the node name.\n:see: setNodeName_, getNodeLocation_, setNodeLocation_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_105getNodeName(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeName (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeName", 1, 2, 2, 1); __PYX_ERR(0, 2214, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeName") < 0)) __PYX_ERR(0, 2214, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeName", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2214, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeName", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_104getNodeName(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_104getNodeName(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getNodeName", 0);

  /* "libopenzwave.pyx":2235
 * 
 *         '''
 *         cdef string c_string = self.manager.GetNodeName(homeid, nodeid)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2235, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2235, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetNodeName(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":2236
 *         '''
 *         cdef string c_string = self.manager.GetNodeName(homeid, nodeid)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getNodeLocation(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2236, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2236, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2214
 *         return cstr_to_str(productname_string.c_str())
 * 
 *     def getNodeName(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeName:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeName", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2238
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodeLocation(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeLocation:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_107getNodeLocation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_106getNodeLocation[] = "\n.. _getNodeLocation:\n\nGet the location of a node\n\nThe node location is a user-editable string that would normally be handled by\nthe Node Naming commmand class, but many devices do not support it.  So that a\nnode can always report its location, OpenZWave stores it with the node data,\nand provides access through this method and SetNodeLocation, rather than\nreporting it via a command class Value object.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: str -- A string containing the nodes location.\n:see: setNodeLocation_, getNodeName_, setNodeName_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_107getNodeLocation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeLocation (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeLocation", 1, 2, 2, 1); __PYX_ERR(0, 2238, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeLocation") < 0)) __PYX_ERR(0, 2238, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeLocation", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2238, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeLocation", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_106getNodeLocation(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_106getNodeLocation(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getNodeLocation", 0);

  /* "libopenzwave.pyx":2258
 * 
 *         '''
 *         cdef string c_string = self.manager.GetNodeLocation(homeid, nodeid)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2258, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2258, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetNodeLocation(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":2259
 *         '''
 *         cdef string c_string = self.manager.GetNodeLocation(homeid, nodeid)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getNodeManufacturerId(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2238
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodeLocation(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeLocation:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeLocation", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2261
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodeManufacturerId(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeManufacturerId:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_109getNodeManufacturerId(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_108getNodeManufacturerId[] = "\n.. _getNodeManufacturerId:\n\nGet the manufacturer ID of a device\n\nThe manufacturer ID is a four digit hex code and would normally be handled by\nthe Manufacturer-Specific commmand class, but not all devices support it.\nAlthough the value reported by this method will be an empty string if the\ncommand class is not supported and cannot be set by the user, the manufacturer\nID is still stored with the node data (rather than being reported via a command\nclass Value object) to retain a consistent approach with the other manufacturer\nspecific data.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: A string containing the nodes manufacturer ID, or an empty string if the manufactuer-specific command class is not supported by the device.\n:rtype: str\n:see: getNodeProductType_, getNodeProductId_, getNodeManufacturerName_, setNodeManufacturerName_,     getNodeProductName_, setNodeProductName_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_109getNodeManufacturerId(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeManufacturerId (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeManufacturerId", 1, 2, 2, 1); __PYX_ERR(0, 2261, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeManufacturerId") < 0)) __PYX_ERR(0, 2261, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeManufacturerId", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2261, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeManufacturerId", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_108getNodeManufacturerId(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_108getNodeManufacturerId(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getNodeManufacturerId", 0);

  /* "libopenzwave.pyx":2285
 * 
 *         '''
 *         cdef string c_string = self.manager.GetNodeManufacturerId(homeid, nodeid)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2285, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2285, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetNodeManufacturerId(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":2286
 *         '''
 *         cdef string c_string = self.manager.GetNodeManufacturerId(homeid, nodeid)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getNodeProductType(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2286, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2286, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2261
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodeManufacturerId(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeManufacturerId:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeManufacturerId", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2288
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodeProductType(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeProductType:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_111getNodeProductType(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_110getNodeProductType[] = "\n.. _getNodeProductType:\n\nGet the product type of a device\n\nThe product type is a four digit hex code and would normally be handled by the\nManufacturer Specific commmand class, but not all devices support it.  Although\nthe value reported by this method will be an empty string if the command class\nis not supported and cannot be set by the user, the product type is still\nstored with the node data (rather than being reported via a command class Value\nobject) to retain a consistent approach with the other manufacturer specific\ndata.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: A string containing the nodes product type, or an empty string if the manufactuer-specific command class is not supported by the device.\n:rtype: str\n:see: getNodeManufacturerId_, getNodeProductId_, getNodeManufacturerName_, setNodeManufacturerName_,     getNodeProductName_, setNodeProductName_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_111getNodeProductType(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeProductType (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeProductType", 1, 2, 2, 1); __PYX_ERR(0, 2288, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeProductType") < 0)) __PYX_ERR(0, 2288, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeProductType", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2288, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeProductType", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_110getNodeProductType(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_110getNodeProductType(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getNodeProductType", 0);

  /* "libopenzwave.pyx":2312
 * 
 *         '''
 *         cdef string c_string = self.manager.GetNodeProductType(homeid, nodeid)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2312, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2312, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetNodeProductType(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":2313
 *         '''
 *         cdef string c_string = self.manager.GetNodeProductType(homeid, nodeid)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getNodeProductId(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2313, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2313, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2288
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodeProductType(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeProductType:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeProductType", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2315
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodeProductId(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeProductId:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_113getNodeProductId(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_112getNodeProductId[] = "\n.. _getNodeProductId:\n\nGet the product ID of a device\n\nThe product ID is a four digit hex code and would normally be handled by the\nManufacturer-Specific commmand class, but not all devices support it.  Although\nthe value reported by this method will be an empty string if the command class\nis not supported and cannot be set by the user, the product ID is still stored\nwith the node data (rather than being reported via a command class Value\nobject)  to retain a consistent approach with the other manufacturer specific\ndata.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: A string containing the nodes product ID, or an empty string if the manufactuer-specific command class is not supported by the device.\n:rtype: str\n:see: getNodeManufacturerId_, getNodeProductType_, getNodeManufacturerName_, setNodeManufacturerName_, getNodeProductName_, setNodeProductName_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_113getNodeProductId(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeProductId (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeProductId", 1, 2, 2, 1); __PYX_ERR(0, 2315, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeProductId") < 0)) __PYX_ERR(0, 2315, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeProductId", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2315, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeProductId", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_112getNodeProductId(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_112getNodeProductId(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getNodeProductId", 0);

  /* "libopenzwave.pyx":2338
 * 
 *         '''
 *         cdef string c_string = self.manager.GetNodeProductId(homeid, nodeid)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2338, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2338, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetNodeProductId(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":2339
 *         '''
 *         cdef string c_string = self.manager.GetNodeProductId(homeid, nodeid)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def setNodeManufacturerName(self, homeid, nodeid, str manufacturerName):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2339, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2339, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2315
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodeProductId(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeProductId:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeProductId", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2341
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def setNodeManufacturerName(self, homeid, nodeid, str manufacturerName):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setNodeManufacturerName:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_115setNodeManufacturerName(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_114setNodeManufacturerName[] = "\n.. _setNodeManufacturerName:\n\nSet the manufacturer name of a device\n\nThe manufacturer name would normally be handled by the Manufacturer Specific\ncommmand class, taking the manufacturer ID reported by the device and using it\nto look up the name from the manufacturer_specific.xml file in the OpenZWave\nconfig folder.  However, there are some devices that do not support the command\nclass, so to enable the user to manually set the name, it is stored with the\nnode data and accessed via this method rather than being reported via a command\nclass Value object.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:param manufacturerName: A string containing the nodess manufacturer name.\n:type manufacturerName: str\n:see: getNodeManufacturerName_, getNodeProductName_, setNodeProductName_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_115setNodeManufacturerName(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_manufacturerName = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setNodeManufacturerName (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_manufacturerName,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setNodeManufacturerName", 1, 3, 3, 1); __PYX_ERR(0, 2341, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_manufacturerName)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setNodeManufacturerName", 1, 3, 3, 2); __PYX_ERR(0, 2341, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setNodeManufacturerName") < 0)) __PYX_ERR(0, 2341, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_manufacturerName = ((PyObject*)values[2]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setNodeManufacturerName", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2341, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setNodeManufacturerName", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_manufacturerName), (&PyString_Type), 1, "manufacturerName", 1))) __PYX_ERR(0, 2341, __pyx_L1_error)
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_114setNodeManufacturerName(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_manufacturerName);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_114setNodeManufacturerName(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_manufacturerName) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  __Pyx_RefNannySetupContext("setNodeManufacturerName", 0);

  /* "libopenzwave.pyx":2365
 *         '''
 *         self.manager.SetNodeManufacturerName(
 *             homeid, nodeid, str_to_cppstr(manufacturerName))             # <<<<<<<<<<<<<<
 * 
 *     def setNodeProductName(self, homeid, nodeid, str productName):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2365, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2365, __pyx_L1_error)

  /* "libopenzwave.pyx":2364
 * 
 *         '''
 *         self.manager.SetNodeManufacturerName(             # <<<<<<<<<<<<<<
 *             homeid, nodeid, str_to_cppstr(manufacturerName))
 * 
 */
  __pyx_v_self->manager->SetNodeManufacturerName(__pyx_t_1, __pyx_t_2, __pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_manufacturerName));

  /* "libopenzwave.pyx":2341
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def setNodeManufacturerName(self, homeid, nodeid, str manufacturerName):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setNodeManufacturerName:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setNodeManufacturerName", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2367
 *             homeid, nodeid, str_to_cppstr(manufacturerName))
 * 
 *     def setNodeProductName(self, homeid, nodeid, str productName):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setNodeProductName:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_117setNodeProductName(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_116setNodeProductName[] = "\n.. _setNodeProductName:\n\nSet the product name of a device\n\nThe product name would normally be handled by the Manufacturer Specific\ncommmand class, taking the product Type and ID reported by the device and using\nit to look up the name from the manufacturer_specific.xml file in the OpenZWave\nconfig folder.  However, there are some devices that do not support the command\nclass, so to enable the user to manually set the name, it is stored with the\nnode data and accessed via this method rather than being reported via a command\nclass Value object.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:param productName: A string containing the nodes product name.\n:type productName: str\n:see: getNodeProductName_, getNodeManufacturerName_, setNodeManufacturerName_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_117setNodeProductName(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_productName = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setNodeProductName (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_productName,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setNodeProductName", 1, 3, 3, 1); __PYX_ERR(0, 2367, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_productName)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setNodeProductName", 1, 3, 3, 2); __PYX_ERR(0, 2367, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setNodeProductName") < 0)) __PYX_ERR(0, 2367, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_productName = ((PyObject*)values[2]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setNodeProductName", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2367, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setNodeProductName", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_productName), (&PyString_Type), 1, "productName", 1))) __PYX_ERR(0, 2367, __pyx_L1_error)
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_116setNodeProductName(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_productName);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_116setNodeProductName(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_productName) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  __Pyx_RefNannySetupContext("setNodeProductName", 0);

  /* "libopenzwave.pyx":2390
 * 
 *         '''
 *         self.manager.SetNodeProductName(homeid, nodeid, str_to_cppstr(productName))             # <<<<<<<<<<<<<<
 * 
 *     def setNodeName(self, homeid, nodeid, str name):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2390, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2390, __pyx_L1_error)
  __pyx_v_self->manager->SetNodeProductName(__pyx_t_1, __pyx_t_2, __pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_productName));

  /* "libopenzwave.pyx":2367
 *             homeid, nodeid, str_to_cppstr(manufacturerName))
 * 
 *     def setNodeProductName(self, homeid, nodeid, str productName):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setNodeProductName:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setNodeProductName", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2392
 *         self.manager.SetNodeProductName(homeid, nodeid, str_to_cppstr(productName))
 * 
 *     def setNodeName(self, homeid, nodeid, str name):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setNodeName:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_119setNodeName(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_118setNodeName[] = "\n.. _setNodeName:\n\nSet the name of a node\n\nThe node name is a user-editable label for the node that would normally be\nhandled by the Node Naming commmand class, but many devices do not support it.\nSo that a node can always be named, OpenZWave stores it with the node data, and\nprovides access through this method and GetNodeName, rather than reporting it\nvia a command class Value object.  If the device does support the Node Naming\ncommand class, the new name will be sent to the node.  The maximum length of a\nnode name is 16 characters.\n\n:param homeI: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:param nodeName: A string containing the nodes name.\n:type nodeName: str\n:see: getNodeName_, getNodeLocation_, setNodeLocation_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_119setNodeName(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_name = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setNodeName (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_name,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setNodeName", 1, 3, 3, 1); __PYX_ERR(0, 2392, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setNodeName", 1, 3, 3, 2); __PYX_ERR(0, 2392, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setNodeName") < 0)) __PYX_ERR(0, 2392, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_name = ((PyObject*)values[2]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setNodeName", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2392, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setNodeName", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_name), (&PyString_Type), 1, "name", 1))) __PYX_ERR(0, 2392, __pyx_L1_error)
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_118setNodeName(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_name);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_118setNodeName(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_name) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  __Pyx_RefNannySetupContext("setNodeName", 0);

  /* "libopenzwave.pyx":2415
 * 
 *         '''
 *         self.manager.SetNodeName(homeid, nodeid, str_to_cppstr(name))             # <<<<<<<<<<<<<<
 * 
 *     def setNodeLocation(self, homeid, nodeid, str location):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2415, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2415, __pyx_L1_error)
  __pyx_v_self->manager->SetNodeName(__pyx_t_1, __pyx_t_2, __pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_name));

  /* "libopenzwave.pyx":2392
 *         self.manager.SetNodeProductName(homeid, nodeid, str_to_cppstr(productName))
 * 
 *     def setNodeName(self, homeid, nodeid, str name):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setNodeName:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setNodeName", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2417
 *         self.manager.SetNodeName(homeid, nodeid, str_to_cppstr(name))
 * 
 *     def setNodeLocation(self, homeid, nodeid, str location):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setNodeLocation:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_121setNodeLocation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_120setNodeLocation[] = "\n.. _setNodeLocation:\n\nSet the location of a node\n\nThe node location is a user-editable string that would normally be handled by\nthe Node Naming commmand class, but many devices do not support it.  So that a\nnode can always report its location, OpenZWave stores it with the node data,\nand provides access through this method and GetNodeLocation, rather than\nreporting it via a command class Value object.  If the device does support the\nNode Naming command class, the new location will be sent to the node.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:param location: A string containing the nodes location.\n:type location: int\n:see: getNodeLocation_, getNodeName_, setNodeName_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_121setNodeLocation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_location = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setNodeLocation (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_location,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setNodeLocation", 1, 3, 3, 1); __PYX_ERR(0, 2417, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_location)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setNodeLocation", 1, 3, 3, 2); __PYX_ERR(0, 2417, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setNodeLocation") < 0)) __PYX_ERR(0, 2417, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_location = ((PyObject*)values[2]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setNodeLocation", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2417, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setNodeLocation", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_location), (&PyString_Type), 1, "location", 1))) __PYX_ERR(0, 2417, __pyx_L1_error)
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_120setNodeLocation(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_location);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_120setNodeLocation(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_location) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  __Pyx_RefNannySetupContext("setNodeLocation", 0);

  /* "libopenzwave.pyx":2439
 * 
 *         '''
 *         self.manager.SetNodeLocation(homeid, nodeid, str_to_cppstr(location))             # <<<<<<<<<<<<<<
 * 
 *     def setNodeOn(self, homeid, nodeid):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2439, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2439, __pyx_L1_error)
  __pyx_v_self->manager->SetNodeLocation(__pyx_t_1, __pyx_t_2, __pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_location));

  /* "libopenzwave.pyx":2417
 *         self.manager.SetNodeName(homeid, nodeid, str_to_cppstr(name))
 * 
 *     def setNodeLocation(self, homeid, nodeid, str location):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setNodeLocation:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setNodeLocation", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2441
 *         self.manager.SetNodeLocation(homeid, nodeid, str_to_cppstr(location))
 * 
 *     def setNodeOn(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setNodeOn:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_123setNodeOn(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_122setNodeOn[] = "\n.. _setNodeOn:\n\nTurns a node on\n\nThis is a helper method to simplify basic control of a node.  It is the\nequivalent of changing the level reported by the nodes Basic command class to\n255, and will generate a ValueChanged notification from that class.  This\ncommand will turn on the device at its last known level, if supported by the\ndevice, otherwise it will turn it on at 100%.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to be changed.\n:type nodeId: int\n:see: setNodeOff_, setNodeLevel_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_123setNodeOn(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setNodeOn (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setNodeOn", 1, 2, 2, 1); __PYX_ERR(0, 2441, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setNodeOn") < 0)) __PYX_ERR(0, 2441, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setNodeOn", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2441, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setNodeOn", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_122setNodeOn(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_122setNodeOn(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  __Pyx_RefNannySetupContext("setNodeOn", 0);

  /* "libopenzwave.pyx":2461
 *         '''
 * 
 *         self.manager.SetNodeOn(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def setNodeOff(self, homeid, nodeid):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2461, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2461, __pyx_L1_error)
  __pyx_v_self->manager->SetNodeOn(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":2441
 *         self.manager.SetNodeLocation(homeid, nodeid, str_to_cppstr(location))
 * 
 *     def setNodeOn(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setNodeOn:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setNodeOn", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2463
 *         self.manager.SetNodeOn(homeid, nodeid)
 * 
 *     def setNodeOff(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setNodeOff:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_125setNodeOff(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_124setNodeOff[] = "\n.. _setNodeOff:\n\nTurns a node off\n\nThis is a helper method to simplify basic control of a node.  It is the\nequivalent of changing the level reported by the nodes Basic command class to\nzero, and will generate a ValueChanged notification from that class.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to be changed.\n:type nodeId: int\n:see: setNodeOn_, setNodeLevel_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_125setNodeOff(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setNodeOff (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setNodeOff", 1, 2, 2, 1); __PYX_ERR(0, 2463, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setNodeOff") < 0)) __PYX_ERR(0, 2463, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setNodeOff", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2463, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setNodeOff", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_124setNodeOff(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_124setNodeOff(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  __Pyx_RefNannySetupContext("setNodeOff", 0);

  /* "libopenzwave.pyx":2480
 * 
 *         '''
 *         self.manager.SetNodeOff(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def setNodeLevel(self, homeid, nodeid, level):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2480, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2480, __pyx_L1_error)
  __pyx_v_self->manager->SetNodeOff(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":2463
 *         self.manager.SetNodeOn(homeid, nodeid)
 * 
 *     def setNodeOff(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setNodeOff:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setNodeOff", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2482
 *         self.manager.SetNodeOff(homeid, nodeid)
 * 
 *     def setNodeLevel(self, homeid, nodeid, level):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setNodeLevel:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_127setNodeLevel(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_126setNodeLevel[] = "\n.. _setNodeLevel:\n\nSets the basic level of a node\n\nThis is a helper method to simplify basic control of a node.  It is the\nequivalent of changing the value reported by the nodes Basic command class\nand will generate a ValueChanged notification from that class.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to be changed.\n:type nodeId: int\n:param level: The level to set the node.  Valid values are 0-99 and 255.  Zero is off and 99 is fully on.  255 will turn on the device at its last known level (if supported).\n:type level: int\n:see: setNodeOn_, setNodeOff_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_127setNodeLevel(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_level = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setNodeLevel (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_level,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setNodeLevel", 1, 3, 3, 1); __PYX_ERR(0, 2482, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_level)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setNodeLevel", 1, 3, 3, 2); __PYX_ERR(0, 2482, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setNodeLevel") < 0)) __PYX_ERR(0, 2482, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_level = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setNodeLevel", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2482, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setNodeLevel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_126setNodeLevel(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_level);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_126setNodeLevel(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_level) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  uint8_t __pyx_t_3;
  __Pyx_RefNannySetupContext("setNodeLevel", 0);

  /* "libopenzwave.pyx":2501
 * 
 *         '''
 *         self.manager.SetNodeLevel(homeid, nodeid, level)             # <<<<<<<<<<<<<<
 * 
 *     def isNodeInfoReceived(self, homeid, nodeid):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2501, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2501, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_As_uint8_t(__pyx_v_level); if (unlikely((__pyx_t_3 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2501, __pyx_L1_error)
  __pyx_v_self->manager->SetNodeLevel(__pyx_t_1, __pyx_t_2, __pyx_t_3);

  /* "libopenzwave.pyx":2482
 *         self.manager.SetNodeOff(homeid, nodeid)
 * 
 *     def setNodeLevel(self, homeid, nodeid, level):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setNodeLevel:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setNodeLevel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2503
 *         self.manager.SetNodeLevel(homeid, nodeid, level)
 * 
 *     def isNodeInfoReceived(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isNodeInfoReceived:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_129isNodeInfoReceived(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_128isNodeInfoReceived[] = "\n.. _isNodeInfoReceived:\n\nGet whether the node information has been received\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: bool -- True if the node information has been received yet\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_129isNodeInfoReceived(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isNodeInfoReceived (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("isNodeInfoReceived", 1, 2, 2, 1); __PYX_ERR(0, 2503, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "isNodeInfoReceived") < 0)) __PYX_ERR(0, 2503, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("isNodeInfoReceived", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2503, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeInfoReceived", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_128isNodeInfoReceived(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_128isNodeInfoReceived(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("isNodeInfoReceived", 0);

  /* "libopenzwave.pyx":2516
 * 
 *         '''
 *         return self.manager.IsNodeInfoReceived(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def getNodeRole(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2516, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2516, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsNodeInfoReceived(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2516, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2503
 *         self.manager.SetNodeLevel(homeid, nodeid, level)
 * 
 *     def isNodeInfoReceived(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isNodeInfoReceived:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeInfoReceived", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2518
 *         return self.manager.IsNodeInfoReceived(homeid, nodeid)
 * 
 *     def getNodeRole(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeRole:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_131getNodeRole(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_130getNodeRole[] = "\n.. _getNodeRole:\n\nGet the node role as reported in the Z-Wave+ Info report.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: The node version number\n:rtype: int\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_131getNodeRole(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeRole (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeRole", 1, 2, 2, 1); __PYX_ERR(0, 2518, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeRole") < 0)) __PYX_ERR(0, 2518, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeRole", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2518, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeRole", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_130getNodeRole(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_130getNodeRole(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getNodeRole", 0);

  /* "libopenzwave.pyx":2532
 * 
 *         '''
 *         return self.manager.GetNodeRole(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def getNodeRoleString(self, homeId, nodeId):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2532, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2532, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_From_uint8_t(__pyx_v_self->manager->GetNodeRole(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2532, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2518
 *         return self.manager.IsNodeInfoReceived(homeid, nodeid)
 * 
 *     def getNodeRole(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeRole:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeRole", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2534
 *         return self.manager.GetNodeRole(homeid, nodeid)
 * 
 *     def getNodeRoleString(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. getNodeRoleString:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_133getNodeRoleString(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_132getNodeRoleString[] = "\n.. getNodeRoleString:\n\nGet the node role (string) as reported in the Z-Wave+ Info report.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: name of current query stage as a string.\n:rtype: str\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_133getNodeRoleString(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeId = 0;
  PyObject *__pyx_v_nodeId = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeRoleString (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeId,&__pyx_n_s_nodeId,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeId)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeId)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeRoleString", 1, 2, 2, 1); __PYX_ERR(0, 2534, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeRoleString") < 0)) __PYX_ERR(0, 2534, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeId = values[0];
    __pyx_v_nodeId = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeRoleString", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2534, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeRoleString", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_132getNodeRoleString(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeId, __pyx_v_nodeId);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_132getNodeRoleString(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getNodeRoleString", 0);

  /* "libopenzwave.pyx":2548
 * 
 *         '''
 *         cdef string c_string = self.manager.GetNodeRoleString(homeId, nodeId)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeId); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2548, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeId); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2548, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetNodeRoleString(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":2549
 *         '''
 *         cdef string c_string = self.manager.GetNodeRoleString(homeId, nodeId)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getNodeDeviceType(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2549, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2549, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2534
 *         return self.manager.GetNodeRole(homeid, nodeid)
 * 
 *     def getNodeRoleString(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. getNodeRoleString:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeRoleString", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2551
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodeDeviceType(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeDeviceType:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_135getNodeDeviceType(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_134getNodeDeviceType[] = "\n.. _getNodeDeviceType:\n\nGet the node DeviceType as reported in the Z-Wave+ Info report.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: The node version number\n:rtype: int\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_135getNodeDeviceType(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeDeviceType (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeDeviceType", 1, 2, 2, 1); __PYX_ERR(0, 2551, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeDeviceType") < 0)) __PYX_ERR(0, 2551, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeDeviceType", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2551, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeDeviceType", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_134getNodeDeviceType(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_134getNodeDeviceType(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getNodeDeviceType", 0);

  /* "libopenzwave.pyx":2565
 * 
 *         '''
 *         return self.manager.GetNodeDeviceType(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def getNodeDeviceTypeString(self, homeId, nodeId):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2565, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2565, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_From_uint16_t(__pyx_v_self->manager->GetNodeDeviceType(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2565, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2551
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodeDeviceType(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeDeviceType:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeDeviceType", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2567
 *         return self.manager.GetNodeDeviceType(homeid, nodeid)
 * 
 *     def getNodeDeviceTypeString(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. getNodeRoleString:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_137getNodeDeviceTypeString(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_136getNodeDeviceTypeString[] = "\n.. getNodeRoleString:\n\nGet the node DeviceType (string) as reported in the Z-Wave+ Info report.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: name of current query stage as a string.\n:rtype: str\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_137getNodeDeviceTypeString(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeId = 0;
  PyObject *__pyx_v_nodeId = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeDeviceTypeString (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeId,&__pyx_n_s_nodeId,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeId)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeId)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeDeviceTypeString", 1, 2, 2, 1); __PYX_ERR(0, 2567, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeDeviceTypeString") < 0)) __PYX_ERR(0, 2567, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeId = values[0];
    __pyx_v_nodeId = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeDeviceTypeString", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2567, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeDeviceTypeString", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_136getNodeDeviceTypeString(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeId, __pyx_v_nodeId);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_136getNodeDeviceTypeString(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getNodeDeviceTypeString", 0);

  /* "libopenzwave.pyx":2581
 * 
 *         '''
 *         cdef string c_string = self.manager.GetNodeDeviceTypeString(homeId, nodeId)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeId); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2581, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeId); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2581, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetNodeDeviceTypeString(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":2582
 *         '''
 *         cdef string c_string = self.manager.GetNodeDeviceTypeString(homeId, nodeId)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getNodePlusType(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2582, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2582, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2567
 *         return self.manager.GetNodeDeviceType(homeid, nodeid)
 * 
 *     def getNodeDeviceTypeString(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. getNodeRoleString:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeDeviceTypeString", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2584
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodePlusType(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodePlusType:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_139getNodePlusType(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_138getNodePlusType[] = "\n.. _getNodePlusType:\n\nGet the node plus type as reported in the Z-Wave+ Info report.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: The node version number\n:rtype: int\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_139getNodePlusType(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodePlusType (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodePlusType", 1, 2, 2, 1); __PYX_ERR(0, 2584, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodePlusType") < 0)) __PYX_ERR(0, 2584, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodePlusType", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2584, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodePlusType", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_138getNodePlusType(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_138getNodePlusType(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getNodePlusType", 0);

  /* "libopenzwave.pyx":2598
 * 
 *         '''
 *         return self.manager.GetNodePlusType(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def getNodePlusTypeString(self, homeId, nodeId):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2598, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2598, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_From_uint8_t(__pyx_v_self->manager->GetNodePlusType(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2598, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2584
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodePlusType(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodePlusType:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodePlusType", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2600
 *         return self.manager.GetNodePlusType(homeid, nodeid)
 * 
 *     def getNodePlusTypeString(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. getNodePlusTypeString:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_141getNodePlusTypeString(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_140getNodePlusTypeString[] = "\n.. getNodePlusTypeString:\n\nGet the node plus type (string) as reported in the Z-Wave+ Info report.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: name of current query stage as a string.\n:rtype: str\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_141getNodePlusTypeString(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeId = 0;
  PyObject *__pyx_v_nodeId = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodePlusTypeString (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeId,&__pyx_n_s_nodeId,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeId)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeId)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodePlusTypeString", 1, 2, 2, 1); __PYX_ERR(0, 2600, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodePlusTypeString") < 0)) __PYX_ERR(0, 2600, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeId = values[0];
    __pyx_v_nodeId = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodePlusTypeString", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2600, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodePlusTypeString", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_140getNodePlusTypeString(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeId, __pyx_v_nodeId);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_140getNodePlusTypeString(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getNodePlusTypeString", 0);

  /* "libopenzwave.pyx":2614
 * 
 *         '''
 *         cdef string c_string = self.manager.GetNodePlusTypeString(homeId, nodeId)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeId); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2614, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeId); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2614, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetNodePlusTypeString(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":2615
 *         '''
 *         cdef string c_string = self.manager.GetNodePlusTypeString(homeId, nodeId)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def getNodeClassInformation(self, homeid, nodeid, commandClassId, className = None, classVersion = None):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2615, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2615, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2600
 *         return self.manager.GetNodePlusType(homeid, nodeid)
 * 
 *     def getNodePlusTypeString(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. getNodePlusTypeString:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodePlusTypeString", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2617
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodeClassInformation(self, homeid, nodeid, commandClassId, className = None, classVersion = None):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeClassInformation:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_143getNodeClassInformation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_142getNodeClassInformation[] = "\n.. _getNodeClassInformation:\n\nHelper method to return whether a particular class is available in a node\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:param commandClassId: control class to query\n:type commandClassId: int\n:param className: (optional, default=None) specific name of class to query\n:type className: str\n:param classVersion: (optional, default=None) specific class version\n:type classVersion: int\n:return: True if the node does have the class instantiated, will return name & version\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_143getNodeClassInformation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_commandClassId = 0;
  CYTHON_UNUSED PyObject *__pyx_v_className = 0;
  CYTHON_UNUSED PyObject *__pyx_v_classVersion = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeClassInformation (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_commandClassId,&__pyx_n_s_className,&__pyx_n_s_classVersion,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeClassInformation", 0, 3, 5, 1); __PYX_ERR(0, 2617, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_commandClassId)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeClassInformation", 0, 3, 5, 2); __PYX_ERR(0, 2617, __pyx_L3_error)
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_className);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_classVersion);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeClassInformation") < 0)) __PYX_ERR(0, 2617, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_commandClassId = values[2];
    __pyx_v_className = values[3];
    __pyx_v_classVersion = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeClassInformation", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2617, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeClassInformation", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_142getNodeClassInformation(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_commandClassId, __pyx_v_className, __pyx_v_classVersion);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_142getNodeClassInformation(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_commandClassId, CYTHON_UNUSED PyObject *__pyx_v_className, CYTHON_UNUSED PyObject *__pyx_v_classVersion) {
  std::string __pyx_v_oclassName;
  uint8_t __pyx_v_oclassVersion;
  bool __pyx_v_ret;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  uint8_t __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("getNodeClassInformation", 0);
  __Pyx_INCREF(__pyx_v_className);
  __Pyx_INCREF(__pyx_v_classVersion);

  /* "libopenzwave.pyx":2639
 *         cdef string oclassName
 *         cdef uint8_t oclassVersion
 *         ret=self.manager.GetNodeClassInformation(homeid, nodeid, commandClassId, &oclassName, &oclassVersion)             # <<<<<<<<<<<<<<
 *         if ret :
 *             className = oclassName.c_str()
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2639, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2639, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_As_uint8_t(__pyx_v_commandClassId); if (unlikely((__pyx_t_3 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2639, __pyx_L1_error)
  __pyx_v_ret = __pyx_v_self->manager->GetNodeClassInformation(__pyx_t_1, __pyx_t_2, __pyx_t_3, (&__pyx_v_oclassName), (&__pyx_v_oclassVersion));

  /* "libopenzwave.pyx":2640
 *         cdef uint8_t oclassVersion
 *         ret=self.manager.GetNodeClassInformation(homeid, nodeid, commandClassId, &oclassName, &oclassVersion)
 *         if ret :             # <<<<<<<<<<<<<<
 *             className = oclassName.c_str()
 *             classVersion = oclassVersion
 */
  __pyx_t_4 = (__pyx_v_ret != 0);
  if (__pyx_t_4) {

    /* "libopenzwave.pyx":2641
 *         ret=self.manager.GetNodeClassInformation(homeid, nodeid, commandClassId, &oclassName, &oclassVersion)
 *         if ret :
 *             className = oclassName.c_str()             # <<<<<<<<<<<<<<
 *             classVersion = oclassVersion
 *             return ret
 */
    __pyx_t_5 = __Pyx_PyUnicode_FromString(__pyx_v_oclassName.c_str()); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2641, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF_SET(__pyx_v_className, __pyx_t_5);
    __pyx_t_5 = 0;

    /* "libopenzwave.pyx":2642
 *         if ret :
 *             className = oclassName.c_str()
 *             classVersion = oclassVersion             # <<<<<<<<<<<<<<
 *             return ret
 *         else :
 */
    __pyx_t_5 = __Pyx_PyInt_From_uint8_t(__pyx_v_oclassVersion); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2642, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF_SET(__pyx_v_classVersion, __pyx_t_5);
    __pyx_t_5 = 0;

    /* "libopenzwave.pyx":2643
 *             className = oclassName.c_str()
 *             classVersion = oclassVersion
 *             return ret             # <<<<<<<<<<<<<<
 *         else :
 *             return False
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_5 = __Pyx_PyBool_FromLong(__pyx_v_ret); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2643, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_r = __pyx_t_5;
    __pyx_t_5 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2640
 *         cdef uint8_t oclassVersion
 *         ret=self.manager.GetNodeClassInformation(homeid, nodeid, commandClassId, &oclassName, &oclassVersion)
 *         if ret :             # <<<<<<<<<<<<<<
 *             className = oclassName.c_str()
 *             classVersion = oclassVersion
 */
  }

  /* "libopenzwave.pyx":2645
 *             return ret
 *         else :
 *             return False             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":2617
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def getNodeClassInformation(self, homeid, nodeid, commandClassId, className = None, classVersion = None):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNodeClassInformation:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeClassInformation", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_className);
  __Pyx_XDECREF(__pyx_v_classVersion);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2648
 * 
 * 
 *     def isNodeAwake(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isNodeAwake: Get whether the node is awake or asleep
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_145isNodeAwake(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_144isNodeAwake[] = "\n.. _isNodeAwake: Get whether the node is awake or asleep\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the node is awake.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_145isNodeAwake(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeId = 0;
  PyObject *__pyx_v_nodeId = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isNodeAwake (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeId,&__pyx_n_s_nodeId,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeId)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeId)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("isNodeAwake", 1, 2, 2, 1); __PYX_ERR(0, 2648, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "isNodeAwake") < 0)) __PYX_ERR(0, 2648, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeId = values[0];
    __pyx_v_nodeId = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("isNodeAwake", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2648, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeAwake", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_144isNodeAwake(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeId, __pyx_v_nodeId);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_144isNodeAwake(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("isNodeAwake", 0);

  /* "libopenzwave.pyx":2660
 * 
 *         '''
 *         return self.manager.IsNodeAwake(homeId, nodeId)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeId); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2660, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeId); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2660, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsNodeAwake(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2660, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2648
 * 
 * 
 *     def isNodeAwake(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isNodeAwake: Get whether the node is awake or asleep
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeAwake", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2663
 * 
 * 
 *     def isNodeFailed(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. isNodeFailed:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_147isNodeFailed(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_146isNodeFailed[] = "\n.. isNodeFailed:\n\nGet whether the node is working or has failed\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the node has failed and is no longer part of the network.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_147isNodeFailed(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeId = 0;
  PyObject *__pyx_v_nodeId = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isNodeFailed (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeId,&__pyx_n_s_nodeId,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeId)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeId)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("isNodeFailed", 1, 2, 2, 1); __PYX_ERR(0, 2663, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "isNodeFailed") < 0)) __PYX_ERR(0, 2663, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeId = values[0];
    __pyx_v_nodeId = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("isNodeFailed", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2663, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeFailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_146isNodeFailed(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeId, __pyx_v_nodeId);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_146isNodeFailed(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("isNodeFailed", 0);

  /* "libopenzwave.pyx":2677
 * 
 *         '''
 *         return self.manager.IsNodeFailed(homeId, nodeId)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeId); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2677, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeId); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2677, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsNodeFailed(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2677, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2663
 * 
 * 
 *     def isNodeFailed(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. isNodeFailed:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeFailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2680
 * 
 * 
 *     def isNodeZWavePlus(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. isNodeZWavePlus:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_149isNodeZWavePlus(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_148isNodeZWavePlus[] = "\n.. isNodeZWavePlus:\n\nGet whether the node is a ZWave+ one\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the node has failed and is no longer part of the network.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_149isNodeZWavePlus(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeId = 0;
  PyObject *__pyx_v_nodeId = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isNodeZWavePlus (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeId,&__pyx_n_s_nodeId,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeId)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeId)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("isNodeZWavePlus", 1, 2, 2, 1); __PYX_ERR(0, 2680, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "isNodeZWavePlus") < 0)) __PYX_ERR(0, 2680, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeId = values[0];
    __pyx_v_nodeId = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("isNodeZWavePlus", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2680, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeZWavePlus", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_148isNodeZWavePlus(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeId, __pyx_v_nodeId);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_148isNodeZWavePlus(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("isNodeZWavePlus", 0);

  /* "libopenzwave.pyx":2694
 * 
 *         '''
 *         return self.manager.IsNodeZWavePlus(homeId, nodeId)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeId); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2694, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeId); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2694, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsNodeZWavePlus(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2694, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2680
 * 
 * 
 *     def isNodeZWavePlus(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. isNodeZWavePlus:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.isNodeZWavePlus", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2697
 * 
 * 
 *     def getNodeQueryStage(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. getNodeQueryStage: Get whether the node's query stage as a string
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_151getNodeQueryStage(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_150getNodeQueryStage[] = "\n.. getNodeQueryStage: Get whether the node's query stage as a string\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: name of current query stage as a string.\n:rtype: str\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_151getNodeQueryStage(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeId = 0;
  PyObject *__pyx_v_nodeId = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeQueryStage (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeId,&__pyx_n_s_nodeId,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeId)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeId)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNodeQueryStage", 1, 2, 2, 1); __PYX_ERR(0, 2697, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNodeQueryStage") < 0)) __PYX_ERR(0, 2697, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeId = values[0];
    __pyx_v_nodeId = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNodeQueryStage", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2697, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeQueryStage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_150getNodeQueryStage(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeId, __pyx_v_nodeId);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_150getNodeQueryStage(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_nodeId) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getNodeQueryStage", 0);

  /* "libopenzwave.pyx":2709
 * 
 *         '''
 *         cdef string c_string = self.manager.GetNodeQueryStage(homeId, nodeId)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeId); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2709, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeId); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2709, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetNodeQueryStage(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":2710
 *         '''
 *         cdef string c_string = self.manager.GetNodeQueryStage(homeId, nodeId)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2710, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2710, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2697
 * 
 * 
 *     def getNodeQueryStage(self, homeId, nodeId):             # <<<<<<<<<<<<<<
 *         '''
 * .. getNodeQueryStage: Get whether the node's query stage as a string
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeQueryStage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2713
 * 
 * 
 *     def getNodeQueryStageCode(self, queryStage):             # <<<<<<<<<<<<<<
 *         '''
 * .. getNodeQueryStageCode: Get code value from a query stage description
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_153getNodeQueryStageCode(PyObject *__pyx_v_self, PyObject *__pyx_v_queryStage); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_152getNodeQueryStageCode[] = "\n.. getNodeQueryStageCode: Get code value from a query stage description\n\n:param queryStage: The query stage description.\n:type queryStage: str\n:return: code value.\n:rtype: int\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_153getNodeQueryStageCode(PyObject *__pyx_v_self, PyObject *__pyx_v_queryStage) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNodeQueryStageCode (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_152getNodeQueryStageCode(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_queryStage));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_152getNodeQueryStageCode(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_queryStage) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("getNodeQueryStageCode", 0);

  /* "libopenzwave.pyx":2723
 * 
 *         '''
 *         if queryStage == "ProtocolInfo":             # <<<<<<<<<<<<<<
 *             # Retrieve protocol information
 *             # QueryStage_ProtocolInfo
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_ProtocolInfo, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2723, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2726
 *             # Retrieve protocol information
 *             # QueryStage_ProtocolInfo
 *             return 0             # <<<<<<<<<<<<<<
 *         elif queryStage == "Probe":
 *             # Ping device to see if alive
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_0);
    __pyx_r = __pyx_int_0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2723
 * 
 *         '''
 *         if queryStage == "ProtocolInfo":             # <<<<<<<<<<<<<<
 *             # Retrieve protocol information
 *             # QueryStage_ProtocolInfo
 */
  }

  /* "libopenzwave.pyx":2727
 *             # QueryStage_ProtocolInfo
 *             return 0
 *         elif queryStage == "Probe":             # <<<<<<<<<<<<<<
 *             # Ping device to see if alive
 *             # QueryStage_Probe
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_Probe, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2727, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2730
 *             # Ping device to see if alive
 *             # QueryStage_Probe
 *             return 1             # <<<<<<<<<<<<<<
 *         elif queryStage == "WakeUp":
 *             # Start wake up process if a sleeping node
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_1);
    __pyx_r = __pyx_int_1;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2727
 *             # QueryStage_ProtocolInfo
 *             return 0
 *         elif queryStage == "Probe":             # <<<<<<<<<<<<<<
 *             # Ping device to see if alive
 *             # QueryStage_Probe
 */
  }

  /* "libopenzwave.pyx":2731
 *             # QueryStage_Probe
 *             return 1
 *         elif queryStage == "WakeUp":             # <<<<<<<<<<<<<<
 *             # Start wake up process if a sleeping node
 *             # QueryStage_WakeUp
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_WakeUp, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2731, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2734
 *             # Start wake up process if a sleeping node
 *             # QueryStage_WakeUp
 *             return 2             # <<<<<<<<<<<<<<
 *         elif queryStage == "ManufacturerSpecific1":
 *             # Retrieve manufacturer name and product ids if ProtocolInfo lets us
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_2);
    __pyx_r = __pyx_int_2;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2731
 *             # QueryStage_Probe
 *             return 1
 *         elif queryStage == "WakeUp":             # <<<<<<<<<<<<<<
 *             # Start wake up process if a sleeping node
 *             # QueryStage_WakeUp
 */
  }

  /* "libopenzwave.pyx":2735
 *             # QueryStage_WakeUp
 *             return 2
 *         elif queryStage == "ManufacturerSpecific1":             # <<<<<<<<<<<<<<
 *             # Retrieve manufacturer name and product ids if ProtocolInfo lets us
 *             # QueryStage_ManufacturerSpecific1
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_ManufacturerSpecific1, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2735, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2738
 *             # Retrieve manufacturer name and product ids if ProtocolInfo lets us
 *             # QueryStage_ManufacturerSpecific1
 *             return 3             # <<<<<<<<<<<<<<
 *         elif queryStage == "NodeInfo":
 *             # Retrieve info about supported, controlled command classes
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_3);
    __pyx_r = __pyx_int_3;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2735
 *             # QueryStage_WakeUp
 *             return 2
 *         elif queryStage == "ManufacturerSpecific1":             # <<<<<<<<<<<<<<
 *             # Retrieve manufacturer name and product ids if ProtocolInfo lets us
 *             # QueryStage_ManufacturerSpecific1
 */
  }

  /* "libopenzwave.pyx":2739
 *             # QueryStage_ManufacturerSpecific1
 *             return 3
 *         elif queryStage == "NodeInfo":             # <<<<<<<<<<<<<<
 *             # Retrieve info about supported, controlled command classes
 *             # QueryStage_NodeInfo
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_NodeInfo, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2739, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2742
 *             # Retrieve info about supported, controlled command classes
 *             # QueryStage_NodeInfo
 *             return 4             # <<<<<<<<<<<<<<
 *         elif queryStage == "ManufacturerSpecific2":
 *             # Retrieve manufacturer name and product ids
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_4);
    __pyx_r = __pyx_int_4;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2739
 *             # QueryStage_ManufacturerSpecific1
 *             return 3
 *         elif queryStage == "NodeInfo":             # <<<<<<<<<<<<<<
 *             # Retrieve info about supported, controlled command classes
 *             # QueryStage_NodeInfo
 */
  }

  /* "libopenzwave.pyx":2743
 *             # QueryStage_NodeInfo
 *             return 4
 *         elif queryStage == "ManufacturerSpecific2":             # <<<<<<<<<<<<<<
 *             # Retrieve manufacturer name and product ids
 *             # QueryStage_ManufacturerSpecific2
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_ManufacturerSpecific2, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2743, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2746
 *             # Retrieve manufacturer name and product ids
 *             # QueryStage_ManufacturerSpecific2
 *             return 5             # <<<<<<<<<<<<<<
 *         elif queryStage == "Versions":
 *             # Retrieve version information
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_5);
    __pyx_r = __pyx_int_5;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2743
 *             # QueryStage_NodeInfo
 *             return 4
 *         elif queryStage == "ManufacturerSpecific2":             # <<<<<<<<<<<<<<
 *             # Retrieve manufacturer name and product ids
 *             # QueryStage_ManufacturerSpecific2
 */
  }

  /* "libopenzwave.pyx":2747
 *             # QueryStage_ManufacturerSpecific2
 *             return 5
 *         elif queryStage == "Versions":             # <<<<<<<<<<<<<<
 *             # Retrieve version information
 *             # QueryStage_Versions
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_Versions, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2747, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2750
 *             # Retrieve version information
 *             # QueryStage_Versions
 *             return 6             # <<<<<<<<<<<<<<
 *         elif queryStage == "Instances":
 *             # Retrieve information about multiple command class instances
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_6);
    __pyx_r = __pyx_int_6;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2747
 *             # QueryStage_ManufacturerSpecific2
 *             return 5
 *         elif queryStage == "Versions":             # <<<<<<<<<<<<<<
 *             # Retrieve version information
 *             # QueryStage_Versions
 */
  }

  /* "libopenzwave.pyx":2751
 *             # QueryStage_Versions
 *             return 6
 *         elif queryStage == "Instances":             # <<<<<<<<<<<<<<
 *             # Retrieve information about multiple command class instances
 *             # QueryStage_Instances
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_Instances, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2751, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2754
 *             # Retrieve information about multiple command class instances
 *             # QueryStage_Instances
 *             return 7             # <<<<<<<<<<<<<<
 *         elif queryStage == "Static":
 *             # Retrieve static information (doesn't change)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_7);
    __pyx_r = __pyx_int_7;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2751
 *             # QueryStage_Versions
 *             return 6
 *         elif queryStage == "Instances":             # <<<<<<<<<<<<<<
 *             # Retrieve information about multiple command class instances
 *             # QueryStage_Instances
 */
  }

  /* "libopenzwave.pyx":2755
 *             # QueryStage_Instances
 *             return 7
 *         elif queryStage == "Static":             # <<<<<<<<<<<<<<
 *             # Retrieve static information (doesn't change)
 *             # QueryStage_Static
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_Static, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2755, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2758
 *             # Retrieve static information (doesn't change)
 *             # QueryStage_Static
 *             return 8             # <<<<<<<<<<<<<<
 *         elif queryStage == "Probe1":
 *             # Ping a device upon starting with configuration
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_8);
    __pyx_r = __pyx_int_8;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2755
 *             # QueryStage_Instances
 *             return 7
 *         elif queryStage == "Static":             # <<<<<<<<<<<<<<
 *             # Retrieve static information (doesn't change)
 *             # QueryStage_Static
 */
  }

  /* "libopenzwave.pyx":2759
 *             # QueryStage_Static
 *             return 8
 *         elif queryStage == "Probe1":             # <<<<<<<<<<<<<<
 *             # Ping a device upon starting with configuration
 *             # QueryStage_Probe1
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_Probe1, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2759, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2762
 *             # Ping a device upon starting with configuration
 *             # QueryStage_Probe1
 *             return 9             # <<<<<<<<<<<<<<
 *         elif queryStage == "Associations":
 *             # Retrieve information about associations
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_9);
    __pyx_r = __pyx_int_9;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2759
 *             # QueryStage_Static
 *             return 8
 *         elif queryStage == "Probe1":             # <<<<<<<<<<<<<<
 *             # Ping a device upon starting with configuration
 *             # QueryStage_Probe1
 */
  }

  /* "libopenzwave.pyx":2763
 *             # QueryStage_Probe1
 *             return 9
 *         elif queryStage == "Associations":             # <<<<<<<<<<<<<<
 *             # Retrieve information about associations
 *             # QueryStage_Associations
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_Associations, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2763, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2766
 *             # Retrieve information about associations
 *             # QueryStage_Associations
 *             return 10             # <<<<<<<<<<<<<<
 *         elif queryStage == "Neighbors":
 *             # Retrieve node neighbor list
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_10);
    __pyx_r = __pyx_int_10;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2763
 *             # QueryStage_Probe1
 *             return 9
 *         elif queryStage == "Associations":             # <<<<<<<<<<<<<<
 *             # Retrieve information about associations
 *             # QueryStage_Associations
 */
  }

  /* "libopenzwave.pyx":2767
 *             # QueryStage_Associations
 *             return 10
 *         elif queryStage == "Neighbors":             # <<<<<<<<<<<<<<
 *             # Retrieve node neighbor list
 *             # QueryStage_Neighbors
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_Neighbors, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2767, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2770
 *             # Retrieve node neighbor list
 *             # QueryStage_Neighbors
 *             return 11             # <<<<<<<<<<<<<<
 *         elif queryStage == "Session":
 *             # Retrieve session information (changes infrequently)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_11);
    __pyx_r = __pyx_int_11;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2767
 *             # QueryStage_Associations
 *             return 10
 *         elif queryStage == "Neighbors":             # <<<<<<<<<<<<<<
 *             # Retrieve node neighbor list
 *             # QueryStage_Neighbors
 */
  }

  /* "libopenzwave.pyx":2771
 *             # QueryStage_Neighbors
 *             return 11
 *         elif queryStage == "Session":             # <<<<<<<<<<<<<<
 *             # Retrieve session information (changes infrequently)
 *             # QueryStage_Session
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_Session, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2771, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2774
 *             # Retrieve session information (changes infrequently)
 *             # QueryStage_Session
 *             return 12             # <<<<<<<<<<<<<<
 *         elif queryStage == "Dynamic":
 *             # Retrieve dynamic information (changes frequently)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_12);
    __pyx_r = __pyx_int_12;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2771
 *             # QueryStage_Neighbors
 *             return 11
 *         elif queryStage == "Session":             # <<<<<<<<<<<<<<
 *             # Retrieve session information (changes infrequently)
 *             # QueryStage_Session
 */
  }

  /* "libopenzwave.pyx":2775
 *             # QueryStage_Session
 *             return 12
 *         elif queryStage == "Dynamic":             # <<<<<<<<<<<<<<
 *             # Retrieve dynamic information (changes frequently)
 *             # QueryStage_Dynamic
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_Dynamic, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2775, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2778
 *             # Retrieve dynamic information (changes frequently)
 *             # QueryStage_Dynamic
 *             return 13             # <<<<<<<<<<<<<<
 *         elif queryStage == "Configuration":
 *             # Retrieve configurable parameter information (only done on request)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_13);
    __pyx_r = __pyx_int_13;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2775
 *             # QueryStage_Session
 *             return 12
 *         elif queryStage == "Dynamic":             # <<<<<<<<<<<<<<
 *             # Retrieve dynamic information (changes frequently)
 *             # QueryStage_Dynamic
 */
  }

  /* "libopenzwave.pyx":2779
 *             # QueryStage_Dynamic
 *             return 13
 *         elif queryStage == "Configuration":             # <<<<<<<<<<<<<<
 *             # Retrieve configurable parameter information (only done on request)
 *             # QueryStage_Configuration
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_Configuration, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2779, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2782
 *             # Retrieve configurable parameter information (only done on request)
 *             # QueryStage_Configuration
 *             return 14             # <<<<<<<<<<<<<<
 *         elif queryStage == "Complete":
 *             # Query process is completed for this node
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_14);
    __pyx_r = __pyx_int_14;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2779
 *             # QueryStage_Dynamic
 *             return 13
 *         elif queryStage == "Configuration":             # <<<<<<<<<<<<<<
 *             # Retrieve configurable parameter information (only done on request)
 *             # QueryStage_Configuration
 */
  }

  /* "libopenzwave.pyx":2783
 *             # QueryStage_Configuration
 *             return 14
 *         elif queryStage == "Complete":             # <<<<<<<<<<<<<<
 *             # Query process is completed for this node
 *             # QueryStage_Complete
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_Complete, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2783, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2786
 *             # Query process is completed for this node
 *             # QueryStage_Complete
 *             return 15             # <<<<<<<<<<<<<<
 *         elif queryStage == "None":
 *             # Query process hasn't started for this node
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_15);
    __pyx_r = __pyx_int_15;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2783
 *             # QueryStage_Configuration
 *             return 14
 *         elif queryStage == "Complete":             # <<<<<<<<<<<<<<
 *             # Query process is completed for this node
 *             # QueryStage_Complete
 */
  }

  /* "libopenzwave.pyx":2787
 *             # QueryStage_Complete
 *             return 15
 *         elif queryStage == "None":             # <<<<<<<<<<<<<<
 *             # Query process hasn't started for this node
 *             # QueryStage_None
 */
  __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_v_queryStage, __pyx_n_s_None, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2787, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":2790
 *             # Query process hasn't started for this node
 *             # QueryStage_None
 *             return 16             # <<<<<<<<<<<<<<
 *         return None
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_16);
    __pyx_r = __pyx_int_16;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2787
 *             # QueryStage_Complete
 *             return 15
 *         elif queryStage == "None":             # <<<<<<<<<<<<<<
 *             # Query process hasn't started for this node
 *             # QueryStage_None
 */
  }

  /* "libopenzwave.pyx":2791
 *             # QueryStage_None
 *             return 16
 *         return None             # <<<<<<<<<<<<<<
 * 
 * #
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_None);
  __pyx_r = Py_None;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2713
 * 
 * 
 *     def getNodeQueryStageCode(self, queryStage):             # <<<<<<<<<<<<<<
 *         '''
 * .. getNodeQueryStageCode: Get code value from a query stage description
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNodeQueryStageCode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2806
 * #        bool SetValueListSelection(ValueID& valueid, string selecteditem)
 * 
 *     def setValue(self, id, value):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setValue:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_155setValue(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_154setValue[] = "\n.. _setValue:\n\nSets the value of a device valueid.\nDue to the possibility of a device being asleep, the command is assumed to suceeed, and the value\nheld by the node is updated directly.  This will be reverted by a future status message from the device\nif the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.\n\n:param id: The ID of a value.\n:type id: int\n:param value: The value to set.\n:type value: int\n:return: An integer representing the result of the operation  0 : The C method fails, 1 : The C method succeed, 2 : Can't find id in the map\n:rtype: int\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_155setValue(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_id = 0;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setValue (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_value,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setValue", 1, 2, 2, 1); __PYX_ERR(0, 2806, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setValue") < 0)) __PYX_ERR(0, 2806, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_id = values[0];
    __pyx_v_value = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setValue", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2806, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setValue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_154setValue(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_id, __pyx_v_value);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_154setValue(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_value) {
  float __pyx_v_type_float;
  bool __pyx_v_type_bool;
  uint8_t __pyx_v_type_byte;
  int32_t __pyx_v_type_int;
  int16_t __pyx_v_type_short;
  std::string __pyx_v_type_string;
  uint8_t *__pyx_v_type_raw;
  long __pyx_v_ret;
  PyObject *__pyx_v_datatype = NULL;
  bool __pyx_v_cret;
  Py_ssize_t __pyx_v_x;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  bool __pyx_t_7;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_8;
  long __pyx_t_9;
  uint8_t __pyx_t_10;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_11;
  Py_ssize_t __pyx_t_12;
  Py_ssize_t __pyx_t_13;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_14;
  float __pyx_t_15;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_16;
  int32_t __pyx_t_17;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_18;
  int16_t __pyx_t_19;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_20;
  char *__pyx_t_21;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_22;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_23;
  int __pyx_t_24;
  PyObject *__pyx_t_25 = NULL;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_26;
  PyObject *__pyx_t_27 = NULL;
  __Pyx_RefNannySetupContext("setValue", 0);

  /* "libopenzwave.pyx":2830
 *         cdef string type_string
 *         cdef uint8_t* type_raw
 *         ret = 2             # <<<<<<<<<<<<<<
 *         if values_map.find(id) != values_map.end():
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 */
  __pyx_v_ret = 2;

  /* "libopenzwave.pyx":2831
 *         cdef uint8_t* type_raw
 *         ret = 2
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2831, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":2832
 *         ret = 2
 *         if values_map.find(id) != values_map.end():
 *             datatype = PyValueTypes[values_map.at(id).GetType()]             # <<<<<<<<<<<<<<
 *             if datatype == "Bool":
 *                 type_bool = value
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyValueTypes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2832, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2832, __pyx_L1_error)
    try {
      __pyx_t_4 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 2832, __pyx_L1_error)
    }
    __pyx_t_5 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueType(__pyx_t_4->GetType()); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2832, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = PyObject_GetItem(__pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2832, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_v_datatype = __pyx_t_6;
    __pyx_t_6 = 0;

    /* "libopenzwave.pyx":2833
 *         if values_map.find(id) != values_map.end():
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":             # <<<<<<<<<<<<<<
 *                 type_bool = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_bool)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Bool, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2833, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":2834
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":
 *                 type_bool = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetValue(values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_7 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2834, __pyx_L1_error)
      __pyx_v_type_bool = __pyx_t_7;

      /* "libopenzwave.pyx":2835
 *             if datatype == "Bool":
 *                 type_bool = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_bool)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Byte":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2835, __pyx_L1_error)
      try {
        __pyx_t_8 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 2835, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetValue(__pyx_t_8, __pyx_v_type_bool);

      /* "libopenzwave.pyx":2836
 *                 type_bool = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Byte":
 *                 type_byte = value
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":2833
 *         if values_map.find(id) != values_map.end():
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":             # <<<<<<<<<<<<<<
 *                 type_bool = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_bool)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":2837
 *                 cret = self.manager.SetValue(values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Byte":             # <<<<<<<<<<<<<<
 *                 type_byte = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_byte)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Byte, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2837, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":2838
 *                 ret = 1 if cret else 0
 *             elif datatype == "Byte":
 *                 type_byte = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetValue(values_map.at(id), type_byte)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_10 = __Pyx_PyInt_As_uint8_t(__pyx_v_value); if (unlikely((__pyx_t_10 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2838, __pyx_L1_error)
      __pyx_v_type_byte = __pyx_t_10;

      /* "libopenzwave.pyx":2839
 *             elif datatype == "Byte":
 *                 type_byte = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_byte)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Raw":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2839, __pyx_L1_error)
      try {
        __pyx_t_11 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 2839, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetValue(__pyx_t_11, __pyx_v_type_byte);

      /* "libopenzwave.pyx":2840
 *                 type_byte = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_byte)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Raw":
 *                 type_raw = <uint8_t*> malloc(len(value)*sizeof(uint8_t))
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":2837
 *                 cret = self.manager.SetValue(values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Byte":             # <<<<<<<<<<<<<<
 *                 type_byte = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_byte)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":2841
 *                 cret = self.manager.SetValue(values_map.at(id), type_byte)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Raw":             # <<<<<<<<<<<<<<
 *                 type_raw = <uint8_t*> malloc(len(value)*sizeof(uint8_t))
 *                 for x in range(0, len(value)):
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Raw, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2841, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":2842
 *                 ret = 1 if cret else 0
 *             elif datatype == "Raw":
 *                 type_raw = <uint8_t*> malloc(len(value)*sizeof(uint8_t))             # <<<<<<<<<<<<<<
 *                 for x in range(0, len(value)):
 *                     #print value[x]
 */
      __pyx_t_12 = PyObject_Length(__pyx_v_value); if (unlikely(__pyx_t_12 == -1)) __PYX_ERR(0, 2842, __pyx_L1_error)
      __pyx_v_type_raw = ((uint8_t *)malloc((__pyx_t_12 * (sizeof(uint8_t)))));

      /* "libopenzwave.pyx":2843
 *             elif datatype == "Raw":
 *                 type_raw = <uint8_t*> malloc(len(value)*sizeof(uint8_t))
 *                 for x in range(0, len(value)):             # <<<<<<<<<<<<<<
 *                     #print value[x]
 *                     type_raw[x] = ord(value[x])
 */
      __pyx_t_12 = PyObject_Length(__pyx_v_value); if (unlikely(__pyx_t_12 == -1)) __PYX_ERR(0, 2843, __pyx_L1_error)
      for (__pyx_t_13 = 0; __pyx_t_13 < __pyx_t_12; __pyx_t_13+=1) {
        __pyx_v_x = __pyx_t_13;

        /* "libopenzwave.pyx":2845
 *                 for x in range(0, len(value)):
 *                     #print value[x]
 *                     type_raw[x] = ord(value[x])             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetValue(values_map.at(id), type_raw, len(value))
 *                 ret = 1 if cret else 0
 */
        __pyx_t_6 = __Pyx_GetItemInt(__pyx_v_value, __pyx_v_x, Py_ssize_t, 1, PyInt_FromSsize_t, 0, 1, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2845, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_9 = __Pyx_PyObject_Ord(__pyx_t_6); if (unlikely(__pyx_t_9 == (long)(Py_UCS4)-1)) __PYX_ERR(0, 2845, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        (__pyx_v_type_raw[__pyx_v_x]) = __pyx_t_9;
      }

      /* "libopenzwave.pyx":2846
 *                     #print value[x]
 *                     type_raw[x] = ord(value[x])
 *                 cret = self.manager.SetValue(values_map.at(id), type_raw, len(value))             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *                 free(type_raw)
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2846, __pyx_L1_error)
      try {
        __pyx_t_14 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 2846, __pyx_L1_error)
      }
      __pyx_t_12 = PyObject_Length(__pyx_v_value); if (unlikely(__pyx_t_12 == -1)) __PYX_ERR(0, 2846, __pyx_L1_error)
      __pyx_v_cret = __pyx_v_self->manager->SetValue(__pyx_t_14, __pyx_v_type_raw, __pyx_t_12);

      /* "libopenzwave.pyx":2847
 *                     type_raw[x] = ord(value[x])
 *                 cret = self.manager.SetValue(values_map.at(id), type_raw, len(value))
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *                 free(type_raw)
 *             elif datatype == "Decimal":
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":2848
 *                 cret = self.manager.SetValue(values_map.at(id), type_raw, len(value))
 *                 ret = 1 if cret else 0
 *                 free(type_raw)             # <<<<<<<<<<<<<<
 *             elif datatype == "Decimal":
 *                 type_float = value
 */
      free(__pyx_v_type_raw);

      /* "libopenzwave.pyx":2841
 *                 cret = self.manager.SetValue(values_map.at(id), type_byte)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Raw":             # <<<<<<<<<<<<<<
 *                 type_raw = <uint8_t*> malloc(len(value)*sizeof(uint8_t))
 *                 for x in range(0, len(value)):
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":2849
 *                 ret = 1 if cret else 0
 *                 free(type_raw)
 *             elif datatype == "Decimal":             # <<<<<<<<<<<<<<
 *                 type_float = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_float)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Decimal, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2849, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":2850
 *                 free(type_raw)
 *             elif datatype == "Decimal":
 *                 type_float = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetValue(values_map.at(id), type_float)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_15 = __pyx_PyFloat_AsFloat(__pyx_v_value); if (unlikely((__pyx_t_15 == (float)-1) && PyErr_Occurred())) __PYX_ERR(0, 2850, __pyx_L1_error)
      __pyx_v_type_float = __pyx_t_15;

      /* "libopenzwave.pyx":2851
 *             elif datatype == "Decimal":
 *                 type_float = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_float)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Int":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2851, __pyx_L1_error)
      try {
        __pyx_t_16 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 2851, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetValue(__pyx_t_16, __pyx_v_type_float);

      /* "libopenzwave.pyx":2852
 *                 type_float = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_float)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Int":
 *                 type_int = value
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":2849
 *                 ret = 1 if cret else 0
 *                 free(type_raw)
 *             elif datatype == "Decimal":             # <<<<<<<<<<<<<<
 *                 type_float = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_float)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":2853
 *                 cret = self.manager.SetValue(values_map.at(id), type_float)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Int":             # <<<<<<<<<<<<<<
 *                 type_int = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_int)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Int, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2853, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":2854
 *                 ret = 1 if cret else 0
 *             elif datatype == "Int":
 *                 type_int = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetValue(values_map.at(id), type_int)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_17 = __Pyx_PyInt_As_int32_t(__pyx_v_value); if (unlikely((__pyx_t_17 == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2854, __pyx_L1_error)
      __pyx_v_type_int = __pyx_t_17;

      /* "libopenzwave.pyx":2855
 *             elif datatype == "Int":
 *                 type_int = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_int)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Short":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2855, __pyx_L1_error)
      try {
        __pyx_t_18 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 2855, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetValue(__pyx_t_18, __pyx_v_type_int);

      /* "libopenzwave.pyx":2856
 *                 type_int = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_int)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Short":
 *                 type_short = value
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":2853
 *                 cret = self.manager.SetValue(values_map.at(id), type_float)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Int":             # <<<<<<<<<<<<<<
 *                 type_int = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_int)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":2857
 *                 cret = self.manager.SetValue(values_map.at(id), type_int)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Short":             # <<<<<<<<<<<<<<
 *                 type_short = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_short)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Short, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2857, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":2858
 *                 ret = 1 if cret else 0
 *             elif datatype == "Short":
 *                 type_short = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetValue(values_map.at(id), type_short)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_19 = __Pyx_PyInt_As_int16_t(__pyx_v_value); if (unlikely((__pyx_t_19 == ((int16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2858, __pyx_L1_error)
      __pyx_v_type_short = __pyx_t_19;

      /* "libopenzwave.pyx":2859
 *             elif datatype == "Short":
 *                 type_short = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_short)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "String":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2859, __pyx_L1_error)
      try {
        __pyx_t_20 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 2859, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetValue(__pyx_t_20, __pyx_v_type_short);

      /* "libopenzwave.pyx":2860
 *                 type_short = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_short)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "String":
 *                 if six.PY3:
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":2857
 *                 cret = self.manager.SetValue(values_map.at(id), type_int)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Short":             # <<<<<<<<<<<<<<
 *                 type_short = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_short)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":2861
 *                 cret = self.manager.SetValue(values_map.at(id), type_short)
 *                 ret = 1 if cret else 0
 *             elif datatype == "String":             # <<<<<<<<<<<<<<
 *                 if six.PY3:
 *                     type_string = str_to_cppstr(value)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_String, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2861, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":2862
 *                 ret = 1 if cret else 0
 *             elif datatype == "String":
 *                 if six.PY3:             # <<<<<<<<<<<<<<
 *                     type_string = str_to_cppstr(value)
 *                 else:
 */
      __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_six); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2862, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_PY3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2862, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2862, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_2) {

        /* "libopenzwave.pyx":2863
 *             elif datatype == "String":
 *                 if six.PY3:
 *                     type_string = str_to_cppstr(value)             # <<<<<<<<<<<<<<
 *                 else:
 *                     type_string = str_to_cppstr(string(value))
 */
        if (!(likely(PyString_CheckExact(__pyx_v_value))||((__pyx_v_value) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_v_value)->tp_name), 0))) __PYX_ERR(0, 2863, __pyx_L1_error)
        __pyx_v_type_string = __pyx_f_12libopenzwave_str_to_cppstr(((PyObject*)__pyx_v_value));

        /* "libopenzwave.pyx":2862
 *                 ret = 1 if cret else 0
 *             elif datatype == "String":
 *                 if six.PY3:             # <<<<<<<<<<<<<<
 *                     type_string = str_to_cppstr(value)
 *                 else:
 */
        goto __pyx_L7;
      }

      /* "libopenzwave.pyx":2865
 *                     type_string = str_to_cppstr(value)
 *                 else:
 *                     type_string = str_to_cppstr(string(value))             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetValue(values_map.at(id), type_string)
 *                 ret = 1 if cret else 0
 */
      /*else*/ {
        __pyx_t_21 = __Pyx_PyObject_AsString(__pyx_v_value); if (unlikely((!__pyx_t_21) && PyErr_Occurred())) __PYX_ERR(0, 2865, __pyx_L1_error)
        __pyx_t_5 = __pyx_convert_PyStr_string_to_py_std__in_string(std::string(__pyx_t_21)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2865, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __pyx_v_type_string = __pyx_f_12libopenzwave_str_to_cppstr(((PyObject*)__pyx_t_5));
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      }
      __pyx_L7:;

      /* "libopenzwave.pyx":2866
 *                 else:
 *                     type_string = str_to_cppstr(string(value))
 *                 cret = self.manager.SetValue(values_map.at(id), type_string)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Button":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2866, __pyx_L1_error)
      try {
        __pyx_t_22 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 2866, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetValue(__pyx_t_22, __pyx_v_type_string);

      /* "libopenzwave.pyx":2867
 *                     type_string = str_to_cppstr(string(value))
 *                 cret = self.manager.SetValue(values_map.at(id), type_string)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Button":
 *                 type_bool = value
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":2861
 *                 cret = self.manager.SetValue(values_map.at(id), type_short)
 *                 ret = 1 if cret else 0
 *             elif datatype == "String":             # <<<<<<<<<<<<<<
 *                 if six.PY3:
 *                     type_string = str_to_cppstr(value)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":2868
 *                 cret = self.manager.SetValue(values_map.at(id), type_string)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Button":             # <<<<<<<<<<<<<<
 *                 type_bool = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_bool)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Button, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2868, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":2869
 *                 ret = 1 if cret else 0
 *             elif datatype == "Button":
 *                 type_bool = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetValue(values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_7 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2869, __pyx_L1_error)
      __pyx_v_type_bool = __pyx_t_7;

      /* "libopenzwave.pyx":2870
 *             elif datatype == "Button":
 *                 type_bool = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_bool)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "List":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2870, __pyx_L1_error)
      try {
        __pyx_t_23 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 2870, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetValue(__pyx_t_23, __pyx_v_type_bool);

      /* "libopenzwave.pyx":2871
 *                 type_bool = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "List":
 *                 logger.debug("SetValueListSelection %s", value)
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":2868
 *                 cret = self.manager.SetValue(values_map.at(id), type_string)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Button":             # <<<<<<<<<<<<<<
 *                 type_bool = value
 *                 cret = self.manager.SetValue(values_map.at(id), type_bool)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":2872
 *                 cret = self.manager.SetValue(values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 *             elif datatype == "List":             # <<<<<<<<<<<<<<
 *                 logger.debug("SetValueListSelection %s", value)
 *                 if six.PY3:
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_List, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2872, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":2873
 *                 ret = 1 if cret else 0
 *             elif datatype == "List":
 *                 logger.debug("SetValueListSelection %s", value)             # <<<<<<<<<<<<<<
 *                 if six.PY3:
 *                     type_string = str_to_cppstr(value)
 */
      __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2873, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_debug); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2873, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_6 = NULL;
      __pyx_t_24 = 0;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_6)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_6);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
          __pyx_t_24 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_kp_s_SetValueListSelection_s, __pyx_v_value};
        __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_24, 2+__pyx_t_24); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2873, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_GOTREF(__pyx_t_5);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_kp_s_SetValueListSelection_s, __pyx_v_value};
        __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_24, 2+__pyx_t_24); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2873, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_GOTREF(__pyx_t_5);
      } else
      #endif
      {
        __pyx_t_25 = PyTuple_New(2+__pyx_t_24); if (unlikely(!__pyx_t_25)) __PYX_ERR(0, 2873, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_25);
        if (__pyx_t_6) {
          __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_25, 0, __pyx_t_6); __pyx_t_6 = NULL;
        }
        __Pyx_INCREF(__pyx_kp_s_SetValueListSelection_s);
        __Pyx_GIVEREF(__pyx_kp_s_SetValueListSelection_s);
        PyTuple_SET_ITEM(__pyx_t_25, 0+__pyx_t_24, __pyx_kp_s_SetValueListSelection_s);
        __Pyx_INCREF(__pyx_v_value);
        __Pyx_GIVEREF(__pyx_v_value);
        PyTuple_SET_ITEM(__pyx_t_25, 1+__pyx_t_24, __pyx_v_value);
        __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_25, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2873, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_25); __pyx_t_25 = 0;
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

      /* "libopenzwave.pyx":2874
 *             elif datatype == "List":
 *                 logger.debug("SetValueListSelection %s", value)
 *                 if six.PY3:             # <<<<<<<<<<<<<<
 *                     type_string = str_to_cppstr(value)
 *                 else:
 */
      __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_six); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2874, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_PY3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2874, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2874, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_2) {

        /* "libopenzwave.pyx":2875
 *                 logger.debug("SetValueListSelection %s", value)
 *                 if six.PY3:
 *                     type_string = str_to_cppstr(value)             # <<<<<<<<<<<<<<
 *                 else:
 *                     type_string = str_to_cppstr(string(value))
 */
        if (!(likely(PyString_CheckExact(__pyx_v_value))||((__pyx_v_value) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_v_value)->tp_name), 0))) __PYX_ERR(0, 2875, __pyx_L1_error)
        __pyx_v_type_string = __pyx_f_12libopenzwave_str_to_cppstr(((PyObject*)__pyx_v_value));

        /* "libopenzwave.pyx":2874
 *             elif datatype == "List":
 *                 logger.debug("SetValueListSelection %s", value)
 *                 if six.PY3:             # <<<<<<<<<<<<<<
 *                     type_string = str_to_cppstr(value)
 *                 else:
 */
        goto __pyx_L8;
      }

      /* "libopenzwave.pyx":2877
 *                     type_string = str_to_cppstr(value)
 *                 else:
 *                     type_string = str_to_cppstr(string(value))             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetValueListSelection(values_map.at(id), type_string)
 *                 logger.debug("SetValueListSelection %s", cret)
 */
      /*else*/ {
        __pyx_t_21 = __Pyx_PyObject_AsString(__pyx_v_value); if (unlikely((!__pyx_t_21) && PyErr_Occurred())) __PYX_ERR(0, 2877, __pyx_L1_error)
        __pyx_t_3 = __pyx_convert_PyStr_string_to_py_std__in_string(std::string(__pyx_t_21)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2877, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_v_type_string = __pyx_f_12libopenzwave_str_to_cppstr(((PyObject*)__pyx_t_3));
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      }
      __pyx_L8:;

      /* "libopenzwave.pyx":2878
 *                 else:
 *                     type_string = str_to_cppstr(string(value))
 *                 cret = self.manager.SetValueListSelection(values_map.at(id), type_string)             # <<<<<<<<<<<<<<
 *                 logger.debug("SetValueListSelection %s", cret)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2878, __pyx_L1_error)
      try {
        __pyx_t_26 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 2878, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetValueListSelection(__pyx_t_26, __pyx_v_type_string);

      /* "libopenzwave.pyx":2879
 *                     type_string = str_to_cppstr(string(value))
 *                 cret = self.manager.SetValueListSelection(values_map.at(id), type_string)
 *                 logger.debug("SetValueListSelection %s", cret)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *         return ret
 */
      __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2879, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_25 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_debug); if (unlikely(!__pyx_t_25)) __PYX_ERR(0, 2879, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_25);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_5 = __Pyx_PyBool_FromLong(__pyx_v_cret); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2879, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_6 = NULL;
      __pyx_t_24 = 0;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_25))) {
        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_25);
        if (likely(__pyx_t_6)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_25);
          __Pyx_INCREF(__pyx_t_6);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_25, function);
          __pyx_t_24 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_25)) {
        PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_kp_s_SetValueListSelection_s, __pyx_t_5};
        __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_25, __pyx_temp+1-__pyx_t_24, 2+__pyx_t_24); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2879, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_25)) {
        PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_kp_s_SetValueListSelection_s, __pyx_t_5};
        __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_25, __pyx_temp+1-__pyx_t_24, 2+__pyx_t_24); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2879, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else
      #endif
      {
        __pyx_t_27 = PyTuple_New(2+__pyx_t_24); if (unlikely(!__pyx_t_27)) __PYX_ERR(0, 2879, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_27);
        if (__pyx_t_6) {
          __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_27, 0, __pyx_t_6); __pyx_t_6 = NULL;
        }
        __Pyx_INCREF(__pyx_kp_s_SetValueListSelection_s);
        __Pyx_GIVEREF(__pyx_kp_s_SetValueListSelection_s);
        PyTuple_SET_ITEM(__pyx_t_27, 0+__pyx_t_24, __pyx_kp_s_SetValueListSelection_s);
        __Pyx_GIVEREF(__pyx_t_5);
        PyTuple_SET_ITEM(__pyx_t_27, 1+__pyx_t_24, __pyx_t_5);
        __pyx_t_5 = 0;
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_25, __pyx_t_27, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2879, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_27); __pyx_t_27 = 0;
      }
      __Pyx_DECREF(__pyx_t_25); __pyx_t_25 = 0;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

      /* "libopenzwave.pyx":2880
 *                 cret = self.manager.SetValueListSelection(values_map.at(id), type_string)
 *                 logger.debug("SetValueListSelection %s", cret)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":2872
 *                 cret = self.manager.SetValue(values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 *             elif datatype == "List":             # <<<<<<<<<<<<<<
 *                 logger.debug("SetValueListSelection %s", value)
 *                 if six.PY3:
 */
    }
    __pyx_L4:;

    /* "libopenzwave.pyx":2831
 *         cdef uint8_t* type_raw
 *         ret = 2
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":
 */
  }

  /* "libopenzwave.pyx":2881
 *                 logger.debug("SetValueListSelection %s", cret)
 *                 ret = 1 if cret else 0
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def refreshValue(self, id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyInt_From_long(__pyx_v_ret); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2881, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2806
 * #        bool SetValueListSelection(ValueID& valueid, string selecteditem)
 * 
 *     def setValue(self, id, value):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setValue:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_25);
  __Pyx_XDECREF(__pyx_t_27);
  __Pyx_AddTraceback("libopenzwave.PyManager.setValue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_datatype);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2883
 *         return ret
 * 
 *     def refreshValue(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _refreshValue:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_157refreshValue(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_156refreshValue[] = "\n.. _refreshValue:\n\nRefreshes the specified value from the Z-Wave network.\nA call to this function causes the library to send a message to the network to retrieve the current value\nof the specified ValueID (just like a poll, except only one-time, not recurring).\n\n:param id: The unique identifier of the value to be refreshed.\n:type id: int\n:return: bool -- True if the driver and node were found; false otherwise\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_157refreshValue(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("refreshValue (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_156refreshValue(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_156refreshValue(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("refreshValue", 0);

  /* "libopenzwave.pyx":2896
 * 
 *         '''
 *         return self.manager.RefreshValue(values_map.at(id))             # <<<<<<<<<<<<<<
 * 
 *     def getValueLabel(self, id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2896, __pyx_L1_error)
  try {
    __pyx_t_2 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
  } catch(...) {
    __Pyx_CppExn2PyErr();
    __PYX_ERR(0, 2896, __pyx_L1_error)
  }
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->RefreshValue(__pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2896, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":2883
 *         return ret
 * 
 *     def refreshValue(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _refreshValue:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.refreshValue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2898
 *         return self.manager.RefreshValue(values_map.at(id))
 * 
 *     def getValueLabel(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueLabel:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_159getValueLabel(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_158getValueLabel[] = "\n.. _getValueLabel:\n\nGets the user-friendly label for the value\n\n:param id: The ID of a value.\n:type id: int\n:return: A string containing the user-friendly label of the value\n:rtype: str\n:see: setValueLabel_\n\n       ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_159getValueLabel(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueLabel (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_158getValueLabel(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_158getValueLabel(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("getValueLabel", 0);

  /* "libopenzwave.pyx":2912
 *        '''
 *         cdef string c_string
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             c_string = self.manager.GetValueLabel(values_map.at(id))
 *             return cstr_to_str(c_string.c_str())
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2912, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":2913
 *         cdef string c_string
 *         if values_map.find(id) != values_map.end():
 *             c_string = self.manager.GetValueLabel(values_map.at(id))             # <<<<<<<<<<<<<<
 *             return cstr_to_str(c_string.c_str())
 *         else :
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2913, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 2913, __pyx_L1_error)
    }
    __pyx_v_c_string = __pyx_v_self->manager->GetValueLabel(__pyx_t_3);

    /* "libopenzwave.pyx":2914
 *         if values_map.find(id) != values_map.end():
 *             c_string = self.manager.GetValueLabel(values_map.at(id))
 *             return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 *         else :
 *             return None
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2914, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2914, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_r = __pyx_t_5;
    __pyx_t_5 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2912
 *        '''
 *         cdef string c_string
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             c_string = self.manager.GetValueLabel(values_map.at(id))
 *             return cstr_to_str(c_string.c_str())
 */
  }

  /* "libopenzwave.pyx":2916
 *             return cstr_to_str(c_string.c_str())
 *         else :
 *             return None             # <<<<<<<<<<<<<<
 * 
 *     def setValueLabel(self, id, str label):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":2898
 *         return self.manager.RefreshValue(values_map.at(id))
 * 
 *     def getValueLabel(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueLabel:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueLabel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2918
 *             return None
 * 
 *     def setValueLabel(self, id, str label):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setValueLabel:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_161setValueLabel(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_160setValueLabel[] = "\n.. _setValueLabel:\n\nSets the user-friendly label for the value\n\n:param id: The ID of a value.\n:type id: int\n:param label: The label of the value.\n:type label: str\n:see: getValueLabel_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_161setValueLabel(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_id = 0;
  PyObject *__pyx_v_label = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setValueLabel (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_label,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_label)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setValueLabel", 1, 2, 2, 1); __PYX_ERR(0, 2918, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setValueLabel") < 0)) __PYX_ERR(0, 2918, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_id = values[0];
    __pyx_v_label = ((PyObject*)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setValueLabel", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2918, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setValueLabel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_label), (&PyString_Type), 1, "label", 1))) __PYX_ERR(0, 2918, __pyx_L1_error)
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_160setValueLabel(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_id, __pyx_v_label);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_160setValueLabel(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_label) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  __Pyx_RefNannySetupContext("setValueLabel", 0);

  /* "libopenzwave.pyx":2931
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             self.manager.SetValueLabel(values_map.at(id), str_to_cppstr(label))
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2931, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":2932
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             self.manager.SetValueLabel(values_map.at(id), str_to_cppstr(label))             # <<<<<<<<<<<<<<
 * 
 *     def getValueUnits(self, id):
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2932, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 2932, __pyx_L1_error)
    }
    __pyx_v_self->manager->SetValueLabel(__pyx_t_3, __pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_label));

    /* "libopenzwave.pyx":2931
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             self.manager.SetValueLabel(values_map.at(id), str_to_cppstr(label))
 * 
 */
  }

  /* "libopenzwave.pyx":2918
 *             return None
 * 
 *     def setValueLabel(self, id, str label):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setValueLabel:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setValueLabel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2934
 *             self.manager.SetValueLabel(values_map.at(id), str_to_cppstr(label))
 * 
 *     def getValueUnits(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueUnits:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_163getValueUnits(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_162getValueUnits[] = "\n.. _getValueUnits:\n\nGets the units that the value is measured in.\n\n:param id: The ID of a value.\n:type id: int\n:return: A string containing the value of the units.\n:rtype: str\n:see: setValueUnits_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_163getValueUnits(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueUnits (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_162getValueUnits(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_162getValueUnits(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("getValueUnits", 0);

  /* "libopenzwave.pyx":2948
 *         '''
 *         cdef string c_string
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             c_string = self.manager.GetValueUnits(values_map.at(id))
 *             return cstr_to_str(c_string.c_str())
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2948, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":2949
 *         cdef string c_string
 *         if values_map.find(id) != values_map.end():
 *             c_string = self.manager.GetValueUnits(values_map.at(id))             # <<<<<<<<<<<<<<
 *             return cstr_to_str(c_string.c_str())
 *         else :
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2949, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 2949, __pyx_L1_error)
    }
    __pyx_v_c_string = __pyx_v_self->manager->GetValueUnits(__pyx_t_3);

    /* "libopenzwave.pyx":2950
 *         if values_map.find(id) != values_map.end():
 *             c_string = self.manager.GetValueUnits(values_map.at(id))
 *             return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 *         else :
 *             return None
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2950, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2950, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_r = __pyx_t_5;
    __pyx_t_5 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2948
 *         '''
 *         cdef string c_string
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             c_string = self.manager.GetValueUnits(values_map.at(id))
 *             return cstr_to_str(c_string.c_str())
 */
  }

  /* "libopenzwave.pyx":2952
 *             return cstr_to_str(c_string.c_str())
 *         else :
 *             return None             # <<<<<<<<<<<<<<
 * 
 *     def setValueUnits(self, id, str unit):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":2934
 *             self.manager.SetValueLabel(values_map.at(id), str_to_cppstr(label))
 * 
 *     def getValueUnits(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueUnits:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueUnits", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2954
 *             return None
 * 
 *     def setValueUnits(self, id, str unit):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setValueUnits:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_165setValueUnits(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_164setValueUnits[] = "\n.. _setValueUnits:\n\nSets the units that the value is measured in.\n\n:param id: The ID of a value.\n:type id: int\n:param label: The new value of the units.\n:type label: str\n:see: getValueUnits_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_165setValueUnits(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_id = 0;
  PyObject *__pyx_v_unit = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setValueUnits (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_unit,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_unit)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setValueUnits", 1, 2, 2, 1); __PYX_ERR(0, 2954, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setValueUnits") < 0)) __PYX_ERR(0, 2954, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_id = values[0];
    __pyx_v_unit = ((PyObject*)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setValueUnits", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2954, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setValueUnits", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_unit), (&PyString_Type), 1, "unit", 1))) __PYX_ERR(0, 2954, __pyx_L1_error)
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_164setValueUnits(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_id, __pyx_v_unit);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_164setValueUnits(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_unit) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  __Pyx_RefNannySetupContext("setValueUnits", 0);

  /* "libopenzwave.pyx":2967
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             self.manager.SetValueUnits(values_map.at(id), str_to_cppstr(unit))
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2967, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":2968
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             self.manager.SetValueUnits(values_map.at(id), str_to_cppstr(unit))             # <<<<<<<<<<<<<<
 * 
 *     def getValueHelp(self, id):
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2968, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 2968, __pyx_L1_error)
    }
    __pyx_v_self->manager->SetValueUnits(__pyx_t_3, __pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_unit));

    /* "libopenzwave.pyx":2967
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             self.manager.SetValueUnits(values_map.at(id), str_to_cppstr(unit))
 * 
 */
  }

  /* "libopenzwave.pyx":2954
 *             return None
 * 
 *     def setValueUnits(self, id, str unit):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setValueUnits:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setValueUnits", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2970
 *             self.manager.SetValueUnits(values_map.at(id), str_to_cppstr(unit))
 * 
 *     def getValueHelp(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueHelp:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_167getValueHelp(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_166getValueHelp[] = "\n.. _getValueHelp:\n\nGets a help string describing the value's purpose and usage.\n\n:param id: The ID of a value.\n:type id: int\n:return: A string containing the value help text.\n:rtype: str\n:see: setValueHelp_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_167getValueHelp(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueHelp (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_166getValueHelp(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_166getValueHelp(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("getValueHelp", 0);

  /* "libopenzwave.pyx":2984
 *         '''
 *         cdef string c_string
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             c_string = self.manager.GetValueHelp(values_map.at(id))
 *             return cstr_to_str(c_string.c_str())
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2984, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":2985
 *         cdef string c_string
 *         if values_map.find(id) != values_map.end():
 *             c_string = self.manager.GetValueHelp(values_map.at(id))             # <<<<<<<<<<<<<<
 *             return cstr_to_str(c_string.c_str())
 *         else :
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 2985, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 2985, __pyx_L1_error)
    }
    __pyx_v_c_string = __pyx_v_self->manager->GetValueHelp(__pyx_t_3);

    /* "libopenzwave.pyx":2986
 *         if values_map.find(id) != values_map.end():
 *             c_string = self.manager.GetValueHelp(values_map.at(id))
 *             return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 *         else :
 *             return None
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2986, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2986, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_r = __pyx_t_5;
    __pyx_t_5 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":2984
 *         '''
 *         cdef string c_string
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             c_string = self.manager.GetValueHelp(values_map.at(id))
 *             return cstr_to_str(c_string.c_str())
 */
  }

  /* "libopenzwave.pyx":2988
 *             return cstr_to_str(c_string.c_str())
 *         else :
 *             return None             # <<<<<<<<<<<<<<
 * 
 *     def setValueHelp(self, id, str help):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":2970
 *             self.manager.SetValueUnits(values_map.at(id), str_to_cppstr(unit))
 * 
 *     def getValueHelp(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueHelp:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueHelp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":2990
 *             return None
 * 
 *     def setValueHelp(self, id, str help):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setValueHelp:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_169setValueHelp(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_168setValueHelp[] = "\n.. _setValueHelp:\n\nSets a help string describing the value's purpose and usage.\n\n:param id: the ID of a value.\n:type id: int\n:param help: The new value of the help text.\n:type help: str\n:see: getValueHelp_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_169setValueHelp(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_id = 0;
  PyObject *__pyx_v_help = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setValueHelp (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_help,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_help)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setValueHelp", 1, 2, 2, 1); __PYX_ERR(0, 2990, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setValueHelp") < 0)) __PYX_ERR(0, 2990, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_id = values[0];
    __pyx_v_help = ((PyObject*)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setValueHelp", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2990, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setValueHelp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_help), (&PyString_Type), 1, "help", 1))) __PYX_ERR(0, 2990, __pyx_L1_error)
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_168setValueHelp(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_id, __pyx_v_help);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_168setValueHelp(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_help) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  __Pyx_RefNannySetupContext("setValueHelp", 0);

  /* "libopenzwave.pyx":3003
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             self.manager.SetValueHelp(values_map.at(id), str_to_cppstr(help))
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3003, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3004
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             self.manager.SetValueHelp(values_map.at(id), str_to_cppstr(help))             # <<<<<<<<<<<<<<
 * 
 *     def getValueMin(self, id):
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3004, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3004, __pyx_L1_error)
    }
    __pyx_v_self->manager->SetValueHelp(__pyx_t_3, __pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_help));

    /* "libopenzwave.pyx":3003
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             self.manager.SetValueHelp(values_map.at(id), str_to_cppstr(help))
 * 
 */
  }

  /* "libopenzwave.pyx":2990
 *             return None
 * 
 *     def setValueHelp(self, id, str help):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setValueHelp:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setValueHelp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3006
 *             self.manager.SetValueHelp(values_map.at(id), str_to_cppstr(help))
 * 
 *     def getValueMin(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueMin:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_171getValueMin(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_170getValueMin[] = "\n.. _getValueMin:\n\nGets the minimum that this value may contain.\n\n:param id: The ID of a value.\n:type id: int\n:return: The value minimum.\n:rtype: int\n:see: getValueMax_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_171getValueMin(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueMin (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_170getValueMin(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_170getValueMin(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getValueMin", 0);

  /* "libopenzwave.pyx":3019
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.GetValueMin(values_map.at(id))
 *         else :
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3019, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3020
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.GetValueMin(values_map.at(id))             # <<<<<<<<<<<<<<
 *         else :
 *             return None
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3020, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3020, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyInt_From_uint32_t(__pyx_v_self->manager->GetValueMin(__pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3020, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3019
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.GetValueMin(values_map.at(id))
 *         else :
 */
  }

  /* "libopenzwave.pyx":3022
 *             return self.manager.GetValueMin(values_map.at(id))
 *         else :
 *             return None             # <<<<<<<<<<<<<<
 * 
 *     def getValueMax(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3006
 *             self.manager.SetValueHelp(values_map.at(id), str_to_cppstr(help))
 * 
 *     def getValueMin(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueMin:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueMin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3024
 *             return None
 * 
 *     def getValueMax(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueMax:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_173getValueMax(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_172getValueMax[] = "\n.. _getValueMax:\n\nGets the maximum that this value may contain.\n\n:param id: The ID of a value.\n:type id: int\n:return: The value maximum.\n:rtype: int\n:see: getValueMin_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_173getValueMax(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueMax (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_172getValueMax(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_172getValueMax(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getValueMax", 0);

  /* "libopenzwave.pyx":3037
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.GetValueMax(values_map.at(id))
 *         else :
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3037, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3038
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.GetValueMax(values_map.at(id))             # <<<<<<<<<<<<<<
 *         else :
 *             return None
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3038, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3038, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyInt_From_uint32_t(__pyx_v_self->manager->GetValueMax(__pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3038, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3037
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.GetValueMax(values_map.at(id))
 *         else :
 */
  }

  /* "libopenzwave.pyx":3040
 *             return self.manager.GetValueMax(values_map.at(id))
 *         else :
 *             return None             # <<<<<<<<<<<<<<
 * 
 *     def isValueReadOnly(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3024
 *             return None
 * 
 *     def getValueMax(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueMax:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueMax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3042
 *             return None
 * 
 *     def isValueReadOnly(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isValueReadOnly:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_175isValueReadOnly(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_174isValueReadOnly[] = "\n.. _isValueReadOnly:\n\nTest whether the value is read-only.\n\n:param id: The ID of a value.\n:type id: int\n:return: True if the value cannot be changed by the user.\n:rtype: bool\n:see: isValueWriteOnly_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_175isValueReadOnly(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isValueReadOnly (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_174isValueReadOnly(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_174isValueReadOnly(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("isValueReadOnly", 0);

  /* "libopenzwave.pyx":3055
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.IsValueReadOnly(values_map.at(id))
 *         else :
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3055, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3056
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.IsValueReadOnly(values_map.at(id))             # <<<<<<<<<<<<<<
 *         else :
 *             return None
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3056, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3056, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsValueReadOnly(__pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3056, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3055
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.IsValueReadOnly(values_map.at(id))
 *         else :
 */
  }

  /* "libopenzwave.pyx":3058
 *             return self.manager.IsValueReadOnly(values_map.at(id))
 *         else :
 *             return None             # <<<<<<<<<<<<<<
 * 
 *     def isValueWriteOnly(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3042
 *             return None
 * 
 *     def isValueReadOnly(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isValueReadOnly:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.isValueReadOnly", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3060
 *             return None
 * 
 *     def isValueWriteOnly(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isValueWriteOnly:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_177isValueWriteOnly(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_176isValueWriteOnly[] = "\n.. _isValueWriteOnly:\n\nTest whether the value is write-only.\n\n:param id: The ID of a value.\n:type id: int\n:return: True if the value can only be written to and not read.\n:rtype: bool\n:see: isValueReadOnly_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_177isValueWriteOnly(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isValueWriteOnly (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_176isValueWriteOnly(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_176isValueWriteOnly(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("isValueWriteOnly", 0);

  /* "libopenzwave.pyx":3073
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.IsValueWriteOnly(values_map.at(id))
 *         else :
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3073, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3074
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.IsValueWriteOnly(values_map.at(id))             # <<<<<<<<<<<<<<
 *         else :
 *             return None
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3074, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3074, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsValueWriteOnly(__pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3074, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3073
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.IsValueWriteOnly(values_map.at(id))
 *         else :
 */
  }

  /* "libopenzwave.pyx":3076
 *             return self.manager.IsValueWriteOnly(values_map.at(id))
 *         else :
 *             return None             # <<<<<<<<<<<<<<
 * 
 *     def isValueSet(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3060
 *             return None
 * 
 *     def isValueWriteOnly(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isValueWriteOnly:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.isValueWriteOnly", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3078
 *             return None
 * 
 *     def isValueSet(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isValueSet:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_179isValueSet(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_178isValueSet[] = "\n.. _isValueSet:\n\nTest whether the value has been set.\n\n:param id: the ID of a value.\n:type id: int\n:return: True if the value has actually been set by a status message from the device, rather than simply being the default.\n:rtype: bool\n:see: getValue_, getValueAsBool_, getValueAsByte_, getValueListItems_, getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueAsString_, getValueType_, getValueInstance_, getValueIndex_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_179isValueSet(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isValueSet (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_178isValueSet(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_178isValueSet(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("isValueSet", 0);

  /* "libopenzwave.pyx":3093
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.IsValueSet(values_map.at(id))
 *         else :
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3093, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3094
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.IsValueSet(values_map.at(id))             # <<<<<<<<<<<<<<
 *         else :
 *             return None
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3094, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3094, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsValueSet(__pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3094, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3093
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.IsValueSet(values_map.at(id))
 *         else :
 */
  }

  /* "libopenzwave.pyx":3096
 *             return self.manager.IsValueSet(values_map.at(id))
 *         else :
 *             return None             # <<<<<<<<<<<<<<
 * 
 *     def isValuePolled(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3078
 *             return None
 * 
 *     def isValueSet(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isValueSet:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.isValueSet", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3098
 *             return None
 * 
 *     def isValuePolled(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isValuePolled:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_181isValuePolled(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_180isValuePolled[] = "\n.. _isValuePolled:\n\nTest whether the value is currently being polled.\n\n:param id: the ID of a value.\n:type id: int\n:return: True if the value is being polled, otherwise false.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_181isValuePolled(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isValuePolled (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_180isValuePolled(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_180isValuePolled(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("isValuePolled", 0);

  /* "libopenzwave.pyx":3110
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.IsValuePolled(values_map.at(id))
 *         else :
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3110, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3111
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.IsValuePolled(values_map.at(id))             # <<<<<<<<<<<<<<
 *         else :
 *             return None
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3111, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3111, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->IsValuePolled(__pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3111, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3110
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.IsValuePolled(values_map.at(id))
 *         else :
 */
  }

  /* "libopenzwave.pyx":3113
 *             return self.manager.IsValuePolled(values_map.at(id))
 *         else :
 *             return None             # <<<<<<<<<<<<<<
 * 
 *     def getValueGenre(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3098
 *             return None
 * 
 *     def isValuePolled(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _isValuePolled:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.isValuePolled", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3115
 *             return None
 * 
 *     def getValueGenre(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueGenre:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_183getValueGenre(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_182getValueGenre[] = "\n.. _getValueGenre:\n\nGet the genre of the value.  The genre classifies a value to enable\nlow-level system or configuration parameters to be filtered out\nby the application\n\n:param id: The ID of a value.\n:type id: int\n:return: A string containing the type of the value\n:rtype: str\n:see: isValueSet_, getValueAsBool_, getValueAsByte_, getValueListItems_, getValueListSelectionStr_ , getValueListSelectionNum_, getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueCommandClass_,getValueAsString_, getValue_, getValueType_, getValueInstance_, getValueIndex_\n\n       ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_183getValueGenre(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueGenre (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_182getValueGenre(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_182getValueGenre(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_v_genre = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannySetupContext("getValueGenre", 0);

  /* "libopenzwave.pyx":3133
 * 
 *        '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             genre = PyGenres[values_map.at(id).GetGenre()]
 *             return genre
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3133, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3134
 *        '''
 *         if values_map.find(id) != values_map.end():
 *             genre = PyGenres[values_map.at(id).GetGenre()]             # <<<<<<<<<<<<<<
 *             return genre
 *         else :
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyGenres); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3134, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3134, __pyx_L1_error)
    try {
      __pyx_t_4 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3134, __pyx_L1_error)
    }
    __pyx_t_5 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueGenre(__pyx_t_4->GetGenre()); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3134, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = PyObject_GetItem(__pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3134, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_v_genre = __pyx_t_6;
    __pyx_t_6 = 0;

    /* "libopenzwave.pyx":3135
 *         if values_map.find(id) != values_map.end():
 *             genre = PyGenres[values_map.at(id).GetGenre()]
 *             return genre             # <<<<<<<<<<<<<<
 *         else :
 *             return None
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_genre);
    __pyx_r = __pyx_v_genre;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3133
 * 
 *        '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             genre = PyGenres[values_map.at(id).GetGenre()]
 *             return genre
 */
  }

  /* "libopenzwave.pyx":3137
 *             return genre
 *         else :
 *             return None             # <<<<<<<<<<<<<<
 * 
 *     def getValueCommandClass(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3115
 *             return None
 * 
 *     def getValueGenre(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueGenre:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueGenre", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_genre);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3139
 *             return None
 * 
 *     def getValueCommandClass(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueCommandClass:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_185getValueCommandClass(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_184getValueCommandClass[] = "\n.. _getValueCommandClass:\n\nGet the command class instance of this value.  It is possible for there to be\nmultiple instances of a command class, although currently it appears that\nonly the SensorMultilevel command class ever does this.  Knowledge of\ninstances and command classes is not required to use OpenZWave, but this\ninformation is exposed in case it is of interest.\n\n\n:param id: The ID of a value.\n:type id: int\n:return: The command class of the value\n:rtype: int\n:see: isValueSet_, getValueAsBool_, getValueAsByte_, getValueListItems_, getValueListSelectionStr_ , getValueListSelectionNum_, getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueGenre_, getValueAsString_, getValue_, getValueType_, getValueInstance_, getValueIndex_\n\n       ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_185getValueCommandClass(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueCommandClass (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_184getValueCommandClass(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_184getValueCommandClass(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  uint8_t __pyx_v_cmd_cls;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getValueCommandClass", 0);

  /* "libopenzwave.pyx":3160
 * 
 *        '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             cmd_cls = values_map.at(id).GetCommandClassId()
 *             return cmd_cls
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3160, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3161
 *        '''
 *         if values_map.find(id) != values_map.end():
 *             cmd_cls = values_map.at(id).GetCommandClassId()             # <<<<<<<<<<<<<<
 *             return cmd_cls
 *         else :
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3161, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3161, __pyx_L1_error)
    }
    __pyx_v_cmd_cls = __pyx_t_3->GetCommandClassId();

    /* "libopenzwave.pyx":3162
 *         if values_map.find(id) != values_map.end():
 *             cmd_cls = values_map.at(id).GetCommandClassId()
 *             return cmd_cls             # <<<<<<<<<<<<<<
 *         else :
 *             return None
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyInt_From_uint8_t(__pyx_v_cmd_cls); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3162, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3160
 * 
 *        '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             cmd_cls = values_map.at(id).GetCommandClassId()
 *             return cmd_cls
 */
  }

  /* "libopenzwave.pyx":3164
 *             return cmd_cls
 *         else :
 *             return None             # <<<<<<<<<<<<<<
 * 
 *     def getValueInstance(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3139
 *             return None
 * 
 *     def getValueCommandClass(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueCommandClass:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueCommandClass", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3166
 *             return None
 * 
 *     def getValueInstance(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueInstance:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_187getValueInstance(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_186getValueInstance[] = "\n.. _getValueInstance:\n\nGet the command class instance of this value.  It is possible for there to be\nmultiple instances of a command class, although currently it appears that\nonly the SensorMultilevel command class ever does this.\n\n:param id: The ID of a value.\n:type id: int\n:return: A string containing the type of the value\n:rtype: str\n:see: isValueSet_, getValueAsBool_, getValueAsByte_, getValueListItems_, getValueListSelectionStr_ , getValueListSelectionNum_, getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueCommandClass_, getValueAsString_, getValue_, getValueType_, getValueIndex_\n\n       ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_187getValueInstance(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueInstance (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_186getValueInstance(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_186getValueInstance(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  uint8_t __pyx_v_genre;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getValueInstance", 0);

  /* "libopenzwave.pyx":3184
 * 
 *        '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             genre = values_map.at(id).GetInstance()
 *             return genre
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3184, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3185
 *        '''
 *         if values_map.find(id) != values_map.end():
 *             genre = values_map.at(id).GetInstance()             # <<<<<<<<<<<<<<
 *             return genre
 *         else :
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3185, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3185, __pyx_L1_error)
    }
    __pyx_v_genre = __pyx_t_3->GetInstance();

    /* "libopenzwave.pyx":3186
 *         if values_map.find(id) != values_map.end():
 *             genre = values_map.at(id).GetInstance()
 *             return genre             # <<<<<<<<<<<<<<
 *         else :
 *             return None
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyInt_From_uint8_t(__pyx_v_genre); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3186, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3184
 * 
 *        '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             genre = values_map.at(id).GetInstance()
 *             return genre
 */
  }

  /* "libopenzwave.pyx":3188
 *             return genre
 *         else :
 *             return None             # <<<<<<<<<<<<<<
 * 
 *     def getValueIndex(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3166
 *             return None
 * 
 *     def getValueInstance(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueInstance:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueInstance", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3190
 *             return None
 * 
 *     def getValueIndex(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueIndex:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_189getValueIndex(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_188getValueIndex[] = "\n.. _getValueIndex:\n\nGet the value index.  The index is used to identify one of multiple\nvalues created and managed by a command class.  In the case of configurable\nparameters (handled by the configuration command class), the index is the\nsame as the parameter ID.\n\n:param id: The ID of a value.\n:type id: int\n:return: A string containing the type of the value\n:rtype: str\n:see: isValueSet_, getValueAsBool_, getValueAsByte_, getValueListItems_, getValueListSelectionStr_ , getValueListSelectionNum_, getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueCommandClass_, getValueAsString_, getValue_, getValueType_\n\n       ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_189getValueIndex(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueIndex (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_188getValueIndex(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_188getValueIndex(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  uint8_t __pyx_v_genre;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getValueIndex", 0);

  /* "libopenzwave.pyx":3209
 * 
 *        '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             genre = values_map.at(id).GetIndex()
 *             return genre
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3209, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3210
 *        '''
 *         if values_map.find(id) != values_map.end():
 *             genre = values_map.at(id).GetIndex()             # <<<<<<<<<<<<<<
 *             return genre
 *         else :
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3210, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3210, __pyx_L1_error)
    }
    __pyx_v_genre = __pyx_t_3->GetIndex();

    /* "libopenzwave.pyx":3211
 *         if values_map.find(id) != values_map.end():
 *             genre = values_map.at(id).GetIndex()
 *             return genre             # <<<<<<<<<<<<<<
 *         else :
 *             return None
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyInt_From_uint8_t(__pyx_v_genre); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3211, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3209
 * 
 *        '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             genre = values_map.at(id).GetIndex()
 *             return genre
 */
  }

  /* "libopenzwave.pyx":3213
 *             return genre
 *         else :
 *             return None             # <<<<<<<<<<<<<<
 * 
 *     def getValueType(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3190
 *             return None
 * 
 *     def getValueIndex(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueIndex:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueIndex", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3215
 *             return None
 * 
 *     def getValueType(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueType:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_191getValueType(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_190getValueType[] = "\n.. _getValueType:\n\nGets the type of the value\n\n:param id: The ID of a value.\n:type id: int\n:return: A string containing the type of the value\n:rtype: str\n:see: isValueSet_, getValueAsBool_, getValueAsByte_, getValueListItems_, getValueListSelectionStr_ , getValueListSelectionNum_, getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueAsString_, getValue_, getValueInstance_, getValueIndex_, getValueCommandClass_\n\n       ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_191getValueType(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueType (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_190getValueType(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_190getValueType(CYTHON_UNUSED struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_v_datatype = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannySetupContext("getValueType", 0);

  /* "libopenzwave.pyx":3231
 * 
 *        '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             return datatype
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3231, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3232
 *        '''
 *         if values_map.find(id) != values_map.end():
 *             datatype = PyValueTypes[values_map.at(id).GetType()]             # <<<<<<<<<<<<<<
 *             return datatype
 *         else :
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyValueTypes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3232, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3232, __pyx_L1_error)
    try {
      __pyx_t_4 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3232, __pyx_L1_error)
    }
    __pyx_t_5 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueType(__pyx_t_4->GetType()); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3232, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = PyObject_GetItem(__pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3232, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_v_datatype = __pyx_t_6;
    __pyx_t_6 = 0;

    /* "libopenzwave.pyx":3233
 *         if values_map.find(id) != values_map.end():
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             return datatype             # <<<<<<<<<<<<<<
 *         else :
 *             return None
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_datatype);
    __pyx_r = __pyx_v_datatype;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3231
 * 
 *        '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             return datatype
 */
  }

  /* "libopenzwave.pyx":3235
 *             return datatype
 *         else :
 *             return None             # <<<<<<<<<<<<<<
 * 
 *     def getValue(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3215
 *             return None
 * 
 *     def getValueType(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueType:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueType", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_datatype);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3237
 *             return None
 * 
 *     def getValue(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValue:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_193getValue(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_192getValue[] = "\n.. _getValue:\n\nGets a value.\n\n:param id: The ID of a value.\n:type id: int\n:param value: The value to set.\n:type value: int\n:return: Depending of the type of the valueId, None otherwise\n:rtype: variable\n:see: isValueSet_, getValueAsBool_, getValueAsByte_, getValueListItems_, getValueListSelectionStr_ , getValueListSelectionNum_, getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueAsString_, getValueType_, getValueInstance_, getValueIndex_, getValueCommandClass_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_193getValue(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValue (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_192getValue(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_192getValue(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("getValue", 0);

  /* "libopenzwave.pyx":3255
 * 
 *         '''
 *         return getValueFromType(self.manager,id)             # <<<<<<<<<<<<<<
 * 
 *     def getValueAsBool(self, id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_12libopenzwave_getValueFromType(__pyx_v_self->manager, __pyx_v_id); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3255, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3237
 *             return None
 * 
 *     def getValue(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValue:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3257
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueAsBool(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueAsBool:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_195getValueAsBool(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_194getValueAsBool[] = "\n.. _getValueAsBool:\n\nGets a value as a bool.\n\n:param id: The ID of a value.\n:type id: int\n:return: The value\n:rtype: bool\n:see: isValueSet_, getValue_, getValueAsByte_, getValueListItems_, getValueListSelectionStr_ , getValueListSelectionNum_, getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueAsString_, getValueType_, getValueInstance_, getValueIndex_, getValueCommandClass_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_195getValueAsBool(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueAsBool (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_194getValueAsBool(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_194getValueAsBool(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("getValueAsBool", 0);

  /* "libopenzwave.pyx":3273
 * 
 *         '''
 *         return getValueFromType(self.manager,id)             # <<<<<<<<<<<<<<
 * 
 *     def getValueAsByte(self, id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_12libopenzwave_getValueFromType(__pyx_v_self->manager, __pyx_v_id); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3273, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3257
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueAsBool(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueAsBool:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueAsBool", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3275
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueAsByte(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueAsByte:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_197getValueAsByte(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_196getValueAsByte[] = "\n.. _getValueAsByte:\n\nGets a value as an 8-bit unsigned integer.\n\n:param id: The ID of a value.\n:type id: int\n:return: The value\n:rtype: int\n:see: isValueSet_, getValue_, getValueAsBool_, getValueListItems_, getValueListSelectionStr_ , getValueListSelectionNum_, getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueAsString_, getValueType_, getValueInstance_, getValueIndex_, getValueCommandClass_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_197getValueAsByte(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueAsByte (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_196getValueAsByte(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_196getValueAsByte(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("getValueAsByte", 0);

  /* "libopenzwave.pyx":3291
 * 
 *         '''
 *         return getValueFromType(self.manager,id)             # <<<<<<<<<<<<<<
 * 
 *     def getValueAsFloat(self, id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_12libopenzwave_getValueFromType(__pyx_v_self->manager, __pyx_v_id); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3291, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3275
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueAsByte(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueAsByte:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueAsByte", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3293
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueAsFloat(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueAsFloat:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_199getValueAsFloat(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_198getValueAsFloat[] = "\n.. _getValueAsFloat:\n\nGets a value as a float.\n\n:param id: The ID of a value.\n:type id: int\n:return: The value\n:rtype: float\n:see: isValueSet_, getValue_, getValueAsBool_, getValueAsByte_, getValueListSelectionStr_ , getValueListSelectionNum_, getValueAsShort_, getValueAsInt_, getValueAsString_, getValueListItems_, getValueType_, getValueInstance_, getValueIndex_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_199getValueAsFloat(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueAsFloat (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_198getValueAsFloat(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_198getValueAsFloat(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("getValueAsFloat", 0);

  /* "libopenzwave.pyx":3309
 * 
 *         '''
 *         return getValueFromType(self.manager,id)             # <<<<<<<<<<<<<<
 * 
 *     def getValueAsShort(self, id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_12libopenzwave_getValueFromType(__pyx_v_self->manager, __pyx_v_id); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3309, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3293
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueAsFloat(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueAsFloat:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueAsFloat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3311
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueAsShort(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueAsShort:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_201getValueAsShort(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_200getValueAsShort[] = "\n.. _getValueAsShort:\n\nGets a value as a 16-bit signed integer.\n\n:param id: The ID of a value.\n:type id: int\n:return: The value\n:rtype: int\n:see: isValueSet_, getValue_, getValueAsBool_, getValueAsByte_, getValueListSelectionStr_ , getValueListSelectionNum_, getValueAsFloat_, getValueAsInt_, getValueAsString_, getValueListItems_, getValueType_, getValueInstance_, getValueIndex_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_201getValueAsShort(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueAsShort (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_200getValueAsShort(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_200getValueAsShort(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("getValueAsShort", 0);

  /* "libopenzwave.pyx":3327
 * 
 *         '''
 *         return getValueFromType(self.manager,id)             # <<<<<<<<<<<<<<
 * 
 *     def getValueAsInt(self, id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_12libopenzwave_getValueFromType(__pyx_v_self->manager, __pyx_v_id); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3327, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3311
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueAsShort(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueAsShort:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueAsShort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3329
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueAsInt(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueAsInt:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_203getValueAsInt(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_202getValueAsInt[] = "\n.. _getValueAsInt:\n\nGets a value as a 32-bit signed integer.\n\n:param id: The ID of a value.\n:type id: int\n:return: The value\n:rtype: int\n:see: isValueSet_, getValue_, getValueAsBool_, getValueAsByte_, getValueListSelectionStr_ , getValueListSelectionNum_, getValueAsFloat_, getValueAsShort_, getValueAsString_, getValueListItems_, getValueType_, getValueInstance_, getValueIndex_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_203getValueAsInt(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueAsInt (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_202getValueAsInt(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_202getValueAsInt(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("getValueAsInt", 0);

  /* "libopenzwave.pyx":3345
 * 
 *         '''
 *         return getValueFromType(self.manager,id)             # <<<<<<<<<<<<<<
 * 
 *     def getValueAsString(self, id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_12libopenzwave_getValueFromType(__pyx_v_self->manager, __pyx_v_id); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3345, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3329
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueAsInt(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueAsInt:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueAsInt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3347
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueAsString(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueAsString:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_205getValueAsString(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_204getValueAsString[] = "\n.. _getValueAsString:\n\nGets a value as a string.\n\n:param id: The ID of a value.\n:type id: int\n:return: The value\n:rtype: str\n:see: isValueSet_, getValue_, getValueAsBool_, getValueAsByte_, getValueListSelectionStr_ , getValueListSelectionNum_, getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueListItems_, getValueType_, getValueInstance_, getValueIndex_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_205getValueAsString(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueAsString (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_204getValueAsString(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_204getValueAsString(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("getValueAsString", 0);

  /* "libopenzwave.pyx":3363
 * 
 *         '''
 *         return getValueFromType(self.manager,id)             # <<<<<<<<<<<<<<
 * 
 *     def getValueAsRaw(self, id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_12libopenzwave_getValueFromType(__pyx_v_self->manager, __pyx_v_id); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3363, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3347
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueAsString(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueAsString:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueAsString", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3365
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueAsRaw(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueAsRaw:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_207getValueAsRaw(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_206getValueAsRaw[] = "\n.. _getValueAsRaw:\n\nGets a value as raw.\n\n:param id: The ID of a value.\n:type id: int\n:return: The value\n:rtype: str\n:see: isValueSet_, getValue_, getValueAsBool_, getValueAsByte_, getValueListSelectionStr_ , getValueListSelectionNum_, getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueListItems_, getValueType_, getValueInstance_, getValueIndex_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_207getValueAsRaw(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueAsRaw (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_206getValueAsRaw(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_206getValueAsRaw(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("getValueAsRaw", 0);

  /* "libopenzwave.pyx":3381
 * 
 *         '''
 *         return getValueFromType(self.manager,id)             # <<<<<<<<<<<<<<
 * 
 *     def getValueListSelectionStr(self,  id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_12libopenzwave_getValueFromType(__pyx_v_self->manager, __pyx_v_id); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3381, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3365
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueAsRaw(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueAsRaw:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueAsRaw", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3383
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueListSelectionStr(self,  id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueListSelectionStr:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_209getValueListSelectionStr(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_208getValueListSelectionStr[] = "\n.. _getValueListSelectionStr:\n\nGets value of items from a list value\n\n:param id: The ID of a value.\n:type id: int\n:return: The value\n:rtype: str\n:see: isValueSet_, getValue_, getValueAsBool_, getValueAsByte_, getValueListSelectionNum_, getValueListItems_,getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueAsString_, getValueType_, getValueInstance_, getValueIndex_\n    ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_209getValueListSelectionStr(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueListSelectionStr (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_208getValueListSelectionStr(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_208getValueListSelectionStr(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("getValueListSelectionStr", 0);

  /* "libopenzwave.pyx":3398
 * getValueType_, getValueInstance_, getValueIndex_
 *     '''
 *         return getValueFromType(self.manager,id)             # <<<<<<<<<<<<<<
 * 
 *     def getValueListSelectionNum(self,  id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_12libopenzwave_getValueFromType(__pyx_v_self->manager, __pyx_v_id); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3398, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3383
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueListSelectionStr(self,  id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueListSelectionStr:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueListSelectionStr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3400
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueListSelectionNum(self,  id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueListSelectionNum:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_211getValueListSelectionNum(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_210getValueListSelectionNum[] = "\n.. _getValueListSelectionNum:\n\nGets value of items from a list value\n\n:param id: The ID of a value.\n:type id: int\n:return: The value\n:rtype: int\n:see: isValueSet_, getValue_, getValueAsBool_, getValueAsByte_, getValueListSelectionStr_, getValueListItems_,getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueAsString_, getValueType_, getValueInstance_, getValueIndex_\n    ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_211getValueListSelectionNum(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueListSelectionNum (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_210getValueListSelectionNum(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_210getValueListSelectionNum(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  int32_t __pyx_v_type_int;
  long __pyx_v_ret;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getValueListSelectionNum", 0);

  /* "libopenzwave.pyx":3416
 *     '''
 *         cdef int32_t type_int
 *         ret=-1             # <<<<<<<<<<<<<<
 *         if values_map.find(id) != values_map.end():
 *             if self.manager.GetValueListSelection(values_map.at(id), &type_int):
 */
  __pyx_v_ret = -1L;

  /* "libopenzwave.pyx":3417
 *         cdef int32_t type_int
 *         ret=-1
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             if self.manager.GetValueListSelection(values_map.at(id), &type_int):
 *                 ret = type_int
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3417, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3418
 *         ret=-1
 *         if values_map.find(id) != values_map.end():
 *             if self.manager.GetValueListSelection(values_map.at(id), &type_int):             # <<<<<<<<<<<<<<
 *                 ret = type_int
 *         #print "//////// Value Num list item : " ,  ret
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3418, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3418, __pyx_L1_error)
    }
    __pyx_t_2 = (__pyx_v_self->manager->GetValueListSelection(__pyx_t_3, (&__pyx_v_type_int)) != 0);
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":3419
 *         if values_map.find(id) != values_map.end():
 *             if self.manager.GetValueListSelection(values_map.at(id), &type_int):
 *                 ret = type_int             # <<<<<<<<<<<<<<
 *         #print "//////// Value Num list item : " ,  ret
 *         return ret
 */
      __pyx_v_ret = __pyx_v_type_int;

      /* "libopenzwave.pyx":3418
 *         ret=-1
 *         if values_map.find(id) != values_map.end():
 *             if self.manager.GetValueListSelection(values_map.at(id), &type_int):             # <<<<<<<<<<<<<<
 *                 ret = type_int
 *         #print "//////// Value Num list item : " ,  ret
 */
    }

    /* "libopenzwave.pyx":3417
 *         cdef int32_t type_int
 *         ret=-1
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             if self.manager.GetValueListSelection(values_map.at(id), &type_int):
 *                 ret = type_int
 */
  }

  /* "libopenzwave.pyx":3421
 *                 ret = type_int
 *         #print "//////// Value Num list item : " ,  ret
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def getValueListItems(self, id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_4 = __Pyx_PyInt_From_long(__pyx_v_ret); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3421, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3400
 *         return getValueFromType(self.manager,id)
 * 
 *     def getValueListSelectionNum(self,  id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueListSelectionNum:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueListSelectionNum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3423
 *         return ret
 * 
 *     def getValueListItems(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueListItems:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_213getValueListItems(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_212getValueListItems[] = "\n.. _getValueListItems:\n\nGets the list of items from a list value\n\n:param id: The ID of a value.\n:type id: int\n:return: The list of possible values\n:rtype: set()\n:see: isValueSet_, getValue_, getValueAsBool_, getValueAsByte_, getValueListSelectionStr_ , getValueListSelectionNum_ getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueAsString_, getValueType_, getValueInstance_, getValueIndex_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_213getValueListItems(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueListItems (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_212getValueListItems(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_212getValueListItems(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  std::vector<std::string>  __pyx_v_vect;
  PyObject *__pyx_v_ret = NULL;
  std::string __pyx_v_temp;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  uint64_t __pyx_t_2;
  int __pyx_t_3;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_4;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("getValueListItems", 0);

  /* "libopenzwave.pyx":3440
 *         '''
 *         cdef vector[string] vect
 *         ret = set()             # <<<<<<<<<<<<<<
 *         if values_map.find(id) != values_map.end():
 *             if self.manager.GetValueListItems(values_map.at(id), &vect):
 */
  __pyx_t_1 = PySet_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3440, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_ret = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "libopenzwave.pyx":3441
 *         cdef vector[string] vect
 *         ret = set()
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             if self.manager.GetValueListItems(values_map.at(id), &vect):
 *                 while not vect.empty() :
 */
  __pyx_t_2 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_2 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3441, __pyx_L1_error)
  __pyx_t_3 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_2) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_3) {

    /* "libopenzwave.pyx":3442
 *         ret = set()
 *         if values_map.find(id) != values_map.end():
 *             if self.manager.GetValueListItems(values_map.at(id), &vect):             # <<<<<<<<<<<<<<
 *                 while not vect.empty() :
 *                     temp = vect.back()
 */
    __pyx_t_2 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_2 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3442, __pyx_L1_error)
    try {
      __pyx_t_4 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_2);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3442, __pyx_L1_error)
    }
    __pyx_t_3 = (__pyx_v_self->manager->GetValueListItems(__pyx_t_4, (&__pyx_v_vect)) != 0);
    if (__pyx_t_3) {

      /* "libopenzwave.pyx":3443
 *         if values_map.find(id) != values_map.end():
 *             if self.manager.GetValueListItems(values_map.at(id), &vect):
 *                 while not vect.empty() :             # <<<<<<<<<<<<<<
 *                     temp = vect.back()
 *                     ret.add(temp.c_str())
 */
      while (1) {
        __pyx_t_3 = ((!(__pyx_v_vect.empty() != 0)) != 0);
        if (!__pyx_t_3) break;

        /* "libopenzwave.pyx":3444
 *             if self.manager.GetValueListItems(values_map.at(id), &vect):
 *                 while not vect.empty() :
 *                     temp = vect.back()             # <<<<<<<<<<<<<<
 *                     ret.add(temp.c_str())
 *                     vect.pop_back();
 */
        __pyx_v_temp = __pyx_v_vect.back();

        /* "libopenzwave.pyx":3445
 *                 while not vect.empty() :
 *                     temp = vect.back()
 *                     ret.add(temp.c_str())             # <<<<<<<<<<<<<<
 *                     vect.pop_back();
 *         return ret
 */
        __pyx_t_1 = __Pyx_PyUnicode_FromString(__pyx_v_temp.c_str()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3445, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_5 = PySet_Add(__pyx_v_ret, __pyx_t_1); if (unlikely(__pyx_t_5 == -1)) __PYX_ERR(0, 3445, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "libopenzwave.pyx":3446
 *                     temp = vect.back()
 *                     ret.add(temp.c_str())
 *                     vect.pop_back();             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
        __pyx_v_vect.pop_back();
      }

      /* "libopenzwave.pyx":3442
 *         ret = set()
 *         if values_map.find(id) != values_map.end():
 *             if self.manager.GetValueListItems(values_map.at(id), &vect):             # <<<<<<<<<<<<<<
 *                 while not vect.empty() :
 *                     temp = vect.back()
 */
    }

    /* "libopenzwave.pyx":3441
 *         cdef vector[string] vect
 *         ret = set()
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             if self.manager.GetValueListItems(values_map.at(id), &vect):
 *                 while not vect.empty() :
 */
  }

  /* "libopenzwave.pyx":3447
 *                     ret.add(temp.c_str())
 *                     vect.pop_back();
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def getValueListValues(self, id):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3423
 *         return ret
 * 
 *     def getValueListItems(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueListItems:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueListItems", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_ret);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3449
 *         return ret
 * 
 *     def getValueListValues(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueListValues:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_215getValueListValues(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_214getValueListValues[] = "\n.. _getValueListValues:\n\nGets the list of values from a list value.\n\n:param id: The ID of a value.\n:type id: int\n:return: The list of values\n:rtype: set()\n:see: isValueSet_, getValue_, getValueAsBool_, getValueAsByte_, getValueListSelectionStr_ , getValueListSelectionNum_ getValueAsFloat_, getValueAsShort_, getValueAsInt_, getValueAsString_, getValueType_, getValueInstance_, getValueIndex_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_215getValueListValues(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueListValues (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_214getValueListValues(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_214getValueListValues(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  std::vector<int32_t>  __pyx_v_vect;
  PyObject *__pyx_v_ret = NULL;
  int32_t __pyx_v_temp;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  uint64_t __pyx_t_2;
  int __pyx_t_3;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_4;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("getValueListValues", 0);

  /* "libopenzwave.pyx":3466
 *         '''
 *         cdef vector[int32_t] vect
 *         ret = set()             # <<<<<<<<<<<<<<
 *         if values_map.find(id) != values_map.end():
 *             if self.manager.GetValueListValues(values_map.at(id), &vect):
 */
  __pyx_t_1 = PySet_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3466, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_ret = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "libopenzwave.pyx":3467
 *         cdef vector[int32_t] vect
 *         ret = set()
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             if self.manager.GetValueListValues(values_map.at(id), &vect):
 *                 while not vect.empty() :
 */
  __pyx_t_2 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_2 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3467, __pyx_L1_error)
  __pyx_t_3 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_2) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_3) {

    /* "libopenzwave.pyx":3468
 *         ret = set()
 *         if values_map.find(id) != values_map.end():
 *             if self.manager.GetValueListValues(values_map.at(id), &vect):             # <<<<<<<<<<<<<<
 *                 while not vect.empty() :
 *                     temp = vect.back()
 */
    __pyx_t_2 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_2 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3468, __pyx_L1_error)
    try {
      __pyx_t_4 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_2);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3468, __pyx_L1_error)
    }
    __pyx_t_3 = (__pyx_v_self->manager->GetValueListValues(__pyx_t_4, (&__pyx_v_vect)) != 0);
    if (__pyx_t_3) {

      /* "libopenzwave.pyx":3469
 *         if values_map.find(id) != values_map.end():
 *             if self.manager.GetValueListValues(values_map.at(id), &vect):
 *                 while not vect.empty() :             # <<<<<<<<<<<<<<
 *                     temp = vect.back()
 *                     ret.add(temp)
 */
      while (1) {
        __pyx_t_3 = ((!(__pyx_v_vect.empty() != 0)) != 0);
        if (!__pyx_t_3) break;

        /* "libopenzwave.pyx":3470
 *             if self.manager.GetValueListValues(values_map.at(id), &vect):
 *                 while not vect.empty() :
 *                     temp = vect.back()             # <<<<<<<<<<<<<<
 *                     ret.add(temp)
 *                     vect.pop_back();
 */
        __pyx_v_temp = __pyx_v_vect.back();

        /* "libopenzwave.pyx":3471
 *                 while not vect.empty() :
 *                     temp = vect.back()
 *                     ret.add(temp)             # <<<<<<<<<<<<<<
 *                     vect.pop_back();
 *         return ret
 */
        __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_temp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3471, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_5 = PySet_Add(__pyx_v_ret, __pyx_t_1); if (unlikely(__pyx_t_5 == -1)) __PYX_ERR(0, 3471, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "libopenzwave.pyx":3472
 *                     temp = vect.back()
 *                     ret.add(temp)
 *                     vect.pop_back();             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
        __pyx_v_vect.pop_back();
      }

      /* "libopenzwave.pyx":3468
 *         ret = set()
 *         if values_map.find(id) != values_map.end():
 *             if self.manager.GetValueListValues(values_map.at(id), &vect):             # <<<<<<<<<<<<<<
 *                 while not vect.empty() :
 *                     temp = vect.back()
 */
    }

    /* "libopenzwave.pyx":3467
 *         cdef vector[int32_t] vect
 *         ret = set()
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             if self.manager.GetValueListValues(values_map.at(id), &vect):
 *                 while not vect.empty() :
 */
  }

  /* "libopenzwave.pyx":3473
 *                     ret.add(temp)
 *                     vect.pop_back();
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def pressButton(self, id):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3449
 *         return ret
 * 
 *     def getValueListValues(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueListValues:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueListValues", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_ret);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3475
 *         return ret
 * 
 *     def pressButton(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _pressButton:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_217pressButton(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_216pressButton[] = "\n.. _pressButton:\n\nStarts an activity in a device.\nSince buttons are write-only values that do not report a state,\nno notification callbacks are sent.\n\n:param id: The ID of an integer value.\n:type id: int\n:return: True if the activity was started. Returns false if the value is not a ValueID::ValueType_Button. The type can be tested with a call to ValueID::GetType.\n:rtype: bool\n:see: releaseButton_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_217pressButton(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("pressButton (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_216pressButton(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_216pressButton(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("pressButton", 0);

  /* "libopenzwave.pyx":3490
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.PressButton(values_map.at(id))
 *         else :
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3490, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3491
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.PressButton(values_map.at(id))             # <<<<<<<<<<<<<<
 *         else :
 *             return False
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3491, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3491, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->PressButton(__pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3491, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3490
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.PressButton(values_map.at(id))
 *         else :
 */
  }

  /* "libopenzwave.pyx":3493
 *             return self.manager.PressButton(values_map.at(id))
 *         else :
 *             return False             # <<<<<<<<<<<<<<
 * 
 *     def releaseButton(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3475
 *         return ret
 * 
 *     def pressButton(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _pressButton:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.pressButton", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3495
 *             return False
 * 
 *     def releaseButton(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _releaseButton:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_219releaseButton(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_218releaseButton[] = "\n.. _releaseButton:\n\nStops an activity in a device.\nSince buttons are write-only values that do not report a state,\nno notification callbacks are sent.\n\n:param id: the ID of an integer value.\n:type id: int\n:return: True if the activity was stopped. Returns false if the value is not a ValueID::ValueType_Button. The type can be tested with a call to ValueID::GetType.\n:rtype: bool\n:see: pressButton_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_219releaseButton(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("releaseButton (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_218releaseButton(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_218releaseButton(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("releaseButton", 0);

  /* "libopenzwave.pyx":3510
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.ReleaseButton(values_map.at(id))
 *         else :
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3510, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3511
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.ReleaseButton(values_map.at(id))             # <<<<<<<<<<<<<<
 *         else :
 *             return False
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3511, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3511, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->ReleaseButton(__pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3511, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3510
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.ReleaseButton(values_map.at(id))
 *         else :
 */
  }

  /* "libopenzwave.pyx":3513
 *             return self.manager.ReleaseButton(values_map.at(id))
 *         else :
 *             return False             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3495
 *             return False
 * 
 *     def releaseButton(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _releaseButton:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.releaseButton", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3516
 * 
 * 
 *     def getValueFloatPrecision(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueFloatPrecision: Gets a float value's precision
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_221getValueFloatPrecision(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_220getValueFloatPrecision[] = "\n.. _getValueFloatPrecision: Gets a float value's precision\n\n:param id: The unique identifier of the value.\n:type id: int\n:return: a float value's precision.\n:rtype: int\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_221getValueFloatPrecision(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getValueFloatPrecision (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_220getValueFloatPrecision(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_220getValueFloatPrecision(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  uint8_t __pyx_v_precision;
  bool __pyx_v_success;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("getValueFloatPrecision", 0);

  /* "libopenzwave.pyx":3527
 *         '''
 *         cdef uint8_t precision
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             success = self.manager.GetValueFloatPrecision(values_map.at(id), &precision)
 *             return precision if success else None
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3527, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3528
 *         cdef uint8_t precision
 *         if values_map.find(id) != values_map.end():
 *             success = self.manager.GetValueFloatPrecision(values_map.at(id), &precision)             # <<<<<<<<<<<<<<
 *             return precision if success else None
 *         return None
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3528, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3528, __pyx_L1_error)
    }
    __pyx_v_success = __pyx_v_self->manager->GetValueFloatPrecision(__pyx_t_3, (&__pyx_v_precision));

    /* "libopenzwave.pyx":3529
 *         if values_map.find(id) != values_map.end():
 *             success = self.manager.GetValueFloatPrecision(values_map.at(id), &precision)
 *             return precision if success else None             # <<<<<<<<<<<<<<
 *         return None
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    if ((__pyx_v_success != 0)) {
      __pyx_t_5 = __Pyx_PyInt_From_uint8_t(__pyx_v_precision); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3529, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_4 = __pyx_t_5;
      __pyx_t_5 = 0;
    } else {
      __Pyx_INCREF(Py_None);
      __pyx_t_4 = Py_None;
    }
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3527
 *         '''
 *         cdef uint8_t precision
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             success = self.manager.GetValueFloatPrecision(values_map.at(id), &precision)
 *             return precision if success else None
 */
  }

  /* "libopenzwave.pyx":3530
 *             success = self.manager.GetValueFloatPrecision(values_map.at(id), &precision)
 *             return precision if success else None
 *         return None             # <<<<<<<<<<<<<<
 * 
 *     def getChangeVerified(self, id):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_None);
  __pyx_r = Py_None;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3516
 * 
 * 
 *     def getValueFloatPrecision(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getValueFloatPrecision: Gets a float value's precision
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("libopenzwave.PyManager.getValueFloatPrecision", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3532
 *         return None
 * 
 *     def getChangeVerified(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getChangeVerified: determine if value changes upon a refresh should be verified.
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_223getChangeVerified(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_222getChangeVerified[] = "\n.. _getChangeVerified: determine if value changes upon a refresh should be verified.\n\nIf so, the library will immediately refresh the value a second time whenever a change is observed.\nThis helps to filter out spurious data reported occasionally by some devices.\n\n:param id:  The unique identifier of the value whose changes should or should not be verified.\n:type id: int\n:return: True if is verified.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_223getChangeVerified(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getChangeVerified (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_222getChangeVerified(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_222getChangeVerified(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getChangeVerified", 0);

  /* "libopenzwave.pyx":3546
 *         '''
 * 
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.GetChangeVerified(values_map.at(id))
 *         return False
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3546, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3547
 * 
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.GetChangeVerified(values_map.at(id))             # <<<<<<<<<<<<<<
 *         return False
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3547, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3547, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->GetChangeVerified(__pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3547, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3546
 *         '''
 * 
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.GetChangeVerified(values_map.at(id))
 *         return False
 */
  }

  /* "libopenzwave.pyx":3548
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.GetChangeVerified(values_map.at(id))
 *         return False             # <<<<<<<<<<<<<<
 * 
 *     def setChangeVerified(self, id, verify ):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_False);
  __pyx_r = Py_False;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3532
 *         return None
 * 
 *     def getChangeVerified(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getChangeVerified: determine if value changes upon a refresh should be verified.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getChangeVerified", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3550
 *         return False
 * 
 *     def setChangeVerified(self, id, verify ):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setChangeVerified: Sets a flag indicating whether value changes noted upon a refresh should be verified.
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_225setChangeVerified(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_224setChangeVerified[] = "\n.. _setChangeVerified: Sets a flag indicating whether value changes noted upon a refresh should be verified.\n\nIf so, the library will immediately refresh the value a second time whenever a change is observed. This helps to filter out spurious data reported occasionally by some devices.\n\n:param id: The unique identifier of the value whose changes should or should not be verified.\n:type id: int\n:param verify: if true, verify changes; if false, don't verify changes\n:type verify: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_225setChangeVerified(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_id = 0;
  PyObject *__pyx_v_verify = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setChangeVerified (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_verify,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_verify)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setChangeVerified", 1, 2, 2, 1); __PYX_ERR(0, 3550, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setChangeVerified") < 0)) __PYX_ERR(0, 3550, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_id = values[0];
    __pyx_v_verify = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setChangeVerified", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3550, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setChangeVerified", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_224setChangeVerified(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_id, __pyx_v_verify);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_224setChangeVerified(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_verify) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  bool __pyx_t_4;
  __Pyx_RefNannySetupContext("setChangeVerified", 0);

  /* "libopenzwave.pyx":3563
 *         '''
 * 
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             self.manager.SetChangeVerified(values_map.at(id), verify)
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3563, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3564
 * 
 *         if values_map.find(id) != values_map.end():
 *             self.manager.SetChangeVerified(values_map.at(id), verify)             # <<<<<<<<<<<<<<
 * 
 * #
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3564, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3564, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_verify); if (unlikely((__pyx_t_4 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3564, __pyx_L1_error)
    __pyx_v_self->manager->SetChangeVerified(__pyx_t_3, __pyx_t_4);

    /* "libopenzwave.pyx":3563
 *         '''
 * 
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             self.manager.SetChangeVerified(values_map.at(id), verify)
 * 
 */
  }

  /* "libopenzwave.pyx":3550
 *         return False
 * 
 *     def setChangeVerified(self, id, verify ):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setChangeVerified: Sets a flag indicating whether value changes noted upon a refresh should be verified.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setChangeVerified", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3581
 * # have been made, they are sent to the device by calling SetSchedule.
 * #
 *     def setSwitchPoint(self, id, hours, minutes, setback):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setSwitchPoint:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_227setSwitchPoint(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_226setSwitchPoint[] = "\n.. _setSwitchPoint:\n\nSet a switch point in the schedule.\n\n:param id: The unique identifier of the schedule value.\n:type id: int\n:param hours: The hours part of the time when the switch point will trigger. The time is set using the 24-hour clock, so this value must be between 0 and 23.\n:type hours: int\n:param minutes: The minutes part of the time when the switch point will trigger.  This value must be between 0 and 59.\n:type minutes: int\n:param setback: The setback in tenths of a degree Celsius.  The setback value can range from -128 (-12.8C) to 120 (12.0C).  There are two special setback values - 121 is used to set Frost Protection mode, and 122 is used to set Energy Saving mode.\n:type setback: int\n:return: True if the switch point is set.\n:rtype: bool\n:see: removeSwitchPoint_, clearSwitchPoints_, getSwitchPoint_, getNumSwitchPoints_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_227setSwitchPoint(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_id = 0;
  PyObject *__pyx_v_hours = 0;
  PyObject *__pyx_v_minutes = 0;
  PyObject *__pyx_v_setback = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setSwitchPoint (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_hours,&__pyx_n_s_minutes,&__pyx_n_s_setback,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_hours)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setSwitchPoint", 1, 4, 4, 1); __PYX_ERR(0, 3581, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_minutes)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setSwitchPoint", 1, 4, 4, 2); __PYX_ERR(0, 3581, __pyx_L3_error)
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_setback)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setSwitchPoint", 1, 4, 4, 3); __PYX_ERR(0, 3581, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setSwitchPoint") < 0)) __PYX_ERR(0, 3581, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_id = values[0];
    __pyx_v_hours = values[1];
    __pyx_v_minutes = values[2];
    __pyx_v_setback = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setSwitchPoint", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3581, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setSwitchPoint", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_226setSwitchPoint(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_id, __pyx_v_hours, __pyx_v_minutes, __pyx_v_setback);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_226setSwitchPoint(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_hours, PyObject *__pyx_v_minutes, PyObject *__pyx_v_setback) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  uint8_t __pyx_t_4;
  uint8_t __pyx_t_5;
  uint8_t __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  __Pyx_RefNannySetupContext("setSwitchPoint", 0);

  /* "libopenzwave.pyx":3600
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.SetSwitchPoint(values_map.at(id), hours, minutes, setback)
 *         else :
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3600, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3601
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.SetSwitchPoint(values_map.at(id), hours, minutes, setback)             # <<<<<<<<<<<<<<
 *         else :
 *             return False
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3601, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3601, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyInt_As_uint8_t(__pyx_v_hours); if (unlikely((__pyx_t_4 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3601, __pyx_L1_error)
    __pyx_t_5 = __Pyx_PyInt_As_uint8_t(__pyx_v_minutes); if (unlikely((__pyx_t_5 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3601, __pyx_L1_error)
    __pyx_t_6 = __Pyx_PyInt_As_uint8_t(__pyx_v_setback); if (unlikely((__pyx_t_6 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3601, __pyx_L1_error)
    __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->SetSwitchPoint(__pyx_t_3, __pyx_t_4, __pyx_t_5, __pyx_t_6)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3601, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_r = __pyx_t_7;
    __pyx_t_7 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3600
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.SetSwitchPoint(values_map.at(id), hours, minutes, setback)
 *         else :
 */
  }

  /* "libopenzwave.pyx":3603
 *             return self.manager.SetSwitchPoint(values_map.at(id), hours, minutes, setback)
 *         else :
 *             return False             # <<<<<<<<<<<<<<
 * 
 *     def removeSwitchPoint(self, id, hours, minutes):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3581
 * # have been made, they are sent to the device by calling SetSchedule.
 * #
 *     def setSwitchPoint(self, id, hours, minutes, setback):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setSwitchPoint:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("libopenzwave.PyManager.setSwitchPoint", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3605
 *             return False
 * 
 *     def removeSwitchPoint(self, id, hours, minutes):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeSwitchPoint:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_229removeSwitchPoint(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_228removeSwitchPoint[] = "\n.. _removeSwitchPoint:\n\nRemove a switch point from the schedule\n\n:param id: The unique identifier of the schedule value.\n:type id: int\n:param hours: The hours part of the time when the switch point will trigger.  The time is set using the 24-hour clock, so this value must be between 0 and 23.\n:type hours: int\n:param minutes: The minutes part of the time when the switch point will trigger.  This value must be between 0 and 59.\n:type minutes: int\n:return: True if the switch point is removed.\n:rtype: bool\n:see: setSwitchPoint_, clearSwitchPoints_, getSwitchPoint_, getNumSwitchPoints_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_229removeSwitchPoint(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_id = 0;
  PyObject *__pyx_v_hours = 0;
  PyObject *__pyx_v_minutes = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("removeSwitchPoint (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_hours,&__pyx_n_s_minutes,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_hours)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("removeSwitchPoint", 1, 3, 3, 1); __PYX_ERR(0, 3605, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_minutes)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("removeSwitchPoint", 1, 3, 3, 2); __PYX_ERR(0, 3605, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "removeSwitchPoint") < 0)) __PYX_ERR(0, 3605, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_id = values[0];
    __pyx_v_hours = values[1];
    __pyx_v_minutes = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("removeSwitchPoint", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3605, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.removeSwitchPoint", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_228removeSwitchPoint(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_id, __pyx_v_hours, __pyx_v_minutes);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_228removeSwitchPoint(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_hours, PyObject *__pyx_v_minutes) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  uint8_t __pyx_t_4;
  uint8_t __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannySetupContext("removeSwitchPoint", 0);

  /* "libopenzwave.pyx":3622
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.RemoveSwitchPoint(values_map.at(id), hours, minutes)
 *         else :
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3622, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3623
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.RemoveSwitchPoint(values_map.at(id), hours, minutes)             # <<<<<<<<<<<<<<
 *         else :
 *             return False
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3623, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3623, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyInt_As_uint8_t(__pyx_v_hours); if (unlikely((__pyx_t_4 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3623, __pyx_L1_error)
    __pyx_t_5 = __Pyx_PyInt_As_uint8_t(__pyx_v_minutes); if (unlikely((__pyx_t_5 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3623, __pyx_L1_error)
    __pyx_t_6 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->RemoveSwitchPoint(__pyx_t_3, __pyx_t_4, __pyx_t_5)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3623, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_r = __pyx_t_6;
    __pyx_t_6 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3622
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.RemoveSwitchPoint(values_map.at(id), hours, minutes)
 *         else :
 */
  }

  /* "libopenzwave.pyx":3625
 *             return self.manager.RemoveSwitchPoint(values_map.at(id), hours, minutes)
 *         else :
 *             return False             # <<<<<<<<<<<<<<
 * 
 *     def clearSwitchPoints(self, id):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3605
 *             return False
 * 
 *     def removeSwitchPoint(self, id, hours, minutes):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeSwitchPoint:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("libopenzwave.PyManager.removeSwitchPoint", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3627
 *             return False
 * 
 *     def clearSwitchPoints(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _clearSwitchPoints:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_231clearSwitchPoints(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_230clearSwitchPoints[] = "\n.. _clearSwitchPoints:\n\nClears all switch points from the schedule\n\n:param id: The unique identifier of the schedule value.\n:type id: int\n:return: True if all switch points are clear.\n:rtype: bool\n:see: setSwitchPoint_, removeSwitchPoint_, getSwitchPoint_, getNumSwitchPoints_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_231clearSwitchPoints(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("clearSwitchPoints (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_230clearSwitchPoints(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_230clearSwitchPoints(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  __Pyx_RefNannySetupContext("clearSwitchPoints", 0);

  /* "libopenzwave.pyx":3640
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             self.manager.ClearSwitchPoints(values_map.at(id))
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3640, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3641
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             self.manager.ClearSwitchPoints(values_map.at(id))             # <<<<<<<<<<<<<<
 * 
 *     def getSwitchPoint(self, id, idx, hours, minutes, setback):
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3641, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3641, __pyx_L1_error)
    }
    __pyx_v_self->manager->ClearSwitchPoints(__pyx_t_3);

    /* "libopenzwave.pyx":3640
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             self.manager.ClearSwitchPoints(values_map.at(id))
 * 
 */
  }

  /* "libopenzwave.pyx":3627
 *             return False
 * 
 *     def clearSwitchPoints(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _clearSwitchPoints:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.clearSwitchPoints", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3643
 *             self.manager.ClearSwitchPoints(values_map.at(id))
 * 
 *     def getSwitchPoint(self, id, idx, hours, minutes, setback):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getSwitchPoint:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_233getSwitchPoint(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_232getSwitchPoint[] = "\n.. _getSwitchPoint:\n\nGets switch point data from the schedule\n\n:param id: The unique identifier of the schedule value.\n:type id: int\n:param idx: The index of the switch point, between zero and one less than the value returned by GetNumSwitchPoints.\n:type idx: int\n:param hours: An integer that will be filled with the hours part of the switch point data.\n:type hours: int\n:param minutes: An integer that will be filled with the minutes part of the switch point data.\n:type minutes: int\n:param setback: An integer that will be filled with the setback value.  This can range from -128 (-12.8C)to 120 (12.0C).  There are two special setback values - 121 is used to set Frost Protection mode, and 122 is used to set Energy Saving mode.\n:type setback: int\n:return: True if successful.  Returns False if the value is not a ValueID::ValueType_Schedule. The type can be tested with a call to ValueID::GetType.\n:rtype: bool\n:see: setSwitchPoint_, removeSwitchPoint_, clearSwitchPoints_, getNumSwitchPoints_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_233getSwitchPoint(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_id = 0;
  PyObject *__pyx_v_idx = 0;
  CYTHON_UNUSED PyObject *__pyx_v_hours = 0;
  CYTHON_UNUSED PyObject *__pyx_v_minutes = 0;
  CYTHON_UNUSED PyObject *__pyx_v_setback = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getSwitchPoint (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_idx,&__pyx_n_s_hours,&__pyx_n_s_minutes,&__pyx_n_s_setback,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_idx)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getSwitchPoint", 1, 5, 5, 1); __PYX_ERR(0, 3643, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_hours)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getSwitchPoint", 1, 5, 5, 2); __PYX_ERR(0, 3643, __pyx_L3_error)
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_minutes)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getSwitchPoint", 1, 5, 5, 3); __PYX_ERR(0, 3643, __pyx_L3_error)
        }
        case  4:
        if (likely((values[4] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_setback)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getSwitchPoint", 1, 5, 5, 4); __PYX_ERR(0, 3643, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getSwitchPoint") < 0)) __PYX_ERR(0, 3643, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 5) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
      values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
    }
    __pyx_v_id = values[0];
    __pyx_v_idx = values[1];
    __pyx_v_hours = values[2];
    __pyx_v_minutes = values[3];
    __pyx_v_setback = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getSwitchPoint", 1, 5, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3643, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getSwitchPoint", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_232getSwitchPoint(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_id, __pyx_v_idx, __pyx_v_hours, __pyx_v_minutes, __pyx_v_setback);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_232getSwitchPoint(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_idx, CYTHON_UNUSED PyObject *__pyx_v_hours, CYTHON_UNUSED PyObject *__pyx_v_minutes, CYTHON_UNUSED PyObject *__pyx_v_setback) {
  uint8_t __pyx_v_ohours;
  uint8_t __pyx_v_ominutes;
  int8_t __pyx_v_osetback;
  bool __pyx_v_ret;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  uint8_t __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("getSwitchPoint", 0);
  __Pyx_INCREF(__pyx_v_hours);
  __Pyx_INCREF(__pyx_v_minutes);
  __Pyx_INCREF(__pyx_v_setback);

  /* "libopenzwave.pyx":3667
 *         cdef uint8_t ominutes
 *         cdef int8_t osetback
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             ret=self.manager.GetSwitchPoint(values_map.at(id), idx, \
 *                 &ohours, &ominutes, &osetback)
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3667, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3668
 *         cdef int8_t osetback
 *         if values_map.find(id) != values_map.end():
 *             ret=self.manager.GetSwitchPoint(values_map.at(id), idx, \             # <<<<<<<<<<<<<<
 *                 &ohours, &ominutes, &osetback)
 *             if ret :
 */
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3668, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3668, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyInt_As_uint8_t(__pyx_v_idx); if (unlikely((__pyx_t_4 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3668, __pyx_L1_error)

    /* "libopenzwave.pyx":3669
 *         if values_map.find(id) != values_map.end():
 *             ret=self.manager.GetSwitchPoint(values_map.at(id), idx, \
 *                 &ohours, &ominutes, &osetback)             # <<<<<<<<<<<<<<
 *             if ret :
 *                 hours = ohours
 */
    __pyx_v_ret = __pyx_v_self->manager->GetSwitchPoint(__pyx_t_3, __pyx_t_4, (&__pyx_v_ohours), (&__pyx_v_ominutes), (&__pyx_v_osetback));

    /* "libopenzwave.pyx":3670
 *             ret=self.manager.GetSwitchPoint(values_map.at(id), idx, \
 *                 &ohours, &ominutes, &osetback)
 *             if ret :             # <<<<<<<<<<<<<<
 *                 hours = ohours
 *                 minutes = ominutes
 */
    __pyx_t_2 = (__pyx_v_ret != 0);
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":3671
 *                 &ohours, &ominutes, &osetback)
 *             if ret :
 *                 hours = ohours             # <<<<<<<<<<<<<<
 *                 minutes = ominutes
 *                 setback = osetback
 */
      __pyx_t_5 = __Pyx_PyInt_From_uint8_t(__pyx_v_ohours); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3671, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF_SET(__pyx_v_hours, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "libopenzwave.pyx":3672
 *             if ret :
 *                 hours = ohours
 *                 minutes = ominutes             # <<<<<<<<<<<<<<
 *                 setback = osetback
 *             return ret
 */
      __pyx_t_5 = __Pyx_PyInt_From_uint8_t(__pyx_v_ominutes); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3672, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF_SET(__pyx_v_minutes, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "libopenzwave.pyx":3673
 *                 hours = ohours
 *                 minutes = ominutes
 *                 setback = osetback             # <<<<<<<<<<<<<<
 *             return ret
 *         else :
 */
      __pyx_t_5 = __Pyx_PyInt_From_int8_t(__pyx_v_osetback); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3673, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF_SET(__pyx_v_setback, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "libopenzwave.pyx":3670
 *             ret=self.manager.GetSwitchPoint(values_map.at(id), idx, \
 *                 &ohours, &ominutes, &osetback)
 *             if ret :             # <<<<<<<<<<<<<<
 *                 hours = ohours
 *                 minutes = ominutes
 */
    }

    /* "libopenzwave.pyx":3674
 *                 minutes = ominutes
 *                 setback = osetback
 *             return ret             # <<<<<<<<<<<<<<
 *         else :
 *             return False
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_5 = __Pyx_PyBool_FromLong(__pyx_v_ret); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3674, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_r = __pyx_t_5;
    __pyx_t_5 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3667
 *         cdef uint8_t ominutes
 *         cdef int8_t osetback
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             ret=self.manager.GetSwitchPoint(values_map.at(id), idx, \
 *                 &ohours, &ominutes, &osetback)
 */
  }

  /* "libopenzwave.pyx":3676
 *             return ret
 *         else :
 *             return False             # <<<<<<<<<<<<<<
 * #        return False
 * 
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3643
 *             self.manager.ClearSwitchPoints(values_map.at(id))
 * 
 *     def getSwitchPoint(self, id, idx, hours, minutes, setback):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getSwitchPoint:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("libopenzwave.PyManager.getSwitchPoint", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_hours);
  __Pyx_XDECREF(__pyx_v_minutes);
  __Pyx_XDECREF(__pyx_v_setback);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3679
 * #        return False
 * 
 *     def getNumSwitchPoints(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNumSwitchPoints:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_235getNumSwitchPoints(PyObject *__pyx_v_self, PyObject *__pyx_v_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_234getNumSwitchPoints[] = "\n.. _getNumSwitchPoints:\n\nGet the number of switch points defined in a schedule\n\n:param id: The unique identifier of the schedule value.\n:type id: int\n:return: The number of switch points defined in this schedule.  Returns zero if the value is not a ValueID::ValueType_Schedule. The type can be tested with a call to ValueID::GetType.\n:rtype: int\n:see: setSwitchPoint_, removeSwitchPoint_, clearSwitchPoints_, getSwitchPoint_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_235getNumSwitchPoints(PyObject *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNumSwitchPoints (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_234getNumSwitchPoints(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_234getNumSwitchPoints(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getNumSwitchPoints", 0);

  /* "libopenzwave.pyx":3692
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.GetNumSwitchPoints(values_map.at(id))
 *         else :
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3692, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":3693
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.GetNumSwitchPoints(values_map.at(id))             # <<<<<<<<<<<<<<
 *         else :
 *             return 0
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3693, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 3693, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyInt_From_uint8_t(__pyx_v_self->manager->GetNumSwitchPoints(__pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3693, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3692
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.GetNumSwitchPoints(values_map.at(id))
 *         else :
 */
  }

  /* "libopenzwave.pyx":3695
 *             return self.manager.GetNumSwitchPoints(values_map.at(id))
 *         else :
 *             return 0             # <<<<<<<<<<<<<<
 * 
 * #
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_0);
    __pyx_r = __pyx_int_0;
    goto __pyx_L0;
  }

  /* "libopenzwave.pyx":3679
 * #        return False
 * 
 *     def getNumSwitchPoints(self, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNumSwitchPoints:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNumSwitchPoints", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3706
 * # not routed, the message might not otherwise reach all the nodes).
 * #
 *     def switchAllOn(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _switchAllOn:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_237switchAllOn(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_236switchAllOn[] = "\n.. _switchAllOn:\n\nSwitch all devices on.  All devices that support the SwitchAll command class\nwill be turned on.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:see: switchAllOff_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_237switchAllOn(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("switchAllOn (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_236switchAllOn(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_236switchAllOn(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  __Pyx_RefNannySetupContext("switchAllOn", 0);

  /* "libopenzwave.pyx":3718
 * 
 *         '''
 *         self.manager.SwitchAllOn(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def switchAllOff(self, homeid):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3718, __pyx_L1_error)
  __pyx_v_self->manager->SwitchAllOn(__pyx_t_1);

  /* "libopenzwave.pyx":3706
 * # not routed, the message might not otherwise reach all the nodes).
 * #
 *     def switchAllOn(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _switchAllOn:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.switchAllOn", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3720
 *         self.manager.SwitchAllOn(homeid)
 * 
 *     def switchAllOff(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _switchAllOff:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_239switchAllOff(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_238switchAllOff[] = "\n.. _switchAllOff:\n\nSwitch all devices off.  All devices that support the SwitchAll command class\nwill be turned off.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:see: switchAllOn_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_239switchAllOff(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("switchAllOff (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_238switchAllOff(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_238switchAllOff(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  __Pyx_RefNannySetupContext("switchAllOff", 0);

  /* "libopenzwave.pyx":3732
 * 
 *         '''
 *         self.manager.SwitchAllOff(homeid)             # <<<<<<<<<<<<<<
 * 
 * # -----------------------------------------------------------------------------
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3732, __pyx_L1_error)
  __pyx_v_self->manager->SwitchAllOff(__pyx_t_1);

  /* "libopenzwave.pyx":3720
 *         self.manager.SwitchAllOn(homeid)
 * 
 *     def switchAllOff(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _switchAllOff:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.switchAllOff", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3745
 * # parameters for every Z-Wave.  See the config folder in the project source code for examples.
 * #
 *     def setConfigParam(self, homeid, nodeid, param, value, size=2):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setConfigParam:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_241setConfigParam(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_240setConfigParam[] = "\n.. _setConfigParam:\n\nSet the value of a configurable parameter in a device.\n\nSome devices have various parameters that can be configured to control the\ndevice behaviour.  These are not reported by the device over the Z-Wave network\nbut can usually be found in the devices user manual.  This method returns\nimmediately, without waiting for confirmation from the device that the change\nhas been made.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to configure.\n:type nodeId: int\n:param param: The index of the parameter.\n:type param: int\n:param value: The value to which the parameter should be set.\n:type value: int\n:param size: Is an optional number of bytes to be sent for the parameter value. Defaults to 2.\n:type size: int\n:return: True if the message setting the value was sent to the device.\n:rtype: bool\n:see: requestConfigParam_, requestAllConfigParams_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_241setConfigParam(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_param = 0;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_v_size = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setConfigParam (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_param,&__pyx_n_s_value,&__pyx_n_s_size,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[4] = ((PyObject *)__pyx_int_2);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setConfigParam", 0, 4, 5, 1); __PYX_ERR(0, 3745, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_param)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setConfigParam", 0, 4, 5, 2); __PYX_ERR(0, 3745, __pyx_L3_error)
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setConfigParam", 0, 4, 5, 3); __PYX_ERR(0, 3745, __pyx_L3_error)
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_size);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setConfigParam") < 0)) __PYX_ERR(0, 3745, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_param = values[2];
    __pyx_v_value = values[3];
    __pyx_v_size = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setConfigParam", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3745, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setConfigParam", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_240setConfigParam(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_param, __pyx_v_value, __pyx_v_size);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_240setConfigParam(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_param, PyObject *__pyx_v_value, PyObject *__pyx_v_size) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  uint8_t __pyx_t_3;
  uint32_t __pyx_t_4;
  uint8_t __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannySetupContext("setConfigParam", 0);

  /* "libopenzwave.pyx":3772
 * 
 *         '''
 *         return self.manager.SetConfigParam(homeid, nodeid, param, value, size)             # <<<<<<<<<<<<<<
 * 
 *     def requestConfigParam(self, homeid, nodeid, param):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3772, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3772, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_As_uint8_t(__pyx_v_param); if (unlikely((__pyx_t_3 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3772, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyInt_As_uint32_t(__pyx_v_value); if (unlikely((__pyx_t_4 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3772, __pyx_L1_error)
  __pyx_t_5 = __Pyx_PyInt_As_uint8_t(__pyx_v_size); if (unlikely((__pyx_t_5 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3772, __pyx_L1_error)
  __pyx_t_6 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->SetConfigParam(__pyx_t_1, __pyx_t_2, __pyx_t_3, __pyx_t_4, __pyx_t_5)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3772, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_r = __pyx_t_6;
  __pyx_t_6 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3745
 * # parameters for every Z-Wave.  See the config folder in the project source code for examples.
 * #
 *     def setConfigParam(self, homeid, nodeid, param, value, size=2):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setConfigParam:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("libopenzwave.PyManager.setConfigParam", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3774
 *         return self.manager.SetConfigParam(homeid, nodeid, param, value, size)
 * 
 *     def requestConfigParam(self, homeid, nodeid, param):             # <<<<<<<<<<<<<<
 *         '''
 * .. _requestConfigParam:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_243requestConfigParam(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_242requestConfigParam[] = "\n.. _requestConfigParam:\n\nRequest the value of a configurable parameter from a device.\n\nSome devices have various parameters that can be configured to control the\ndevice behaviour.  These are not reported by the device over the Z-Wave network\nbut can usually be found in the devices user manual.  This method requests\nthe value of a parameter from the device, and then returns immediately,\nwithout waiting for a response.  If the parameter index is valid for this\ndevice, and the device is awake, the value will eventually be reported via a\nValueChanged notification callback.  The ValueID reported in the callback will\nhave an index set the same as _param and a command class set to the same value\nas returned by a call to Configuration::StaticGetCommandClassId.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to configure.\n:type nodeId: int\n:param param: The index of the parameter.\n:type param: int\n:see: requestAllConfigParams_, setConfigParam_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_243requestConfigParam(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_param = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("requestConfigParam (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_param,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("requestConfigParam", 1, 3, 3, 1); __PYX_ERR(0, 3774, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_param)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("requestConfigParam", 1, 3, 3, 2); __PYX_ERR(0, 3774, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "requestConfigParam") < 0)) __PYX_ERR(0, 3774, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_param = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("requestConfigParam", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3774, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.requestConfigParam", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_242requestConfigParam(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_param);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_242requestConfigParam(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_param) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  uint8_t __pyx_t_3;
  __Pyx_RefNannySetupContext("requestConfigParam", 0);

  /* "libopenzwave.pyx":3799
 * 
 *         '''
 *         self.manager.RequestConfigParam(homeid, nodeid, param)             # <<<<<<<<<<<<<<
 * 
 *     def requestAllConfigParams(self, homeid, nodeid):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3799, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3799, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_As_uint8_t(__pyx_v_param); if (unlikely((__pyx_t_3 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3799, __pyx_L1_error)
  __pyx_v_self->manager->RequestConfigParam(__pyx_t_1, __pyx_t_2, __pyx_t_3);

  /* "libopenzwave.pyx":3774
 *         return self.manager.SetConfigParam(homeid, nodeid, param, value, size)
 * 
 *     def requestConfigParam(self, homeid, nodeid, param):             # <<<<<<<<<<<<<<
 *         '''
 * .. _requestConfigParam:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.requestConfigParam", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3801
 *         self.manager.RequestConfigParam(homeid, nodeid, param)
 * 
 *     def requestAllConfigParams(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _requestAllConfigParams:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_245requestAllConfigParams(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_244requestAllConfigParams[] = "\n.. _requestAllConfigParams:\n\nRequest the values of all known configurable parameters from a device.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to configure.\n:type nodeId: int\n:see: requestConfigParam_, setConfigParam_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_245requestAllConfigParams(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("requestAllConfigParams (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("requestAllConfigParams", 1, 2, 2, 1); __PYX_ERR(0, 3801, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "requestAllConfigParams") < 0)) __PYX_ERR(0, 3801, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("requestAllConfigParams", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3801, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.requestAllConfigParams", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_244requestAllConfigParams(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_244requestAllConfigParams(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  __Pyx_RefNannySetupContext("requestAllConfigParams", 0);

  /* "libopenzwave.pyx":3814
 * 
 *         '''
 *         self.manager.RequestAllConfigParams(homeid, nodeid)             # <<<<<<<<<<<<<<
 * #
 * # -----------------------------------------------------------------------------
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3814, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3814, __pyx_L1_error)
  __pyx_v_self->manager->RequestAllConfigParams(__pyx_t_1, __pyx_t_2);

  /* "libopenzwave.pyx":3801
 *         self.manager.RequestConfigParam(homeid, nodeid, param)
 * 
 *     def requestAllConfigParams(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _requestAllConfigParams:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.requestAllConfigParams", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3821
 * # Methods for accessing device association groups.
 * #
 *     def getNumGroups(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNumGroups:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_247getNumGroups(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_246getNumGroups[] = "\n.. _getNumGroups:\n\nGets the number of association groups reported by this node\n\nIn Z-Wave, groups are numbered starting from one.  For example, if a call to\nGetNumGroups returns 4, the _groupIdx value to use in calls to GetAssociations\nAddAssociation and RemoveAssociation will be a number between 1 and 4.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node whose groups we are interested in.\n:type nodeId: int\n:return: The number of groups.\n:rtype: int\n:see: getAssociations_, getMaxAssociations_, addAssociation_, removeAssociation_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_247getNumGroups(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNumGroups (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getNumGroups", 1, 2, 2, 1); __PYX_ERR(0, 3821, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getNumGroups") < 0)) __PYX_ERR(0, 3821, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getNumGroups", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3821, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getNumGroups", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_246getNumGroups(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_246getNumGroups(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getNumGroups", 0);

  /* "libopenzwave.pyx":3840
 * 
 *         '''
 *         return self.manager.GetNumGroups(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def getAssociations(self, homeid, nodeid, groupidx):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3840, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3840, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_From_uint8_t(__pyx_v_self->manager->GetNumGroups(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3840, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3821
 * # Methods for accessing device association groups.
 * #
 *     def getNumGroups(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNumGroups:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNumGroups", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3842
 *         return self.manager.GetNumGroups(homeid, nodeid)
 * 
 *     def getAssociations(self, homeid, nodeid, groupidx):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getAssociations:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_249getAssociations(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_248getAssociations[] = "\n.. _getAssociations:\n\nGets the associations for a group\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node whose associations we are interested in.\n:type nodeId: int\n:param groupIdx: one-based index of the group (because Z-Wave product manuals use one-based group numbering).\n:type groupIdx: int\n:return: A set containing IDs of members of the group\n:rtype: set()\n:see: getNumGroups_, addAssociation_, removeAssociation_, getMaxAssociations_\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_249getAssociations(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_groupidx = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getAssociations (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_groupidx,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getAssociations", 1, 3, 3, 1); __PYX_ERR(0, 3842, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_groupidx)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getAssociations", 1, 3, 3, 2); __PYX_ERR(0, 3842, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getAssociations") < 0)) __PYX_ERR(0, 3842, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_groupidx = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getAssociations", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3842, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getAssociations", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_248getAssociations(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_groupidx);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_248getAssociations(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_groupidx) {
  PyObject *__pyx_v_x = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  Py_ssize_t __pyx_t_7;
  PyObject *(*__pyx_t_8)(PyObject *);
  int __pyx_t_9;
  __Pyx_RefNannySetupContext("getAssociations", 0);

  /* "libopenzwave.pyx":3887
 * #~                 pass
 * #~         return data
 *         return [ x[0] for x in self.getAssociationsInstances(homeid, nodeid, groupidx) if x[1] == 0x00 ]             # <<<<<<<<<<<<<<
 * 
 *     def getAssociationsInstances(self, homeid, nodeid, groupidx):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3887, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_getAssociationsInstances); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3887, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  __pyx_t_5 = 0;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
      __pyx_t_5 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_groupidx};
    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 3+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3887, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_2);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_groupidx};
    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 3+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3887, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_2);
  } else
  #endif
  {
    __pyx_t_6 = PyTuple_New(3+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3887, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (__pyx_t_4) {
      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
    }
    __Pyx_INCREF(__pyx_v_homeid);
    __Pyx_GIVEREF(__pyx_v_homeid);
    PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_homeid);
    __Pyx_INCREF(__pyx_v_nodeid);
    __Pyx_GIVEREF(__pyx_v_nodeid);
    PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_v_nodeid);
    __Pyx_INCREF(__pyx_v_groupidx);
    __Pyx_GIVEREF(__pyx_v_groupidx);
    PyTuple_SET_ITEM(__pyx_t_6, 2+__pyx_t_5, __pyx_v_groupidx);
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3887, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
    __pyx_t_3 = __pyx_t_2; __Pyx_INCREF(__pyx_t_3); __pyx_t_7 = 0;
    __pyx_t_8 = NULL;
  } else {
    __pyx_t_7 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3887, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_8 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3887, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  for (;;) {
    if (likely(!__pyx_t_8)) {
      if (likely(PyList_CheckExact(__pyx_t_3))) {
        if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_3)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_2 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_2); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 3887, __pyx_L1_error)
        #else
        __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3887, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        #endif
      } else {
        if (__pyx_t_7 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_2); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 3887, __pyx_L1_error)
        #else
        __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3887, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        #endif
      }
    } else {
      __pyx_t_2 = __pyx_t_8(__pyx_t_3);
      if (unlikely(!__pyx_t_2)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 3887, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_2);
    }
    __Pyx_XDECREF_SET(__pyx_v_x, __pyx_t_2);
    __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_x, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3887, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_6 = __Pyx_PyInt_EqObjC(__pyx_t_2, __pyx_int_0, 0x00, 0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3887, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 3887, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (__pyx_t_9) {
      __pyx_t_6 = __Pyx_GetItemInt(__pyx_v_x, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3887, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_6))) __PYX_ERR(0, 3887, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3842
 *         return self.manager.GetNumGroups(homeid, nodeid)
 * 
 *     def getAssociations(self, homeid, nodeid, groupidx):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getAssociations:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("libopenzwave.PyManager.getAssociations", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_x);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3889
 *         return [ x[0] for x in self.getAssociationsInstances(homeid, nodeid, groupidx) if x[1] == 0x00 ]
 * 
 *     def getAssociationsInstances(self, homeid, nodeid, groupidx):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getAssociationsInstances:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_251getAssociationsInstances(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_250getAssociationsInstances[] = "\n.. _getAssociationsInstances:\n\nGets the associationsInstances for a group\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node whose associations we are interested in.\n:type nodeId: int\n:param groupIdx: one-based index of the group (because Z-Wave product manuals use one-based group numbering).\n:type groupIdx: int\n:return: A set containing tuples containing the node_id and the instance\n:rtype: set((node_id,instance))\n:see: getNumGroups_, addAssociation_, removeAssociation_, getMaxAssociations_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_251getAssociationsInstances(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_groupidx = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getAssociationsInstances (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_groupidx,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getAssociationsInstances", 1, 3, 3, 1); __PYX_ERR(0, 3889, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_groupidx)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getAssociationsInstances", 1, 3, 3, 2); __PYX_ERR(0, 3889, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getAssociationsInstances") < 0)) __PYX_ERR(0, 3889, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_groupidx = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getAssociationsInstances", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3889, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getAssociationsInstances", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_250getAssociationsInstances(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_groupidx);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_250getAssociationsInstances(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_groupidx) {
  PyObject *__pyx_v_data = NULL;
  uint32_t __pyx_v_size;
  __pyx_t_7manager_struct_associations __pyx_v_dbuf;
  uint32_t __pyx_v_count;
  struct __pyx_obj_12libopenzwave_InstanceAssociationAlloc *__pyx_v_retassinst = 0;
  __pyx_t_5group_InstanceAssociation_t *__pyx_v_p;
  uint32_t __pyx_v_start;
  PyObject *__pyx_v_i = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  uint32_t __pyx_t_2;
  uint8_t __pyx_t_3;
  uint8_t __pyx_t_4;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  Py_ssize_t __pyx_t_8;
  PyObject *(*__pyx_t_9)(PyObject *);
  Py_ssize_t __pyx_t_10;
  PyObject *__pyx_t_11 = NULL;
  int __pyx_t_12;
  int __pyx_t_13;
  int __pyx_t_14;
  char const *__pyx_t_15;
  PyObject *__pyx_t_16 = NULL;
  PyObject *__pyx_t_17 = NULL;
  PyObject *__pyx_t_18 = NULL;
  PyObject *__pyx_t_19 = NULL;
  PyObject *__pyx_t_20 = NULL;
  PyObject *__pyx_t_21 = NULL;
  __Pyx_RefNannySetupContext("getAssociationsInstances", 0);

  /* "libopenzwave.pyx":3906
 * 
 *         '''
 *         data = set()             # <<<<<<<<<<<<<<
 *         cdef uint32_t size = self.manager.GetMaxAssociations(homeid, nodeid, groupidx)
 *         #Allocate memory
 */
  __pyx_t_1 = PySet_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3906, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_data = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "libopenzwave.pyx":3907
 *         '''
 *         data = set()
 *         cdef uint32_t size = self.manager.GetMaxAssociations(homeid, nodeid, groupidx)             # <<<<<<<<<<<<<<
 *         #Allocate memory
 *         cdef struct_associations dbuf = <struct_associations>malloc(sizeof(InstanceAssociation_t) * size)
 */
  __pyx_t_2 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_2 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3907, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_3 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3907, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyInt_As_uint8_t(__pyx_v_groupidx); if (unlikely((__pyx_t_4 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3907, __pyx_L1_error)
  __pyx_v_size = __pyx_v_self->manager->GetMaxAssociations(__pyx_t_2, __pyx_t_3, __pyx_t_4);

  /* "libopenzwave.pyx":3909
 *         cdef uint32_t size = self.manager.GetMaxAssociations(homeid, nodeid, groupidx)
 *         #Allocate memory
 *         cdef struct_associations dbuf = <struct_associations>malloc(sizeof(InstanceAssociation_t) * size)             # <<<<<<<<<<<<<<
 *         # return value is pointer to uint8_t[]
 *         cdef uint32_t count = self.manager.GetAssociations(homeid, nodeid, groupidx, dbuf)
 */
  __pyx_v_dbuf = ((__pyx_t_7manager_struct_associations)malloc(((sizeof(__pyx_t_5group_InstanceAssociation_t)) * __pyx_v_size)));

  /* "libopenzwave.pyx":3911
 *         cdef struct_associations dbuf = <struct_associations>malloc(sizeof(InstanceAssociation_t) * size)
 *         # return value is pointer to uint8_t[]
 *         cdef uint32_t count = self.manager.GetAssociations(homeid, nodeid, groupidx, dbuf)             # <<<<<<<<<<<<<<
 *         if count == 0:
 *             #Don't need to allocate memory.
 */
  __pyx_t_2 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_2 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3911, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_4 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3911, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_As_uint8_t(__pyx_v_groupidx); if (unlikely((__pyx_t_3 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3911, __pyx_L1_error)
  __pyx_v_count = __pyx_v_self->manager->GetAssociations(__pyx_t_2, __pyx_t_4, __pyx_t_3, __pyx_v_dbuf);

  /* "libopenzwave.pyx":3912
 *         # return value is pointer to uint8_t[]
 *         cdef uint32_t count = self.manager.GetAssociations(homeid, nodeid, groupidx, dbuf)
 *         if count == 0:             # <<<<<<<<<<<<<<
 *             #Don't need to allocate memory.
 *             free(dbuf)
 */
  __pyx_t_5 = ((__pyx_v_count == 0) != 0);
  if (__pyx_t_5) {

    /* "libopenzwave.pyx":3914
 *         if count == 0:
 *             #Don't need to allocate memory.
 *             free(dbuf)             # <<<<<<<<<<<<<<
 *             return data
 *         cdef InstanceAssociationAlloc retassinst = InstanceAssociationAlloc(count)
 */
    free(__pyx_v_dbuf);

    /* "libopenzwave.pyx":3915
 *             #Don't need to allocate memory.
 *             free(dbuf)
 *             return data             # <<<<<<<<<<<<<<
 *         cdef InstanceAssociationAlloc retassinst = InstanceAssociationAlloc(count)
 *         cdef InstanceAssociation_t* p
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_data);
    __pyx_r = __pyx_v_data;
    goto __pyx_L0;

    /* "libopenzwave.pyx":3912
 *         # return value is pointer to uint8_t[]
 *         cdef uint32_t count = self.manager.GetAssociations(homeid, nodeid, groupidx, dbuf)
 *         if count == 0:             # <<<<<<<<<<<<<<
 *             #Don't need to allocate memory.
 *             free(dbuf)
 */
  }

  /* "libopenzwave.pyx":3916
 *             free(dbuf)
 *             return data
 *         cdef InstanceAssociationAlloc retassinst = InstanceAssociationAlloc(count)             # <<<<<<<<<<<<<<
 *         cdef InstanceAssociation_t* p
 *         cdef uint32_t start = 0
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(__pyx_v_count); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3916, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3916, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_12libopenzwave_InstanceAssociationAlloc), __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3916, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_v_retassinst = ((struct __pyx_obj_12libopenzwave_InstanceAssociationAlloc *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "libopenzwave.pyx":3918
 *         cdef InstanceAssociationAlloc retassinst = InstanceAssociationAlloc(count)
 *         cdef InstanceAssociation_t* p
 *         cdef uint32_t start = 0             # <<<<<<<<<<<<<<
 *         if count:
 *             try:
 */
  __pyx_v_start = 0;

  /* "libopenzwave.pyx":3919
 *         cdef InstanceAssociation_t* p
 *         cdef uint32_t start = 0
 *         if count:             # <<<<<<<<<<<<<<
 *             try:
 *                 p = dbuf[0] # p is now pointing at first element of array
 */
  __pyx_t_5 = (__pyx_v_count != 0);
  if (__pyx_t_5) {

    /* "libopenzwave.pyx":3920
 *         cdef uint32_t start = 0
 *         if count:
 *             try:             # <<<<<<<<<<<<<<
 *                 p = dbuf[0] # p is now pointing at first element of array
 *                 for i in range(start, count):
 */
    /*try:*/ {

      /* "libopenzwave.pyx":3921
 *         if count:
 *             try:
 *                 p = dbuf[0] # p is now pointing at first element of array             # <<<<<<<<<<<<<<
 *                 for i in range(start, count):
 *                     retassinst.data[2*i] = p[0].m_nodeId
 */
      __pyx_v_p = (__pyx_v_dbuf[0]);

      /* "libopenzwave.pyx":3922
 *             try:
 *                 p = dbuf[0] # p is now pointing at first element of array
 *                 for i in range(start, count):             # <<<<<<<<<<<<<<
 *                     retassinst.data[2*i] = p[0].m_nodeId
 *                     retassinst.data[2*i+1] = p[0].m_instance
 */
      __pyx_t_1 = __Pyx_PyInt_From_uint32_t(__pyx_v_start); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3922, __pyx_L6_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_6 = __Pyx_PyInt_From_uint32_t(__pyx_v_count); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3922, __pyx_L6_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3922, __pyx_L6_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_GIVEREF(__pyx_t_1);
      PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_1);
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_6);
      __pyx_t_1 = 0;
      __pyx_t_6 = 0;
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_range, __pyx_t_7, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3922, __pyx_L6_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (likely(PyList_CheckExact(__pyx_t_6)) || PyTuple_CheckExact(__pyx_t_6)) {
        __pyx_t_7 = __pyx_t_6; __Pyx_INCREF(__pyx_t_7); __pyx_t_8 = 0;
        __pyx_t_9 = NULL;
      } else {
        __pyx_t_8 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3922, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_7);
        __pyx_t_9 = Py_TYPE(__pyx_t_7)->tp_iternext; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3922, __pyx_L6_error)
      }
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      for (;;) {
        if (likely(!__pyx_t_9)) {
          if (likely(PyList_CheckExact(__pyx_t_7))) {
            if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_7)) break;
            #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
            __pyx_t_6 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_6); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 3922, __pyx_L6_error)
            #else
            __pyx_t_6 = PySequence_ITEM(__pyx_t_7, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3922, __pyx_L6_error)
            __Pyx_GOTREF(__pyx_t_6);
            #endif
          } else {
            if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
            #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
            __pyx_t_6 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_6); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 3922, __pyx_L6_error)
            #else
            __pyx_t_6 = PySequence_ITEM(__pyx_t_7, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3922, __pyx_L6_error)
            __Pyx_GOTREF(__pyx_t_6);
            #endif
          }
        } else {
          __pyx_t_6 = __pyx_t_9(__pyx_t_7);
          if (unlikely(!__pyx_t_6)) {
            PyObject* exc_type = PyErr_Occurred();
            if (exc_type) {
              if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
              else __PYX_ERR(0, 3922, __pyx_L6_error)
            }
            break;
          }
          __Pyx_GOTREF(__pyx_t_6);
        }
        __Pyx_XDECREF_SET(__pyx_v_i, __pyx_t_6);
        __pyx_t_6 = 0;

        /* "libopenzwave.pyx":3923
 *                 p = dbuf[0] # p is now pointing at first element of array
 *                 for i in range(start, count):
 *                     retassinst.data[2*i] = p[0].m_nodeId             # <<<<<<<<<<<<<<
 *                     retassinst.data[2*i+1] = p[0].m_instance
 *                     data.add((retassinst.data[2*i],retassinst.data[2*i+1]))
 */
        __pyx_t_3 = (__pyx_v_p[0]).m_nodeId;
        __pyx_t_6 = PyNumber_Multiply(__pyx_int_2, __pyx_v_i); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3923, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_t_6); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 3923, __pyx_L6_error)
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        (__pyx_v_retassinst->data[__pyx_t_10]) = __pyx_t_3;

        /* "libopenzwave.pyx":3924
 *                 for i in range(start, count):
 *                     retassinst.data[2*i] = p[0].m_nodeId
 *                     retassinst.data[2*i+1] = p[0].m_instance             # <<<<<<<<<<<<<<
 *                     data.add((retassinst.data[2*i],retassinst.data[2*i+1]))
 *                     p += 1
 */
        __pyx_t_3 = (__pyx_v_p[0]).m_instance;
        __pyx_t_6 = PyNumber_Multiply(__pyx_int_2, __pyx_v_i); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3924, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_1 = __Pyx_PyInt_AddObjC(__pyx_t_6, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3924, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 3924, __pyx_L6_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        (__pyx_v_retassinst->data[__pyx_t_10]) = __pyx_t_3;

        /* "libopenzwave.pyx":3925
 *                     retassinst.data[2*i] = p[0].m_nodeId
 *                     retassinst.data[2*i+1] = p[0].m_instance
 *                     data.add((retassinst.data[2*i],retassinst.data[2*i+1]))             # <<<<<<<<<<<<<<
 *                     p += 1
 *             finally:
 */
        __pyx_t_1 = PyNumber_Multiply(__pyx_int_2, __pyx_v_i); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3925, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 3925, __pyx_L6_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_t_1 = __Pyx_PyInt_From_uint8_t((__pyx_v_retassinst->data[__pyx_t_10])); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3925, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_6 = PyNumber_Multiply(__pyx_int_2, __pyx_v_i); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3925, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_11 = __Pyx_PyInt_AddObjC(__pyx_t_6, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 3925, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_11);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_t_11); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 3925, __pyx_L6_error)
        __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
        __pyx_t_11 = __Pyx_PyInt_From_uint8_t((__pyx_v_retassinst->data[__pyx_t_10])); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 3925, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_11);
        __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3925, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_GIVEREF(__pyx_t_1);
        PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_1);
        __Pyx_GIVEREF(__pyx_t_11);
        PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_11);
        __pyx_t_1 = 0;
        __pyx_t_11 = 0;
        __pyx_t_12 = PySet_Add(__pyx_v_data, __pyx_t_6); if (unlikely(__pyx_t_12 == -1)) __PYX_ERR(0, 3925, __pyx_L6_error)
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

        /* "libopenzwave.pyx":3926
 *                     retassinst.data[2*i+1] = p[0].m_instance
 *                     data.add((retassinst.data[2*i],retassinst.data[2*i+1]))
 *                     p += 1             # <<<<<<<<<<<<<<
 *             finally:
 *                 # Free memory
 */
        __pyx_v_p = (__pyx_v_p + 1);

        /* "libopenzwave.pyx":3922
 *             try:
 *                 p = dbuf[0] # p is now pointing at first element of array
 *                 for i in range(start, count):             # <<<<<<<<<<<<<<
 *                     retassinst.data[2*i] = p[0].m_nodeId
 *                     retassinst.data[2*i+1] = p[0].m_instance
 */
      }
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }

    /* "libopenzwave.pyx":3929
 *             finally:
 *                 # Free memory
 *                 free(dbuf)             # <<<<<<<<<<<<<<
 *                 pass
 *         return data
 */
    /*finally:*/ {
      /*normal exit:*/{
        free(__pyx_v_dbuf);
        goto __pyx_L7;
      }
      /*exception exit:*/{
        __Pyx_PyThreadState_declare
        __pyx_L6_error:;
        __pyx_t_16 = 0; __pyx_t_17 = 0; __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0;
        __Pyx_PyThreadState_assign
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_19, &__pyx_t_20, &__pyx_t_21);
        if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_16, &__pyx_t_17, &__pyx_t_18) < 0)) __Pyx_ErrFetch(&__pyx_t_16, &__pyx_t_17, &__pyx_t_18);
        __Pyx_XGOTREF(__pyx_t_16);
        __Pyx_XGOTREF(__pyx_t_17);
        __Pyx_XGOTREF(__pyx_t_18);
        __Pyx_XGOTREF(__pyx_t_19);
        __Pyx_XGOTREF(__pyx_t_20);
        __Pyx_XGOTREF(__pyx_t_21);
        __pyx_t_13 = __pyx_lineno; __pyx_t_14 = __pyx_clineno; __pyx_t_15 = __pyx_filename;
        {
          free(__pyx_v_dbuf);
        }
        __Pyx_PyThreadState_assign
        if (PY_MAJOR_VERSION >= 3) {
          __Pyx_XGIVEREF(__pyx_t_19);
          __Pyx_XGIVEREF(__pyx_t_20);
          __Pyx_XGIVEREF(__pyx_t_21);
          __Pyx_ExceptionReset(__pyx_t_19, __pyx_t_20, __pyx_t_21);
        }
        __Pyx_XGIVEREF(__pyx_t_16);
        __Pyx_XGIVEREF(__pyx_t_17);
        __Pyx_XGIVEREF(__pyx_t_18);
        __Pyx_ErrRestore(__pyx_t_16, __pyx_t_17, __pyx_t_18);
        __pyx_t_16 = 0; __pyx_t_17 = 0; __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0;
        __pyx_lineno = __pyx_t_13; __pyx_clineno = __pyx_t_14; __pyx_filename = __pyx_t_15;
        goto __pyx_L1_error;
      }
      __pyx_L7:;
    }

    /* "libopenzwave.pyx":3919
 *         cdef InstanceAssociation_t* p
 *         cdef uint32_t start = 0
 *         if count:             # <<<<<<<<<<<<<<
 *             try:
 *                 p = dbuf[0] # p is now pointing at first element of array
 */
  }

  /* "libopenzwave.pyx":3931
 *                 free(dbuf)
 *                 pass
 *         return data             # <<<<<<<<<<<<<<
 * 
 *     def getMaxAssociations(self, homeid, nodeid, groupidx):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_data);
  __pyx_r = __pyx_v_data;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3889
 *         return [ x[0] for x in self.getAssociationsInstances(homeid, nodeid, groupidx) if x[1] == 0x00 ]
 * 
 *     def getAssociationsInstances(self, homeid, nodeid, groupidx):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getAssociationsInstances:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_AddTraceback("libopenzwave.PyManager.getAssociationsInstances", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_data);
  __Pyx_XDECREF((PyObject *)__pyx_v_retassinst);
  __Pyx_XDECREF(__pyx_v_i);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3933
 *         return data
 * 
 *     def getMaxAssociations(self, homeid, nodeid, groupidx):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getMaxAssociations:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_253getMaxAssociations(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_252getMaxAssociations[] = "\n.. _getMaxAssociations:\n\nGets the maximum number of associations for a group.\n\n:param homeid: The Home ID of the Z-Wave controller that manages the node.\n:type homeid: int\n:param nodeid: The ID of the node whose associations we are interested in.\n:type nodeid: int\n:param groupidx: One-based index of the group (because Z-Wave product manuals use one-based group numbering).\n:type groupidx: int\n:return: The maximum number of nodes that can be associated into the group.\n:rtype: int\n:see: getNumGroups_, addAssociation_, removeAssociation_, getAssociations_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_253getMaxAssociations(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_groupidx = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getMaxAssociations (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_groupidx,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getMaxAssociations", 1, 3, 3, 1); __PYX_ERR(0, 3933, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_groupidx)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getMaxAssociations", 1, 3, 3, 2); __PYX_ERR(0, 3933, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getMaxAssociations") < 0)) __PYX_ERR(0, 3933, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_groupidx = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getMaxAssociations", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3933, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getMaxAssociations", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_252getMaxAssociations(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_groupidx);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_252getMaxAssociations(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_groupidx) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  uint8_t __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getMaxAssociations", 0);

  /* "libopenzwave.pyx":3950
 * 
 *         '''
 *         return self.manager.GetMaxAssociations(homeid, nodeid, groupidx)             # <<<<<<<<<<<<<<
 * 
 *     def getGroupLabel(self, homeid, nodeid, groupidx):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3950, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3950, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_As_uint8_t(__pyx_v_groupidx); if (unlikely((__pyx_t_3 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3950, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyInt_From_uint8_t(__pyx_v_self->manager->GetMaxAssociations(__pyx_t_1, __pyx_t_2, __pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3950, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3933
 *         return data
 * 
 *     def getMaxAssociations(self, homeid, nodeid, groupidx):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getMaxAssociations:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.getMaxAssociations", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3952
 *         return self.manager.GetMaxAssociations(homeid, nodeid, groupidx)
 * 
 *     def getGroupLabel(self, homeid, nodeid, groupidx):             # <<<<<<<<<<<<<<
 *         '''
 * Returns a label for the particular group of a node.
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_255getGroupLabel(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_254getGroupLabel[] = "\nReturns a label for the particular group of a node.\n\n.. _getGroupLabel:\n\nThis label is populated by the device specific configuration files.\n\n:param homeid: The Home ID of the Z-Wave controller that manages the node.\n:type homeid: int\n:param nodeid: The ID of the node whose associations are to be changed.\n:type nodeid: int\n:param groupidx: One-based index of the group (because Z-Wave product manuals use one-based group numbering).\n:type groupidx: int\n:return: The label for the particular group of a node.\n:rtype: str\n:see: getNumGroups_, getAssociations_, getMaxAssociations_, addAssociation_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_255getGroupLabel(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_groupidx = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getGroupLabel (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_groupidx,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getGroupLabel", 1, 3, 3, 1); __PYX_ERR(0, 3952, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_groupidx)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getGroupLabel", 1, 3, 3, 2); __PYX_ERR(0, 3952, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getGroupLabel") < 0)) __PYX_ERR(0, 3952, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_groupidx = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getGroupLabel", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3952, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.getGroupLabel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_254getGroupLabel(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_groupidx);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_254getGroupLabel(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_groupidx) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  uint8_t __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("getGroupLabel", 0);

  /* "libopenzwave.pyx":3971
 * 
 *         '''
 *         cdef string c_string = self.manager.GetGroupLabel(homeid, nodeid, groupidx)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3971, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3971, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_As_uint8_t(__pyx_v_groupidx); if (unlikely((__pyx_t_3 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3971, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetGroupLabel(__pyx_t_1, __pyx_t_2, __pyx_t_3);

  /* "libopenzwave.pyx":3972
 *         '''
 *         cdef string c_string = self.manager.GetGroupLabel(homeid, nodeid, groupidx)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def addAssociation(self, homeid, nodeid, groupidx, targetnodeid, instance=0x00):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_4 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3972, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3972, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_r = __pyx_t_5;
  __pyx_t_5 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":3952
 *         return self.manager.GetMaxAssociations(homeid, nodeid, groupidx)
 * 
 *     def getGroupLabel(self, homeid, nodeid, groupidx):             # <<<<<<<<<<<<<<
 *         '''
 * Returns a label for the particular group of a node.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("libopenzwave.PyManager.getGroupLabel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":3974
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def addAssociation(self, homeid, nodeid, groupidx, targetnodeid, instance=0x00):             # <<<<<<<<<<<<<<
 *         '''
 * .. _addAssociation:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_257addAssociation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_256addAssociation[] = "\n.. _addAssociation:\n\nAdds a node to an association group.\n\nDue to the possibility of a device being asleep, the command is assumed to\nsuceeed, and the association data held in this class is updated directly.  This\nwill be reverted by a future Association message from the device if the Z-Wave\nmessage actually failed to get through.  Notification callbacks will be sent in\nboth cases.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node whose associations are to be changed.\n:type nodeId: int\n:param groupIdx: One-based index of the group (because Z-Wave product manuals use one-based group numbering).\n:type groupIdx: int\n:param targetNodeId: Identifier for the node that will be added to the association group.\n:type targetNodeId: int\n:param instance: Identifier for the instance that will be added to the association group.\n:type instance: int\n:see: getNumGroups_, getAssociations_, getMaxAssociations_, removeAssociation_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_257addAssociation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_groupidx = 0;
  PyObject *__pyx_v_targetnodeid = 0;
  PyObject *__pyx_v_instance = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("addAssociation (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_groupidx,&__pyx_n_s_targetnodeid,&__pyx_n_s_instance,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[4] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("addAssociation", 0, 4, 5, 1); __PYX_ERR(0, 3974, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_groupidx)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("addAssociation", 0, 4, 5, 2); __PYX_ERR(0, 3974, __pyx_L3_error)
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_targetnodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("addAssociation", 0, 4, 5, 3); __PYX_ERR(0, 3974, __pyx_L3_error)
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_instance);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "addAssociation") < 0)) __PYX_ERR(0, 3974, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_groupidx = values[2];
    __pyx_v_targetnodeid = values[3];
    __pyx_v_instance = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("addAssociation", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3974, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.addAssociation", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_256addAssociation(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_groupidx, __pyx_v_targetnodeid, __pyx_v_instance);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_256addAssociation(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_groupidx, PyObject *__pyx_v_targetnodeid, PyObject *__pyx_v_instance) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  uint8_t __pyx_t_3;
  uint8_t __pyx_t_4;
  uint8_t __pyx_t_5;
  __Pyx_RefNannySetupContext("addAssociation", 0);

  /* "libopenzwave.pyx":3999
 * 
 *         '''
 *         self.manager.AddAssociation(homeid, nodeid, groupidx, targetnodeid, instance)             # <<<<<<<<<<<<<<
 * 
 *     def removeAssociation(self, homeid, nodeid, groupidx, targetnodeid, instance=0x00):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3999, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3999, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_As_uint8_t(__pyx_v_groupidx); if (unlikely((__pyx_t_3 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3999, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyInt_As_uint8_t(__pyx_v_targetnodeid); if (unlikely((__pyx_t_4 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3999, __pyx_L1_error)
  __pyx_t_5 = __Pyx_PyInt_As_uint8_t(__pyx_v_instance); if (unlikely((__pyx_t_5 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 3999, __pyx_L1_error)
  __pyx_v_self->manager->AddAssociation(__pyx_t_1, __pyx_t_2, __pyx_t_3, __pyx_t_4, __pyx_t_5);

  /* "libopenzwave.pyx":3974
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def addAssociation(self, homeid, nodeid, groupidx, targetnodeid, instance=0x00):             # <<<<<<<<<<<<<<
 *         '''
 * .. _addAssociation:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.addAssociation", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4001
 *         self.manager.AddAssociation(homeid, nodeid, groupidx, targetnodeid, instance)
 * 
 *     def removeAssociation(self, homeid, nodeid, groupidx, targetnodeid, instance=0x00):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeAssociation:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_259removeAssociation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_258removeAssociation[] = "\n.. _removeAssociation:\n\nRemoves a node from an association group.\n\nDue to the possibility of a device being asleep, the command is assumed to\nsucceed, and the association data held in this class is updated directly.  This\nwill be reverted by a future Association message from the device if the Z-Wave\nmessage actually failed to get through.   Notification callbacks will be sent\nin both cases.\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node whose associations are to be changed.\n:type nodeId: int\n:param groupIdx: One-based index of the group (because Z-Wave product manuals use one-based group numbering).\n:type groupIdx: int\n:param targetNodeId: Identifier for the node that will be removed from the association group.\n:type targetNodeId: int\n:param instance: Identifier for the instance that will be added to the association group.\n:type instance: int\n:see: getNumGroups_, getAssociations_, getMaxAssociations_, addAssociation_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_259removeAssociation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_groupidx = 0;
  PyObject *__pyx_v_targetnodeid = 0;
  PyObject *__pyx_v_instance = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("removeAssociation (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_groupidx,&__pyx_n_s_targetnodeid,&__pyx_n_s_instance,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[4] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("removeAssociation", 0, 4, 5, 1); __PYX_ERR(0, 4001, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_groupidx)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("removeAssociation", 0, 4, 5, 2); __PYX_ERR(0, 4001, __pyx_L3_error)
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_targetnodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("removeAssociation", 0, 4, 5, 3); __PYX_ERR(0, 4001, __pyx_L3_error)
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_instance);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "removeAssociation") < 0)) __PYX_ERR(0, 4001, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_groupidx = values[2];
    __pyx_v_targetnodeid = values[3];
    __pyx_v_instance = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("removeAssociation", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4001, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.removeAssociation", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_258removeAssociation(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_groupidx, __pyx_v_targetnodeid, __pyx_v_instance);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_258removeAssociation(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_groupidx, PyObject *__pyx_v_targetnodeid, PyObject *__pyx_v_instance) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  uint8_t __pyx_t_3;
  uint8_t __pyx_t_4;
  uint8_t __pyx_t_5;
  __Pyx_RefNannySetupContext("removeAssociation", 0);

  /* "libopenzwave.pyx":4026
 * 
 *         '''
 *         self.manager.RemoveAssociation(homeid, nodeid, groupidx, targetnodeid, instance)             # <<<<<<<<<<<<<<
 * #
 * # -----------------------------------------------------------------------------
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4026, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4026, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_As_uint8_t(__pyx_v_groupidx); if (unlikely((__pyx_t_3 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4026, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyInt_As_uint8_t(__pyx_v_targetnodeid); if (unlikely((__pyx_t_4 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4026, __pyx_L1_error)
  __pyx_t_5 = __Pyx_PyInt_As_uint8_t(__pyx_v_instance); if (unlikely((__pyx_t_5 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4026, __pyx_L1_error)
  __pyx_v_self->manager->RemoveAssociation(__pyx_t_1, __pyx_t_2, __pyx_t_3, __pyx_t_4, __pyx_t_5);

  /* "libopenzwave.pyx":4001
 *         self.manager.AddAssociation(homeid, nodeid, groupidx, targetnodeid, instance)
 * 
 *     def removeAssociation(self, homeid, nodeid, groupidx, targetnodeid, instance=0x00):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeAssociation:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.removeAssociation", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4033
 * # For notification of changes to the Z-Wave network or device values and associations.
 * #
 *     def addWatcher(self, pythonfunc):             # <<<<<<<<<<<<<<
 *         '''
 * .. _addWatcher:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_261addWatcher(PyObject *__pyx_v_self, PyObject *__pyx_v_pythonfunc); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_260addWatcher[] = "\n.. _addWatcher:\n\nAdd a notification watcher.\n\nIn OpenZWave, all feedback from the Z-Wave network is sent to the application\nvia callbacks.  This method allows the application to add a notification\ncallback handler, known as a \"watcher\" to OpenZWave.  An application needs only\nadd a single watcher - all notifications will be reported to it.\n\n:param pythonfunc: Watcher pointer to a function that will be called by the notification system.\n:type pythonfunc: callback\n:see: removeWatcher_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_261addWatcher(PyObject *__pyx_v_self, PyObject *__pyx_v_pythonfunc) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("addWatcher (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_260addWatcher(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_pythonfunc));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_260addWatcher(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_pythonfunc) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("addWatcher", 0);

  /* "libopenzwave.pyx":4049
 * 
 *         '''
 *         self._watcherCallback = pythonfunc # need to keep a reference to this             # <<<<<<<<<<<<<<
 *         if not self.manager.AddWatcher(notif_callback, <void*>pythonfunc):
 *             raise ValueError("call to AddWatcher failed")
 */
  __Pyx_INCREF(__pyx_v_pythonfunc);
  __Pyx_GIVEREF(__pyx_v_pythonfunc);
  __Pyx_GOTREF(__pyx_v_self->_watcherCallback);
  __Pyx_DECREF(__pyx_v_self->_watcherCallback);
  __pyx_v_self->_watcherCallback = __pyx_v_pythonfunc;

  /* "libopenzwave.pyx":4050
 *         '''
 *         self._watcherCallback = pythonfunc # need to keep a reference to this
 *         if not self.manager.AddWatcher(notif_callback, <void*>pythonfunc):             # <<<<<<<<<<<<<<
 *             raise ValueError("call to AddWatcher failed")
 * 
 */
  __pyx_t_1 = ((!(__pyx_v_self->manager->AddWatcher(__pyx_f_12libopenzwave_notif_callback, ((void *)__pyx_v_pythonfunc)) != 0)) != 0);
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":4051
 *         self._watcherCallback = pythonfunc # need to keep a reference to this
 *         if not self.manager.AddWatcher(notif_callback, <void*>pythonfunc):
 *             raise ValueError("call to AddWatcher failed")             # <<<<<<<<<<<<<<
 * 
 *     def removeWatcher(self, pythonfunc):
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__31, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4051, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 4051, __pyx_L1_error)

    /* "libopenzwave.pyx":4050
 *         '''
 *         self._watcherCallback = pythonfunc # need to keep a reference to this
 *         if not self.manager.AddWatcher(notif_callback, <void*>pythonfunc):             # <<<<<<<<<<<<<<
 *             raise ValueError("call to AddWatcher failed")
 * 
 */
  }

  /* "libopenzwave.pyx":4033
 * # For notification of changes to the Z-Wave network or device values and associations.
 * #
 *     def addWatcher(self, pythonfunc):             # <<<<<<<<<<<<<<
 *         '''
 * .. _addWatcher:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.addWatcher", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4053
 *             raise ValueError("call to AddWatcher failed")
 * 
 *     def removeWatcher(self, pythonfunc):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeWatcher:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_263removeWatcher(PyObject *__pyx_v_self, PyObject *__pyx_v_pythonfunc); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_262removeWatcher[] = "\n.. _removeWatcher:\n\nRemove a notification watcher.\n\n:param pythonfunc: Watcher pointer to a function\n:type pythonfunc: callback\n:see: addWatcher_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_263removeWatcher(PyObject *__pyx_v_self, PyObject *__pyx_v_pythonfunc) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("removeWatcher (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_262removeWatcher(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_pythonfunc));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_262removeWatcher(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_pythonfunc) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("removeWatcher", 0);

  /* "libopenzwave.pyx":4064
 * 
 *         '''
 *         if not self.manager.RemoveWatcher(notif_callback, <void*>self._watcherCallback):             # <<<<<<<<<<<<<<
 *             raise ValueError("call to RemoveWatcher failed")
 *         else:
 */
  __pyx_t_1 = ((!(__pyx_v_self->manager->RemoveWatcher(__pyx_f_12libopenzwave_notif_callback, ((void *)__pyx_v_self->_watcherCallback)) != 0)) != 0);
  if (__pyx_t_1) {

    /* "libopenzwave.pyx":4065
 *         '''
 *         if not self.manager.RemoveWatcher(notif_callback, <void*>self._watcherCallback):
 *             raise ValueError("call to RemoveWatcher failed")             # <<<<<<<<<<<<<<
 *         else:
 *             self._watcherCallback = None
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__32, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4065, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 4065, __pyx_L1_error)

    /* "libopenzwave.pyx":4064
 * 
 *         '''
 *         if not self.manager.RemoveWatcher(notif_callback, <void*>self._watcherCallback):             # <<<<<<<<<<<<<<
 *             raise ValueError("call to RemoveWatcher failed")
 *         else:
 */
  }

  /* "libopenzwave.pyx":4067
 *             raise ValueError("call to RemoveWatcher failed")
 *         else:
 *             self._watcherCallback = None             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(Py_None);
    __Pyx_GOTREF(__pyx_v_self->_watcherCallback);
    __Pyx_DECREF(__pyx_v_self->_watcherCallback);
    __pyx_v_self->_watcherCallback = Py_None;
  }

  /* "libopenzwave.pyx":4053
 *             raise ValueError("call to AddWatcher failed")
 * 
 *     def removeWatcher(self, pythonfunc):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeWatcher:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.removeWatcher", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4076
 * # Commands for Z-Wave network management using the PC Controller.
 * #
 *     def resetController(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _resetController:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_265resetController(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_264resetController[] = "\n.. _resetController:\n\nHard Reset a PC Z-Wave Controller.\n\nResets a controller and erases its network configuration settings.  The\ncontroller becomes a primary controller ready to add devices to a new network.\n\n:param homeId: The Home ID of the Z-Wave controller to be reset.\n:type homeId: int\n:see: softResetController_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_265resetController(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("resetController (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_264resetController(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_264resetController(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  __Pyx_RefNannySetupContext("resetController", 0);

  /* "libopenzwave.pyx":4090
 * 
 *         '''
 *         values_map.clear()             # <<<<<<<<<<<<<<
 *         self.manager.ResetController(homeid)
 * 
 */
  __pyx_v_12libopenzwave_values_map.clear();

  /* "libopenzwave.pyx":4091
 *         '''
 *         values_map.clear()
 *         self.manager.ResetController(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def softResetController(self, homeid):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4091, __pyx_L1_error)
  __pyx_v_self->manager->ResetController(__pyx_t_1);

  /* "libopenzwave.pyx":4076
 * # Commands for Z-Wave network management using the PC Controller.
 * #
 *     def resetController(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _resetController:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.resetController", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4093
 *         self.manager.ResetController(homeid)
 * 
 *     def softResetController(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _softResetController:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_267softResetController(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_266softResetController[] = "\n.. _softResetController:\n\nSoft Reset a PC Z-Wave Controller.\n\nResets a controller without erasing its network configuration settings.\n\n:param homeId: The Home ID of the Z-Wave controller to be reset.\n:type homeId: int\n:see: resetController_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_267softResetController(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("softResetController (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_266softResetController(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_266softResetController(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  __Pyx_RefNannySetupContext("softResetController", 0);

  /* "libopenzwave.pyx":4106
 * 
 *         '''
 *         self.manager.SoftReset(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def cancelControllerCommand(self, homeid):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4106, __pyx_L1_error)
  __pyx_v_self->manager->SoftReset(__pyx_t_1);

  /* "libopenzwave.pyx":4093
 *         self.manager.ResetController(homeid)
 * 
 *     def softResetController(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _softResetController:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.softResetController", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4108
 *         self.manager.SoftReset(homeid)
 * 
 *     def cancelControllerCommand(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _cancelControllerCommand:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_269cancelControllerCommand(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_268cancelControllerCommand[] = "\n.. _cancelControllerCommand:\n\nCancels any in-progress command running on a controller.\n\n:param homeId: The Home ID of the Z-Wave controller.\n:type homeId: int\n:return: True if a command was running and was cancelled.\n:rtype: bool\n:see: beginControllerCommand_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_269cancelControllerCommand(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cancelControllerCommand (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_268cancelControllerCommand(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_268cancelControllerCommand(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("cancelControllerCommand", 0);

  /* "libopenzwave.pyx":4121
 * 
 *         '''
 *         return self.manager.CancelControllerCommand(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def beginControllerCommand(self, homeId, command, pythonfunc,\
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4121, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->CancelControllerCommand(__pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4121, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4108
 *         self.manager.SoftReset(homeid)
 * 
 *     def cancelControllerCommand(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _cancelControllerCommand:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.cancelControllerCommand", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4123
 *         return self.manager.CancelControllerCommand(homeid)
 * 
 *     def beginControllerCommand(self, homeId, command, pythonfunc,\             # <<<<<<<<<<<<<<
 *             highPower=False, nodeId=0xff, arg=0):
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_271beginControllerCommand(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_270beginControllerCommand[] = "\n\n.. _beginControllerCommand:\n\nStart a controller command process.\n\nCommands :\n\n     - Driver::ControllerCommand_AddDevice - Add a new device or controller to the Z-Wave network.\n     - Driver::ControllerCommand_CreateNewPrimary - Create a new primary controller when old primary fails. Requires SUC.\n     - Driver::ControllerCommand_ReceiveConfiguration - Receive network configuration information from primary controller. Requires secondary.\n     - Driver::ControllerCommand_RemoveDevice - Remove a device or controller from the Z-Wave network.\n     - Driver::ControllerCommand_RemoveFailedNode - Remove a node from the network. The node must not be responding\n       and be on the controller's failed node list.\n     - Driver::ControllerCommand_HasNodeFailed - Check whether a node is in the controller's failed nodes list.\n     - Driver::ControllerCommand_ReplaceFailedNode - Replace a failed device with another. If the node is not in\n       the controller's failed nodes list, or the node responds, this command will fail.\n     - Driver:: ControllerCommand_TransferPrimaryRole - Add a new controller to the network and\n       make it the primary.  The existing primary will become a secondary controller.\n     - Driver::ControllerCommand_RequestNetworkUpdate - Update the controller with network information from the SUC/SIS.\n     - Driver::ControllerCommand_RequestNodeNeighborUpdate - Get a node to rebuild its neighbour list.  This method also does RequestNodeNeighbors afterwards.\n     - Driver::ControllerCommand_AssignReturnRoute - Assign a network return route to a device.\n     - Driver::ControllerCommand_DeleteAllReturnRoutes - Delete all network return routes from a device.\n     - Driver::ControllerCommand_SendNodeInformation - Send a node information frame.\n     - Driver::ControllerCommand_ReplicationSend - Send information from primary to secondary\n     - Driver::ControllerCommand_CreateButton - Create a handheld button id.\n     - Driver::Controller""Command_DeleteButton - Delete a handheld button id.\n\nCallbacks :\n\n    - Driver::ControllerState_Waiting, the controller is waiting for a user action.  A notice should be displayed       to the user at this point, telling them what to do next.       For the add, remove, replace and transfer primary role commands, the user needs to be told to press the       inclusion button on the device that  is going to be added or removed.  For ControllerCommand_ReceiveConfiguration,       they must set their other controller to send its data, and for ControllerCommand_CreateNewPrimary, set the other       controller to learn new data.\n    - Driver::ControllerState_InProgress - the controller is in the process of adding or removing the chosen node.  It is now too late to cancel the command.\n    - Driver::ControllerState_Complete - the controller has finished adding or removing the node, and the command is complete.\n    - Driver::ControllerState_Failed - will be sent if the command fails for any reason.\n\n:param homeId: The Home ID of the Z-Wave controller.\n:type homeId: int\n:param command: The command to be sent to the controller.\n:type command: ControllerCommand\n:param callback: Pointer to a function that will be called at various stages during the command process to notify the user of progress or to request actions on the user's part.  Defaults to NULL.\n:type callback: pfnControllerCallback_t\n:param context: Pointer to user defined data that will be passed into to the callback function.  Defaults to NULL.\n:type context:\n:param highPower: Used only with the AddDevice, AddController, RemoveDevice and RemoveController commands. Usually when adding or removing devices, the controller operates at low power so that the controller must be physically close to the device for security reasons.  If _highPower is true, the controller will operate at normal power levels instead.  Defaults to false.\n:type highPower: bool\n:param nodeId: Used only with the ReplaceFailedNode co""mmand, to specify the node that is going to be replaced.\n:type nodeId: int\n:param arg:\n:type arg: int\n:return: True if the command was accepted and has started.\n:rtype: bool\n:see: cancelControllerCommand_\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_271beginControllerCommand(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeId = 0;
  PyObject *__pyx_v_command = 0;
  PyObject *__pyx_v_pythonfunc = 0;
  PyObject *__pyx_v_highPower = 0;
  PyObject *__pyx_v_nodeId = 0;
  PyObject *__pyx_v_arg = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("beginControllerCommand (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeId,&__pyx_n_s_command,&__pyx_n_s_pythonfunc,&__pyx_n_s_highPower,&__pyx_n_s_nodeId,&__pyx_n_s_arg,0};
    PyObject* values[6] = {0,0,0,0,0,0};

    /* "libopenzwave.pyx":4124
 * 
 *     def beginControllerCommand(self, homeId, command, pythonfunc,\
 *             highPower=False, nodeId=0xff, arg=0):             # <<<<<<<<<<<<<<
 * 
 *         '''
 */
    values[3] = ((PyObject *)Py_False);
    values[4] = ((PyObject *)__pyx_int_255);
    values[5] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeId)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_command)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("beginControllerCommand", 0, 3, 6, 1); __PYX_ERR(0, 4123, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_pythonfunc)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("beginControllerCommand", 0, 3, 6, 2); __PYX_ERR(0, 4123, __pyx_L3_error)
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_highPower);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeId);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_arg);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "beginControllerCommand") < 0)) __PYX_ERR(0, 4123, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_homeId = values[0];
    __pyx_v_command = values[1];
    __pyx_v_pythonfunc = values[2];
    __pyx_v_highPower = values[3];
    __pyx_v_nodeId = values[4];
    __pyx_v_arg = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("beginControllerCommand", 0, 3, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4123, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.beginControllerCommand", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_270beginControllerCommand(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeId, __pyx_v_command, __pyx_v_pythonfunc, __pyx_v_highPower, __pyx_v_nodeId, __pyx_v_arg);

  /* "libopenzwave.pyx":4123
 *         return self.manager.CancelControllerCommand(homeid)
 * 
 *     def beginControllerCommand(self, homeId, command, pythonfunc,\             # <<<<<<<<<<<<<<
 *             highPower=False, nodeId=0xff, arg=0):
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_270beginControllerCommand(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeId, PyObject *__pyx_v_command, PyObject *__pyx_v_pythonfunc, PyObject *__pyx_v_highPower, PyObject *__pyx_v_nodeId, PyObject *__pyx_v_arg) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  enum OpenZWave::Driver::ControllerCommand __pyx_t_2;
  bool __pyx_t_3;
  uint8_t __pyx_t_4;
  uint8_t __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannySetupContext("beginControllerCommand", 0);

  /* "libopenzwave.pyx":4189
 *         '''
 * 
 *         self._controllerCallback = pythonfunc # need to keep a reference to this             # <<<<<<<<<<<<<<
 *         return self.manager.BeginControllerCommand(homeId, command, \
 *                  ctrl_callback, <void*>pythonfunc, highPower, nodeId, arg)
 */
  __Pyx_INCREF(__pyx_v_pythonfunc);
  __Pyx_GIVEREF(__pyx_v_pythonfunc);
  __Pyx_GOTREF(__pyx_v_self->_controllerCallback);
  __Pyx_DECREF(__pyx_v_self->_controllerCallback);
  __pyx_v_self->_controllerCallback = __pyx_v_pythonfunc;

  /* "libopenzwave.pyx":4190
 * 
 *         self._controllerCallback = pythonfunc # need to keep a reference to this
 *         return self.manager.BeginControllerCommand(homeId, command, \             # <<<<<<<<<<<<<<
 *                  ctrl_callback, <void*>pythonfunc, highPower, nodeId, arg)
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeId); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4190, __pyx_L1_error)
  __pyx_t_2 = ((enum OpenZWave::Driver::ControllerCommand)__Pyx_PyInt_As_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerCommand(__pyx_v_command)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 4190, __pyx_L1_error)

  /* "libopenzwave.pyx":4191
 *         self._controllerCallback = pythonfunc # need to keep a reference to this
 *         return self.manager.BeginControllerCommand(homeId, command, \
 *                  ctrl_callback, <void*>pythonfunc, highPower, nodeId, arg)             # <<<<<<<<<<<<<<
 * 
 *     def createNewPrimary(self, homeid):
 */
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_highPower); if (unlikely((__pyx_t_3 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4191, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeId); if (unlikely((__pyx_t_4 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4191, __pyx_L1_error)
  __pyx_t_5 = __Pyx_PyInt_As_uint8_t(__pyx_v_arg); if (unlikely((__pyx_t_5 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4191, __pyx_L1_error)

  /* "libopenzwave.pyx":4190
 * 
 *         self._controllerCallback = pythonfunc # need to keep a reference to this
 *         return self.manager.BeginControllerCommand(homeId, command, \             # <<<<<<<<<<<<<<
 *                  ctrl_callback, <void*>pythonfunc, highPower, nodeId, arg)
 * 
 */
  __pyx_t_6 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->BeginControllerCommand(__pyx_t_1, __pyx_t_2, __pyx_f_12libopenzwave_ctrl_callback, ((void *)__pyx_v_pythonfunc), __pyx_t_3, __pyx_t_4, __pyx_t_5)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_r = __pyx_t_6;
  __pyx_t_6 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4123
 *         return self.manager.CancelControllerCommand(homeid)
 * 
 *     def beginControllerCommand(self, homeId, command, pythonfunc,\             # <<<<<<<<<<<<<<
 *             highPower=False, nodeId=0xff, arg=0):
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("libopenzwave.PyManager.beginControllerCommand", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4193
 *                  ctrl_callback, <void*>pythonfunc, highPower, nodeId, arg)
 * 
 *     def createNewPrimary(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _createNewPrimary:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_273createNewPrimary(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_272createNewPrimary[] = "\n.. _createNewPrimary:\n\nCreate a new primary controller when old primary fails. Requires SUC.\n\nThis command Creates a new Primary Controller when the Old Primary has Failed. Requires a SUC on the network to function.\n\nResults of the CreateNewPrimary Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_273createNewPrimary(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("createNewPrimary (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_272createNewPrimary(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_272createNewPrimary(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("createNewPrimary", 0);

  /* "libopenzwave.pyx":4210
 * 
 *         '''
 *         return self.manager.CreateNewPrimary(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def transferPrimaryRole(self, homeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4210, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->CreateNewPrimary(__pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4210, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4193
 *                  ctrl_callback, <void*>pythonfunc, highPower, nodeId, arg)
 * 
 *     def createNewPrimary(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _createNewPrimary:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.createNewPrimary", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4212
 *         return self.manager.CreateNewPrimary(homeid)
 * 
 *     def transferPrimaryRole(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _transferPrimaryRole:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_275transferPrimaryRole(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_274transferPrimaryRole[] = "\n.. _transferPrimaryRole:\n\nAdd a new controller to the network and make it the primary.\n\nThe existing primary will become a secondary controller.\n\nResults of the TransferPrimaryRole Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_275transferPrimaryRole(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("transferPrimaryRole (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_274transferPrimaryRole(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_274transferPrimaryRole(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("transferPrimaryRole", 0);

  /* "libopenzwave.pyx":4229
 * 
 *         '''
 *         return self.manager.TransferPrimaryRole(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def receiveConfiguration(self, homeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4229, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->TransferPrimaryRole(__pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4229, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4212
 *         return self.manager.CreateNewPrimary(homeid)
 * 
 *     def transferPrimaryRole(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _transferPrimaryRole:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.transferPrimaryRole", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4231
 *         return self.manager.TransferPrimaryRole(homeid)
 * 
 *     def receiveConfiguration(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _receiveConfiguration:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_277receiveConfiguration(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_276receiveConfiguration[] = "\n.. _receiveConfiguration:\n\nReceive network configuration information from primary controller. Requires secondary.\n\nThis command prepares the controller to recieve Network Configuration from a Secondary Controller.\n\nResults of the ReceiveConfiguration Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_277receiveConfiguration(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("receiveConfiguration (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_276receiveConfiguration(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_276receiveConfiguration(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("receiveConfiguration", 0);

  /* "libopenzwave.pyx":4248
 * 
 *         '''
 *         return self.manager.ReceiveConfiguration(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def addNode(self, homeid, doSecurity):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4248, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->ReceiveConfiguration(__pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4248, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4231
 *         return self.manager.TransferPrimaryRole(homeid)
 * 
 *     def receiveConfiguration(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _receiveConfiguration:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.receiveConfiguration", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4250
 *         return self.manager.ReceiveConfiguration(homeid)
 * 
 *     def addNode(self, homeid, doSecurity):             # <<<<<<<<<<<<<<
 *         '''
 * .. _addNode:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_279addNode(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_278addNode[] = "\n.. _addNode:\n\nStart the Inclusion Process to add a Node to the Network.\n\nThe Status of the Node Inclusion is communicated via Notifications. Specifically, you should\nmonitor ControllerCommand Notifications.\n\nResults of the AddNode Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param doSecurity: Whether to initialize the Network Key on the device if it supports the Security CC\n:type doSecurity: bool\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_279addNode(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_doSecurity = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("addNode (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_doSecurity,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_doSecurity)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("addNode", 1, 2, 2, 1); __PYX_ERR(0, 4250, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "addNode") < 0)) __PYX_ERR(0, 4250, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_doSecurity = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("addNode", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4250, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.addNode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_278addNode(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_doSecurity);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_278addNode(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_doSecurity) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  bool __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("addNode", 0);

  /* "libopenzwave.pyx":4270
 * 
 *         '''
 *         return self.manager.AddNode(homeid, doSecurity)             # <<<<<<<<<<<<<<
 * 
 *     def removeNode(self, homeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4270, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_doSecurity); if (unlikely((__pyx_t_2 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4270, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->AddNode(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4270, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4250
 *         return self.manager.ReceiveConfiguration(homeid)
 * 
 *     def addNode(self, homeid, doSecurity):             # <<<<<<<<<<<<<<
 *         '''
 * .. _addNode:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.addNode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4272
 *         return self.manager.AddNode(homeid, doSecurity)
 * 
 *     def removeNode(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeNode:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_281removeNode(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_280removeNode[] = "\n.. _removeNode:\n\nRemove a Device from the Z-Wave Network\n\nThe Status of the Node Removal is communicated via Notifications. Specifically, you should\nmonitor ControllerCommand Notifications.\n\nResults of the RemoveNode Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param doSecurity: Whether to initialize the Network Key on the device if it supports the Security CC\n:type doSecurity: bool\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_281removeNode(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("removeNode (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_280removeNode(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_280removeNode(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("removeNode", 0);

  /* "libopenzwave.pyx":4292
 * 
 *         '''
 *         return self.manager.RemoveNode(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def removeFailedNode(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4292, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->RemoveNode(__pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4292, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4272
 *         return self.manager.AddNode(homeid, doSecurity)
 * 
 *     def removeNode(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeNode:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.removeNode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4294
 *         return self.manager.RemoveNode(homeid)
 * 
 *     def removeFailedNode(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeFailedNode:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_283removeFailedNode(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_282removeFailedNode[] = "\n.. _removeFailedNode:\n\nCheck if the Controller Believes a Node has Failed.\n\nThis is different from the IsNodeFailed call in that we test the Controllers Failed Node List, whereas the IsNodeFailed is testing\nour list of Failed Nodes, which might be different.\n\nThe Results will be communicated via Notifications. Specifically, you should monitor the ControllerCommand notifications\n\nResults of the RemoveFailedNode Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_283removeFailedNode(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("removeFailedNode (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("removeFailedNode", 1, 2, 2, 1); __PYX_ERR(0, 4294, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "removeFailedNode") < 0)) __PYX_ERR(0, 4294, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("removeFailedNode", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4294, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.removeFailedNode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_282removeFailedNode(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_282removeFailedNode(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("removeFailedNode", 0);

  /* "libopenzwave.pyx":4316
 * 
 *         '''
 *         return self.manager.RemoveFailedNode(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def hasNodeFailed(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4316, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4316, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->RemoveFailedNode(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4316, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4294
 *         return self.manager.RemoveNode(homeid)
 * 
 *     def removeFailedNode(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeFailedNode:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.removeFailedNode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4318
 *         return self.manager.RemoveFailedNode(homeid, nodeid)
 * 
 *     def hasNodeFailed(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _hasNodeFailed:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_285hasNodeFailed(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_284hasNodeFailed[] = "\n.. _hasNodeFailed:\n\nAsk a Node to update its Neighbor Tables\n\nThis command will ask a Node to update its Neighbor Tables.\n\nResults of the HasNodeFailed Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_285hasNodeFailed(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hasNodeFailed (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("hasNodeFailed", 1, 2, 2, 1); __PYX_ERR(0, 4318, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "hasNodeFailed") < 0)) __PYX_ERR(0, 4318, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("hasNodeFailed", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4318, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.hasNodeFailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_284hasNodeFailed(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_284hasNodeFailed(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("hasNodeFailed", 0);

  /* "libopenzwave.pyx":4337
 * 
 *         '''
 *         return self.manager.HasNodeFailed(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def requestNodeNeighborUpdate(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4337, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4337, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->HasNodeFailed(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4337, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4318
 *         return self.manager.RemoveFailedNode(homeid, nodeid)
 * 
 *     def hasNodeFailed(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _hasNodeFailed:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.hasNodeFailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4339
 *         return self.manager.HasNodeFailed(homeid, nodeid)
 * 
 *     def requestNodeNeighborUpdate(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _requestNodeNeighborUpdate:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_287requestNodeNeighborUpdate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_286requestNodeNeighborUpdate[] = "\n.. _requestNodeNeighborUpdate:\n\nAsk a Node to update its Neighbor Tables\n\nThis command will ask a Node to update its Neighbor Tables.\n\nResults of the RequestNodeNeighborUpdate Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_287requestNodeNeighborUpdate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("requestNodeNeighborUpdate (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("requestNodeNeighborUpdate", 1, 2, 2, 1); __PYX_ERR(0, 4339, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "requestNodeNeighborUpdate") < 0)) __PYX_ERR(0, 4339, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("requestNodeNeighborUpdate", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4339, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.requestNodeNeighborUpdate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_286requestNodeNeighborUpdate(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_286requestNodeNeighborUpdate(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("requestNodeNeighborUpdate", 0);

  /* "libopenzwave.pyx":4358
 * 
 *         '''
 *         return self.manager.RequestNodeNeighborUpdate(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def assignReturnRoute(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4358, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4358, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->RequestNodeNeighborUpdate(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4358, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4339
 *         return self.manager.HasNodeFailed(homeid, nodeid)
 * 
 *     def requestNodeNeighborUpdate(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _requestNodeNeighborUpdate:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.requestNodeNeighborUpdate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4360
 *         return self.manager.RequestNodeNeighborUpdate(homeid, nodeid)
 * 
 *     def assignReturnRoute(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _assignReturnRoute:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_289assignReturnRoute(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_288assignReturnRoute[] = "\n.. _assignReturnRoute:\n\nAsk a Node to update its update its Return Route to the Controller\n\nThis command will ask a Node to update its Return Route to the Controller\n\nResults of the AssignReturnRoute Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_289assignReturnRoute(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("assignReturnRoute (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("assignReturnRoute", 1, 2, 2, 1); __PYX_ERR(0, 4360, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "assignReturnRoute") < 0)) __PYX_ERR(0, 4360, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("assignReturnRoute", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4360, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.assignReturnRoute", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_288assignReturnRoute(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_288assignReturnRoute(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("assignReturnRoute", 0);

  /* "libopenzwave.pyx":4379
 * 
 *         '''
 *         return self.manager.AssignReturnRoute(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def deleteAllReturnRoutes(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4379, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4379, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->AssignReturnRoute(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4379, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4360
 *         return self.manager.RequestNodeNeighborUpdate(homeid, nodeid)
 * 
 *     def assignReturnRoute(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _assignReturnRoute:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.assignReturnRoute", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4381
 *         return self.manager.AssignReturnRoute(homeid, nodeid)
 * 
 *     def deleteAllReturnRoutes(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _deleteAllReturnRoutes:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_291deleteAllReturnRoutes(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_290deleteAllReturnRoutes[] = "\n.. _deleteAllReturnRoutes:\n\nAsk a Node to delete all Return Route.\n\nThis command will ask a Node to delete all its return routes, and will rediscover when needed.\n\nResults of the DeleteAllReturnRoutes Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_291deleteAllReturnRoutes(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("deleteAllReturnRoutes (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("deleteAllReturnRoutes", 1, 2, 2, 1); __PYX_ERR(0, 4381, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "deleteAllReturnRoutes") < 0)) __PYX_ERR(0, 4381, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("deleteAllReturnRoutes", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4381, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.deleteAllReturnRoutes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_290deleteAllReturnRoutes(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_290deleteAllReturnRoutes(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("deleteAllReturnRoutes", 0);

  /* "libopenzwave.pyx":4400
 * 
 *         '''
 *         return self.manager.DeleteAllReturnRoutes(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def sendNodeInformation(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4400, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4400, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->DeleteAllReturnRoutes(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4400, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4381
 *         return self.manager.AssignReturnRoute(homeid, nodeid)
 * 
 *     def deleteAllReturnRoutes(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _deleteAllReturnRoutes:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.deleteAllReturnRoutes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4402
 *         return self.manager.DeleteAllReturnRoutes(homeid, nodeid)
 * 
 *     def sendNodeInformation(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _sendNodeInformation:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_293sendNodeInformation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_292sendNodeInformation[] = "\n.. _sendNodeInformation:\n\nCreate a new primary controller when old primary fails. Requires SUC.\n\nThis command Creates a new Primary Controller when the Old Primary has Failed. Requires a SUC on the network to function\n\nResults of the SendNodeInformation Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_293sendNodeInformation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sendNodeInformation (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("sendNodeInformation", 1, 2, 2, 1); __PYX_ERR(0, 4402, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "sendNodeInformation") < 0)) __PYX_ERR(0, 4402, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("sendNodeInformation", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4402, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.sendNodeInformation", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_292sendNodeInformation(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_292sendNodeInformation(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("sendNodeInformation", 0);

  /* "libopenzwave.pyx":4421
 * 
 *         '''
 *         return self.manager.SendNodeInformation(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def replaceFailedNode(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4421, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4421, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->SendNodeInformation(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4421, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4402
 *         return self.manager.DeleteAllReturnRoutes(homeid, nodeid)
 * 
 *     def sendNodeInformation(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _sendNodeInformation:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.sendNodeInformation", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4423
 *         return self.manager.SendNodeInformation(homeid, nodeid)
 * 
 *     def replaceFailedNode(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _replaceFailedNode:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_295replaceFailedNode(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_294replaceFailedNode[] = "\n.. _replaceFailedNode:\n\nReplace a failed device with another.\n\nIf the node is not in the controller's failed nodes list, or the node responds, this command will fail.\n\nYou can check if a Node is in the Controllers Failed node list by using the HasNodeFailed method.\n\nResults of the ReplaceFailedNode Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_295replaceFailedNode(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("replaceFailedNode (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("replaceFailedNode", 1, 2, 2, 1); __PYX_ERR(0, 4423, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "replaceFailedNode") < 0)) __PYX_ERR(0, 4423, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("replaceFailedNode", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4423, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.replaceFailedNode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_294replaceFailedNode(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_294replaceFailedNode(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("replaceFailedNode", 0);

  /* "libopenzwave.pyx":4444
 * 
 *         '''
 *         return self.manager.ReplaceFailedNode(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def requestNetworkUpdate(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4444, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4444, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->ReplaceFailedNode(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4444, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4423
 *         return self.manager.SendNodeInformation(homeid, nodeid)
 * 
 *     def replaceFailedNode(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _replaceFailedNode:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.replaceFailedNode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4446
 *         return self.manager.ReplaceFailedNode(homeid, nodeid)
 * 
 *     def requestNetworkUpdate(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _requestNetworkUpdate:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_297requestNetworkUpdate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_296requestNetworkUpdate[] = "\n.. _requestNetworkUpdate:\n\nUpdate the controller with network information from the SUC/SIS.\n\nResults of the RequestNetworkUpdate Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_297requestNetworkUpdate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("requestNetworkUpdate (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("requestNetworkUpdate", 1, 2, 2, 1); __PYX_ERR(0, 4446, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "requestNetworkUpdate") < 0)) __PYX_ERR(0, 4446, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("requestNetworkUpdate", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4446, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.requestNetworkUpdate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_296requestNetworkUpdate(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_296requestNetworkUpdate(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("requestNetworkUpdate", 0);

  /* "libopenzwave.pyx":4463
 * 
 *         '''
 *         return self.manager.RequestNetworkUpdate(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def replicationSend(self, homeid, nodeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4463, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4463, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->RequestNetworkUpdate(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4463, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4446
 *         return self.manager.ReplaceFailedNode(homeid, nodeid)
 * 
 *     def requestNetworkUpdate(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _requestNetworkUpdate:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.requestNetworkUpdate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4465
 *         return self.manager.RequestNetworkUpdate(homeid, nodeid)
 * 
 *     def replicationSend(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _replicationSend:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_299replicationSend(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_298replicationSend[] = "\n.. _replicationSend:\n\nCreate a handheld button id.\n\nOnly intended for Bridge Firmware Controllers.\n\nResults of the ReplicationSend Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:param buttonid: the ID of the Button to query.\n:type buttonid: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_299replicationSend(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("replicationSend (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("replicationSend", 1, 2, 2, 1); __PYX_ERR(0, 4465, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "replicationSend") < 0)) __PYX_ERR(0, 4465, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("replicationSend", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4465, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.replicationSend", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_298replicationSend(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_298replicationSend(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("replicationSend", 0);

  /* "libopenzwave.pyx":4486
 * 
 *         '''
 *         return self.manager.ReplicationSend(homeid, nodeid)             # <<<<<<<<<<<<<<
 * 
 *     def createButton(self, homeid, nodeid, buttonid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4486, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4486, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->ReplicationSend(__pyx_t_1, __pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4486, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4465
 *         return self.manager.RequestNetworkUpdate(homeid, nodeid)
 * 
 *     def replicationSend(self, homeid, nodeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _replicationSend:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.replicationSend", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4488
 *         return self.manager.ReplicationSend(homeid, nodeid)
 * 
 *     def createButton(self, homeid, nodeid, buttonid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _createButton:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_301createButton(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_300createButton[] = "\n.. _createButton:\n\nCreate a handheld button id.\n\nOnly intended for Bridge Firmware Controllers.\n\nResults of the CreateButton Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:param buttonid: the ID of the Button to query.\n:type buttonid: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_301createButton(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_buttonid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("createButton (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_buttonid,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("createButton", 1, 3, 3, 1); __PYX_ERR(0, 4488, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_buttonid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("createButton", 1, 3, 3, 2); __PYX_ERR(0, 4488, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "createButton") < 0)) __PYX_ERR(0, 4488, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_buttonid = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("createButton", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4488, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.createButton", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_300createButton(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_buttonid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_300createButton(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_buttonid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  uint8_t __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("createButton", 0);

  /* "libopenzwave.pyx":4509
 * 
 *         '''
 *         return self.manager.CreateButton(homeid, nodeid, buttonid)             # <<<<<<<<<<<<<<
 * 
 *     def deleteButton(self, homeid, nodeid, buttonid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4509, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4509, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_As_uint8_t(__pyx_v_buttonid); if (unlikely((__pyx_t_3 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4509, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->CreateButton(__pyx_t_1, __pyx_t_2, __pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4509, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4488
 *         return self.manager.ReplicationSend(homeid, nodeid)
 * 
 *     def createButton(self, homeid, nodeid, buttonid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _createButton:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.createButton", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4511
 *         return self.manager.CreateButton(homeid, nodeid, buttonid)
 * 
 *     def deleteButton(self, homeid, nodeid, buttonid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _deleteButton:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_303deleteButton(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_302deleteButton[] = "\n.. _deleteButton:\n\nDelete a handheld button id.\n\nOnly intended for Bridge Firmware Controllers.\n\nResults of the CreateButton Command will be send as a Notification with the Notification type as\nNotification::Type_ControllerCommand\n\n:param homeId: The Home ID of the Z-Wave controller that manages the node.\n:type homeId: int\n:param nodeId: The ID of the node to query.\n:type nodeId: int\n:return: True if the request was sent successfully.\n:rtype: bool\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_303deleteButton(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_homeid = 0;
  PyObject *__pyx_v_nodeid = 0;
  PyObject *__pyx_v_buttonid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("deleteButton (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_homeid,&__pyx_n_s_nodeid,&__pyx_n_s_buttonid,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_homeid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nodeid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("deleteButton", 1, 3, 3, 1); __PYX_ERR(0, 4511, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_buttonid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("deleteButton", 1, 3, 3, 2); __PYX_ERR(0, 4511, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "deleteButton") < 0)) __PYX_ERR(0, 4511, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_homeid = values[0];
    __pyx_v_nodeid = values[1];
    __pyx_v_buttonid = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("deleteButton", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4511, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.deleteButton", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_302deleteButton(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_homeid, __pyx_v_nodeid, __pyx_v_buttonid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_302deleteButton(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid, PyObject *__pyx_v_nodeid, PyObject *__pyx_v_buttonid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  uint8_t __pyx_t_2;
  uint8_t __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("deleteButton", 0);

  /* "libopenzwave.pyx":4530
 * 
 *         '''
 *         return self.manager.DeleteButton(homeid, nodeid, buttonid)             # <<<<<<<<<<<<<<
 * 
 * #-----------------------------------------------------------------------------
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4530, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_As_uint8_t(__pyx_v_nodeid); if (unlikely((__pyx_t_2 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4530, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_As_uint8_t(__pyx_v_buttonid); if (unlikely((__pyx_t_3 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4530, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->DeleteButton(__pyx_t_1, __pyx_t_2, __pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4530, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4511
 *         return self.manager.CreateButton(homeid, nodeid, buttonid)
 * 
 *     def deleteButton(self, homeid, nodeid, buttonid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _deleteButton:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.deleteButton", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4536
 * #-----------------------------------------------------------------------------
 * 
 *     def getNumScenes(self):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNumScenes:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_305getNumScenes(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_304getNumScenes[] = "\n.. _getNumScenes:\n\nGets the number of scenes that have been defined\n\n:return: The number of scenes.\n:rtype: int\n:see: getAllScenes_, sceneExists_, createScene_, removeScene_, activateScene_, getSceneLabel_, setSceneLabel_, removeSceneValue_, addSceneValue_, setSceneValue_, sceneGetValues_, removeAllScenes_\n\n       ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_305getNumScenes(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getNumScenes (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_304getNumScenes(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_304getNumScenes(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("getNumScenes", 0);

  /* "libopenzwave.pyx":4551
 * 
 *        '''
 *         return self.manager.GetNumScenes()             # <<<<<<<<<<<<<<
 * 
 *     def getAllScenes(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_uint8_t(__pyx_v_self->manager->GetNumScenes()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4551, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4536
 * #-----------------------------------------------------------------------------
 * 
 *     def getNumScenes(self):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getNumScenes:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.getNumScenes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4553
 *         return self.manager.GetNumScenes()
 * 
 *     def getAllScenes(self):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getAllScenes:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_307getAllScenes(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_306getAllScenes[] = "\n.. _getAllScenes:\n\nGets a set of all the SceneIds\n\n:return: A set() containing neighboring scene IDs\n:rtype: set()\n:see: getNumScenes_, sceneExists_, createScene_, removeScene_, activateScene_, getSceneLabel_, setSceneLabel_, removeSceneValue_, addSceneValue_, setSceneValue_, sceneGetValues_, removeAllScenes_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_307getAllScenes(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getAllScenes (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_306getAllScenes(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_306getAllScenes(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self) {
  PyObject *__pyx_v_data = NULL;
  uint32_t __pyx_v_size;
  uint8_t **__pyx_v_dbuf;
  uint32_t __pyx_v_count;
  struct __pyx_obj_12libopenzwave_RetAlloc *__pyx_v_retuint8 = 0;
  uint8_t *__pyx_v_p;
  uint32_t __pyx_v_start;
  uint32_t __pyx_v_i;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  uint32_t __pyx_t_4;
  uint32_t __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  char const *__pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  __Pyx_RefNannySetupContext("getAllScenes", 0);

  /* "libopenzwave.pyx":4568
 * 
 *         '''
 *         data = set()             # <<<<<<<<<<<<<<
 *         cdef uint32_t size = self.manager.GetNumScenes()
 *         # Allocate memory
 */
  __pyx_t_1 = PySet_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4568, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_data = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "libopenzwave.pyx":4569
 *         '''
 *         data = set()
 *         cdef uint32_t size = self.manager.GetNumScenes()             # <<<<<<<<<<<<<<
 *         # Allocate memory
 *         cdef uint8_t** dbuf = <uint8_t**>malloc(sizeof(uint8_t)*size)
 */
  __pyx_v_size = __pyx_v_self->manager->GetNumScenes();

  /* "libopenzwave.pyx":4571
 *         cdef uint32_t size = self.manager.GetNumScenes()
 *         # Allocate memory
 *         cdef uint8_t** dbuf = <uint8_t**>malloc(sizeof(uint8_t)*size)             # <<<<<<<<<<<<<<
 *         # return value is pointer to uint8_t[]
 *         cdef uint32_t count = self.manager.GetAllScenes(dbuf)
 */
  __pyx_v_dbuf = ((uint8_t **)malloc(((sizeof(uint8_t)) * __pyx_v_size)));

  /* "libopenzwave.pyx":4573
 *         cdef uint8_t** dbuf = <uint8_t**>malloc(sizeof(uint8_t)*size)
 *         # return value is pointer to uint8_t[]
 *         cdef uint32_t count = self.manager.GetAllScenes(dbuf)             # <<<<<<<<<<<<<<
 *         if count == 0:
 *             #Don't need to allocate memory.
 */
  __pyx_v_count = __pyx_v_self->manager->GetAllScenes(__pyx_v_dbuf);

  /* "libopenzwave.pyx":4574
 *         # return value is pointer to uint8_t[]
 *         cdef uint32_t count = self.manager.GetAllScenes(dbuf)
 *         if count == 0:             # <<<<<<<<<<<<<<
 *             #Don't need to allocate memory.
 *             free(dbuf)
 */
  __pyx_t_2 = ((__pyx_v_count == 0) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":4576
 *         if count == 0:
 *             #Don't need to allocate memory.
 *             free(dbuf)             # <<<<<<<<<<<<<<
 *             return data
 *         cdef RetAlloc retuint8 = RetAlloc(count)
 */
    free(__pyx_v_dbuf);

    /* "libopenzwave.pyx":4577
 *             #Don't need to allocate memory.
 *             free(dbuf)
 *             return data             # <<<<<<<<<<<<<<
 *         cdef RetAlloc retuint8 = RetAlloc(count)
 *         cdef uint8_t* p
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_data);
    __pyx_r = __pyx_v_data;
    goto __pyx_L0;

    /* "libopenzwave.pyx":4574
 *         # return value is pointer to uint8_t[]
 *         cdef uint32_t count = self.manager.GetAllScenes(dbuf)
 *         if count == 0:             # <<<<<<<<<<<<<<
 *             #Don't need to allocate memory.
 *             free(dbuf)
 */
  }

  /* "libopenzwave.pyx":4578
 *             free(dbuf)
 *             return data
 *         cdef RetAlloc retuint8 = RetAlloc(count)             # <<<<<<<<<<<<<<
 *         cdef uint8_t* p
 *         cdef uint32_t start = 0
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(__pyx_v_count); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4578, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4578, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_12libopenzwave_RetAlloc), __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4578, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_retuint8 = ((struct __pyx_obj_12libopenzwave_RetAlloc *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "libopenzwave.pyx":4580
 *         cdef RetAlloc retuint8 = RetAlloc(count)
 *         cdef uint8_t* p
 *         cdef uint32_t start = 0             # <<<<<<<<<<<<<<
 *         if count:
 *             try:
 */
  __pyx_v_start = 0;

  /* "libopenzwave.pyx":4581
 *         cdef uint8_t* p
 *         cdef uint32_t start = 0
 *         if count:             # <<<<<<<<<<<<<<
 *             try:
 *                 p = dbuf[0] # p is now pointing at first element of array
 */
  __pyx_t_2 = (__pyx_v_count != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":4582
 *         cdef uint32_t start = 0
 *         if count:
 *             try:             # <<<<<<<<<<<<<<
 *                 p = dbuf[0] # p is now pointing at first element of array
 *                 for i in range(start, count):
 */
    /*try:*/ {

      /* "libopenzwave.pyx":4583
 *         if count:
 *             try:
 *                 p = dbuf[0] # p is now pointing at first element of array             # <<<<<<<<<<<<<<
 *                 for i in range(start, count):
 *                     retuint8.data[i] = p[0]
 */
      __pyx_v_p = (__pyx_v_dbuf[0]);

      /* "libopenzwave.pyx":4584
 *             try:
 *                 p = dbuf[0] # p is now pointing at first element of array
 *                 for i in range(start, count):             # <<<<<<<<<<<<<<
 *                     retuint8.data[i] = p[0]
 *                     data.add(retuint8.data[i])
 */
      __pyx_t_4 = __pyx_v_count;
      for (__pyx_t_5 = __pyx_v_start; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
        __pyx_v_i = __pyx_t_5;

        /* "libopenzwave.pyx":4585
 *                 p = dbuf[0] # p is now pointing at first element of array
 *                 for i in range(start, count):
 *                     retuint8.data[i] = p[0]             # <<<<<<<<<<<<<<
 *                     data.add(retuint8.data[i])
 *                     p += 1
 */
        (__pyx_v_retuint8->data[__pyx_v_i]) = (__pyx_v_p[0]);

        /* "libopenzwave.pyx":4586
 *                 for i in range(start, count):
 *                     retuint8.data[i] = p[0]
 *                     data.add(retuint8.data[i])             # <<<<<<<<<<<<<<
 *                     p += 1
 *             finally:
 */
        __pyx_t_1 = __Pyx_PyInt_From_uint8_t((__pyx_v_retuint8->data[__pyx_v_i])); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4586, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_6 = PySet_Add(__pyx_v_data, __pyx_t_1); if (unlikely(__pyx_t_6 == -1)) __PYX_ERR(0, 4586, __pyx_L6_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "libopenzwave.pyx":4587
 *                     retuint8.data[i] = p[0]
 *                     data.add(retuint8.data[i])
 *                     p += 1             # <<<<<<<<<<<<<<
 *             finally:
 *                 # Free memory
 */
        __pyx_v_p = (__pyx_v_p + 1);
      }
    }

    /* "libopenzwave.pyx":4590
 *             finally:
 *                 # Free memory
 *                 free(dbuf)             # <<<<<<<<<<<<<<
 *                 pass
 *         return data
 */
    /*finally:*/ {
      /*normal exit:*/{
        free(__pyx_v_dbuf);
        goto __pyx_L7;
      }
      /*exception exit:*/{
        __Pyx_PyThreadState_declare
        __pyx_L6_error:;
        __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
        __Pyx_PyThreadState_assign
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_13, &__pyx_t_14, &__pyx_t_15);
        if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12) < 0)) __Pyx_ErrFetch(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12);
        __Pyx_XGOTREF(__pyx_t_10);
        __Pyx_XGOTREF(__pyx_t_11);
        __Pyx_XGOTREF(__pyx_t_12);
        __Pyx_XGOTREF(__pyx_t_13);
        __Pyx_XGOTREF(__pyx_t_14);
        __Pyx_XGOTREF(__pyx_t_15);
        __pyx_t_7 = __pyx_lineno; __pyx_t_8 = __pyx_clineno; __pyx_t_9 = __pyx_filename;
        {
          free(__pyx_v_dbuf);
        }
        __Pyx_PyThreadState_assign
        if (PY_MAJOR_VERSION >= 3) {
          __Pyx_XGIVEREF(__pyx_t_13);
          __Pyx_XGIVEREF(__pyx_t_14);
          __Pyx_XGIVEREF(__pyx_t_15);
          __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
        }
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_XGIVEREF(__pyx_t_11);
        __Pyx_XGIVEREF(__pyx_t_12);
        __Pyx_ErrRestore(__pyx_t_10, __pyx_t_11, __pyx_t_12);
        __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
        __pyx_lineno = __pyx_t_7; __pyx_clineno = __pyx_t_8; __pyx_filename = __pyx_t_9;
        goto __pyx_L1_error;
      }
      __pyx_L7:;
    }

    /* "libopenzwave.pyx":4581
 *         cdef uint8_t* p
 *         cdef uint32_t start = 0
 *         if count:             # <<<<<<<<<<<<<<
 *             try:
 *                 p = dbuf[0] # p is now pointing at first element of array
 */
  }

  /* "libopenzwave.pyx":4592
 *                 free(dbuf)
 *                 pass
 *         return data             # <<<<<<<<<<<<<<
 * 
 *     def removeAllScenes(self, homeid):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_data);
  __pyx_r = __pyx_v_data;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4553
 *         return self.manager.GetNumScenes()
 * 
 *     def getAllScenes(self):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getAllScenes:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getAllScenes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_data);
  __Pyx_XDECREF((PyObject *)__pyx_v_retuint8);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4594
 *         return data
 * 
 *     def removeAllScenes(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeAllScenes:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_309removeAllScenes(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_308removeAllScenes[] = "\n.. _removeAllScenes:\n\nDelete all scenes.\n\n:param homeid: The Home ID of the Z-Wave controller that manages the node.\n:type homeid: int\n:see: getNumScenes_, getAllScenes_, sceneExists_, removeScene_, activateScene_, getSceneLabel_, setSceneLabel_, removeSceneValue_, addSceneValue_, setSceneValue_, sceneGetValues_\n\n       ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_309removeAllScenes(PyObject *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("removeAllScenes (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_308removeAllScenes(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_homeid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_308removeAllScenes(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_homeid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint32_t __pyx_t_1;
  __Pyx_RefNannySetupContext("removeAllScenes", 0);

  /* "libopenzwave.pyx":4608
 * 
 *        '''
 *         self.manager.RemoveAllScenes(homeid)             # <<<<<<<<<<<<<<
 * 
 *     def removeScene(self, sceneId):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint32_t(__pyx_v_homeid); if (unlikely((__pyx_t_1 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4608, __pyx_L1_error)
  __pyx_v_self->manager->RemoveAllScenes(__pyx_t_1);

  /* "libopenzwave.pyx":4594
 *         return data
 * 
 *     def removeAllScenes(self, homeid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeAllScenes:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.removeAllScenes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4610
 *         self.manager.RemoveAllScenes(homeid)
 * 
 *     def removeScene(self, sceneId):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeScene:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_311removeScene(PyObject *__pyx_v_self, PyObject *__pyx_v_sceneId); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_310removeScene[] = "\n.. _removeScene:\n\nRemove an existing Scene.\n\n:param sceneId: The unique Scene ID to be removed.\n:type sceneId: int\n:return: True if scene was removed.\n:rtype: bool\n:see: getNumScenes_, getAllScenes_, sceneExists_, createScene_, activateScene_, getSceneLabel_, setSceneLabel_, removeSceneValue_, addSceneValue_, setSceneValue_, sceneGetValues_, removeAllScenes_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_311removeScene(PyObject *__pyx_v_self, PyObject *__pyx_v_sceneId) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("removeScene (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_310removeScene(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_sceneId));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_310removeScene(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_sceneId) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint8_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("removeScene", 0);

  /* "libopenzwave.pyx":4626
 * 
 *         '''
 *         return self.manager.RemoveScene(sceneId)             # <<<<<<<<<<<<<<
 * 
 *     def createScene(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint8_t(__pyx_v_sceneId); if (unlikely((__pyx_t_1 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4626, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->RemoveScene(__pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4626, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4610
 *         self.manager.RemoveAllScenes(homeid)
 * 
 *     def removeScene(self, sceneId):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeScene:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.removeScene", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4628
 *         return self.manager.RemoveScene(sceneId)
 * 
 *     def createScene(self):             # <<<<<<<<<<<<<<
 *         '''
 * .. _createScene:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_313createScene(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_312createScene[] = "\n.. _createScene:\n\nCreate a Scene.\n\n:return: Scene ID used to reference the scene. 0 is failure result.\n:rtype: id\n:see: getNumScenes_, getAllScenes_, sceneExists_, removeScene_, activateScene_, getSceneLabel_, setSceneLabel_, removeSceneValue_, addSceneValue_, setSceneValue_, sceneGetValues_, removeAllScenes_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_313createScene(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("createScene (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_312createScene(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_312createScene(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("createScene", 0);

  /* "libopenzwave.pyx":4642
 * 
 *         '''
 *         return self.manager.CreateScene()             # <<<<<<<<<<<<<<
 * 
 *     def sceneGetValues(self, uint8_t id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_uint8_t(__pyx_v_self->manager->CreateScene()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4642, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4628
 *         return self.manager.RemoveScene(sceneId)
 * 
 *     def createScene(self):             # <<<<<<<<<<<<<<
 *         '''
 * .. _createScene:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("libopenzwave.PyManager.createScene", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4644
 *         return self.manager.CreateScene()
 * 
 *     def sceneGetValues(self, uint8_t id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _sceneGetValues:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_315sceneGetValues(PyObject *__pyx_v_self, PyObject *__pyx_arg_id); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_314sceneGetValues[] = "\n.. _sceneGetValues:\n\nRetrieve the list of values from a scene.\n\n:param id: The ID of a scene.\n:type id: int\n:rtype: dict()\n:return: A dict containing : {valueid : value, ...}\n:see: getNumScenes_, getAllScenes_, sceneExists_, createScene_, removeScene_, getSceneLabel_, setSceneLabel_, removeSceneValue_, addSceneValue_, setSceneValue_, sceneGetValues_, removeAllScenes_\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_315sceneGetValues(PyObject *__pyx_v_self, PyObject *__pyx_arg_id) {
  uint8_t __pyx_v_id;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sceneGetValues (wrapper)", 0);
  assert(__pyx_arg_id); {
    __pyx_v_id = __Pyx_PyInt_As_uint8_t(__pyx_arg_id); if (unlikely((__pyx_v_id == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4644, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.sceneGetValues", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_314sceneGetValues(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((uint8_t)__pyx_v_id));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_314sceneGetValues(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, uint8_t __pyx_v_id) {
  float __pyx_v_type_float;
  bool __pyx_v_type_bool;
  uint8_t __pyx_v_type_byte;
  int32_t __pyx_v_type_int;
  int16_t __pyx_v_type_short;
  std::string __pyx_v_type_string;
  OpenZWave::ValueID *__pyx_v_cvalueID;
  std::vector<OpenZWave::ValueID>  __pyx_v_vect;
  PyObject *__pyx_v_ret = NULL;
  PyObject *__pyx_v_datatype = NULL;
  PyObject *__pyx_v_value_data = NULL;
  uint64_t __pyx_v_value_id;
  bool __pyx_v_cret;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("sceneGetValues", 0);

  /* "libopenzwave.pyx":4668
 *         cdef ValueID* cvalueID
 *         cdef vector[ValueID] vect
 *         ret = dict()             # <<<<<<<<<<<<<<
 *         if self.manager.SceneGetValues(id, &vect):
 *             while not vect.empty() :
 */
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4668, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_ret = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "libopenzwave.pyx":4669
 *         cdef vector[ValueID] vect
 *         ret = dict()
 *         if self.manager.SceneGetValues(id, &vect):             # <<<<<<<<<<<<<<
 *             while not vect.empty() :
 *                 cvalueID = &vect.back()
 */
  __pyx_t_2 = (__pyx_v_self->manager->SceneGetValues(__pyx_v_id, (&__pyx_v_vect)) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":4670
 *         ret = dict()
 *         if self.manager.SceneGetValues(id, &vect):
 *             while not vect.empty() :             # <<<<<<<<<<<<<<
 *                 cvalueID = &vect.back()
 *                 datatype = PyValueTypes[cvalueID.GetType()]
 */
    while (1) {
      __pyx_t_2 = ((!(__pyx_v_vect.empty() != 0)) != 0);
      if (!__pyx_t_2) break;

      /* "libopenzwave.pyx":4671
 *         if self.manager.SceneGetValues(id, &vect):
 *             while not vect.empty() :
 *                 cvalueID = &vect.back()             # <<<<<<<<<<<<<<
 *                 datatype = PyValueTypes[cvalueID.GetType()]
 *                 value_data = None
 */
      __pyx_v_cvalueID = (&__pyx_v_vect.back());

      /* "libopenzwave.pyx":4672
 *             while not vect.empty() :
 *                 cvalueID = &vect.back()
 *                 datatype = PyValueTypes[cvalueID.GetType()]             # <<<<<<<<<<<<<<
 *                 value_data = None
 *                 value_id = cvalueID.GetId()
 */
      __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyValueTypes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4672, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_3 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueType(__pyx_v_cvalueID->GetType()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4672, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PyObject_GetItem(__pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4672, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF_SET(__pyx_v_datatype, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "libopenzwave.pyx":4673
 *                 cvalueID = &vect.back()
 *                 datatype = PyValueTypes[cvalueID.GetType()]
 *                 value_data = None             # <<<<<<<<<<<<<<
 *                 value_id = cvalueID.GetId()
 *                 if datatype == "Bool":
 */
      __Pyx_INCREF(Py_None);
      __Pyx_XDECREF_SET(__pyx_v_value_data, Py_None);

      /* "libopenzwave.pyx":4674
 *                 datatype = PyValueTypes[cvalueID.GetType()]
 *                 value_data = None
 *                 value_id = cvalueID.GetId()             # <<<<<<<<<<<<<<
 *                 if datatype == "Bool":
 *                     cret = self.manager.SceneGetValueAsBool(id, deref(cvalueID), &type_bool)
 */
      __pyx_v_value_id = __pyx_v_cvalueID->GetId();

      /* "libopenzwave.pyx":4675
 *                 value_data = None
 *                 value_id = cvalueID.GetId()
 *                 if datatype == "Bool":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueAsBool(id, deref(cvalueID), &type_bool)
 *                     value_data = type_bool if cret else None
 */
      __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Bool, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4675, __pyx_L1_error)
      if (__pyx_t_2) {

        /* "libopenzwave.pyx":4676
 *                 value_id = cvalueID.GetId()
 *                 if datatype == "Bool":
 *                     cret = self.manager.SceneGetValueAsBool(id, deref(cvalueID), &type_bool)             # <<<<<<<<<<<<<<
 *                     value_data = type_bool if cret else None
 *                 elif datatype == "Byte":
 */
        __pyx_v_cret = __pyx_v_self->manager->SceneGetValueAsBool(__pyx_v_id, (*__pyx_v_cvalueID), (&__pyx_v_type_bool));

        /* "libopenzwave.pyx":4677
 *                 if datatype == "Bool":
 *                     cret = self.manager.SceneGetValueAsBool(id, deref(cvalueID), &type_bool)
 *                     value_data = type_bool if cret else None             # <<<<<<<<<<<<<<
 *                 elif datatype == "Byte":
 *                     cret = self.manager.SceneGetValueAsByte(id, deref(cvalueID), &type_byte)
 */
        if ((__pyx_v_cret != 0)) {
          __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_type_bool); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4677, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_4 = __pyx_t_3;
          __pyx_t_3 = 0;
        } else {
          __Pyx_INCREF(Py_None);
          __pyx_t_4 = Py_None;
        }
        __Pyx_DECREF_SET(__pyx_v_value_data, __pyx_t_4);
        __pyx_t_4 = 0;

        /* "libopenzwave.pyx":4675
 *                 value_data = None
 *                 value_id = cvalueID.GetId()
 *                 if datatype == "Bool":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueAsBool(id, deref(cvalueID), &type_bool)
 *                     value_data = type_bool if cret else None
 */
        goto __pyx_L6;
      }

      /* "libopenzwave.pyx":4678
 *                     cret = self.manager.SceneGetValueAsBool(id, deref(cvalueID), &type_bool)
 *                     value_data = type_bool if cret else None
 *                 elif datatype == "Byte":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueAsByte(id, deref(cvalueID), &type_byte)
 *                     value_data = type_byte if cret else None
 */
      __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Byte, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4678, __pyx_L1_error)
      if (__pyx_t_2) {

        /* "libopenzwave.pyx":4679
 *                     value_data = type_bool if cret else None
 *                 elif datatype == "Byte":
 *                     cret = self.manager.SceneGetValueAsByte(id, deref(cvalueID), &type_byte)             # <<<<<<<<<<<<<<
 *                     value_data = type_byte if cret else None
 *                 elif datatype == "Decimal":
 */
        __pyx_v_cret = __pyx_v_self->manager->SceneGetValueAsByte(__pyx_v_id, (*__pyx_v_cvalueID), (&__pyx_v_type_byte));

        /* "libopenzwave.pyx":4680
 *                 elif datatype == "Byte":
 *                     cret = self.manager.SceneGetValueAsByte(id, deref(cvalueID), &type_byte)
 *                     value_data = type_byte if cret else None             # <<<<<<<<<<<<<<
 *                 elif datatype == "Decimal":
 *                     cret = self.manager.SceneGetValueAsFloat(id, deref(cvalueID), &type_float)
 */
        if ((__pyx_v_cret != 0)) {
          __pyx_t_3 = __Pyx_PyInt_From_uint8_t(__pyx_v_type_byte); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4680, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_4 = __pyx_t_3;
          __pyx_t_3 = 0;
        } else {
          __Pyx_INCREF(Py_None);
          __pyx_t_4 = Py_None;
        }
        __Pyx_DECREF_SET(__pyx_v_value_data, __pyx_t_4);
        __pyx_t_4 = 0;

        /* "libopenzwave.pyx":4678
 *                     cret = self.manager.SceneGetValueAsBool(id, deref(cvalueID), &type_bool)
 *                     value_data = type_bool if cret else None
 *                 elif datatype == "Byte":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueAsByte(id, deref(cvalueID), &type_byte)
 *                     value_data = type_byte if cret else None
 */
        goto __pyx_L6;
      }

      /* "libopenzwave.pyx":4681
 *                     cret = self.manager.SceneGetValueAsByte(id, deref(cvalueID), &type_byte)
 *                     value_data = type_byte if cret else None
 *                 elif datatype == "Decimal":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueAsFloat(id, deref(cvalueID), &type_float)
 *                     value_data = type_float if cret else None
 */
      __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Decimal, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4681, __pyx_L1_error)
      if (__pyx_t_2) {

        /* "libopenzwave.pyx":4682
 *                     value_data = type_byte if cret else None
 *                 elif datatype == "Decimal":
 *                     cret = self.manager.SceneGetValueAsFloat(id, deref(cvalueID), &type_float)             # <<<<<<<<<<<<<<
 *                     value_data = type_float if cret else None
 *                 elif datatype == "Int":
 */
        __pyx_v_cret = __pyx_v_self->manager->SceneGetValueAsFloat(__pyx_v_id, (*__pyx_v_cvalueID), (&__pyx_v_type_float));

        /* "libopenzwave.pyx":4683
 *                 elif datatype == "Decimal":
 *                     cret = self.manager.SceneGetValueAsFloat(id, deref(cvalueID), &type_float)
 *                     value_data = type_float if cret else None             # <<<<<<<<<<<<<<
 *                 elif datatype == "Int":
 *                     cret = self.manager.SceneGetValueAsInt(id, deref(cvalueID), &type_int)
 */
        if ((__pyx_v_cret != 0)) {
          __pyx_t_3 = PyFloat_FromDouble(__pyx_v_type_float); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4683, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_4 = __pyx_t_3;
          __pyx_t_3 = 0;
        } else {
          __Pyx_INCREF(Py_None);
          __pyx_t_4 = Py_None;
        }
        __Pyx_DECREF_SET(__pyx_v_value_data, __pyx_t_4);
        __pyx_t_4 = 0;

        /* "libopenzwave.pyx":4681
 *                     cret = self.manager.SceneGetValueAsByte(id, deref(cvalueID), &type_byte)
 *                     value_data = type_byte if cret else None
 *                 elif datatype == "Decimal":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueAsFloat(id, deref(cvalueID), &type_float)
 *                     value_data = type_float if cret else None
 */
        goto __pyx_L6;
      }

      /* "libopenzwave.pyx":4684
 *                     cret = self.manager.SceneGetValueAsFloat(id, deref(cvalueID), &type_float)
 *                     value_data = type_float if cret else None
 *                 elif datatype == "Int":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueAsInt(id, deref(cvalueID), &type_int)
 *                     value_data = type_int if cret else None
 */
      __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Int, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4684, __pyx_L1_error)
      if (__pyx_t_2) {

        /* "libopenzwave.pyx":4685
 *                     value_data = type_float if cret else None
 *                 elif datatype == "Int":
 *                     cret = self.manager.SceneGetValueAsInt(id, deref(cvalueID), &type_int)             # <<<<<<<<<<<<<<
 *                     value_data = type_int if cret else None
 *                 elif datatype == "Short":
 */
        __pyx_v_cret = __pyx_v_self->manager->SceneGetValueAsInt(__pyx_v_id, (*__pyx_v_cvalueID), (&__pyx_v_type_int));

        /* "libopenzwave.pyx":4686
 *                 elif datatype == "Int":
 *                     cret = self.manager.SceneGetValueAsInt(id, deref(cvalueID), &type_int)
 *                     value_data = type_int if cret else None             # <<<<<<<<<<<<<<
 *                 elif datatype == "Short":
 *                     cret = self.manager.SceneGetValueAsShort(id, deref(cvalueID), &type_short)
 */
        if ((__pyx_v_cret != 0)) {
          __pyx_t_3 = __Pyx_PyInt_From_int32_t(__pyx_v_type_int); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4686, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_4 = __pyx_t_3;
          __pyx_t_3 = 0;
        } else {
          __Pyx_INCREF(Py_None);
          __pyx_t_4 = Py_None;
        }
        __Pyx_DECREF_SET(__pyx_v_value_data, __pyx_t_4);
        __pyx_t_4 = 0;

        /* "libopenzwave.pyx":4684
 *                     cret = self.manager.SceneGetValueAsFloat(id, deref(cvalueID), &type_float)
 *                     value_data = type_float if cret else None
 *                 elif datatype == "Int":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueAsInt(id, deref(cvalueID), &type_int)
 *                     value_data = type_int if cret else None
 */
        goto __pyx_L6;
      }

      /* "libopenzwave.pyx":4687
 *                     cret = self.manager.SceneGetValueAsInt(id, deref(cvalueID), &type_int)
 *                     value_data = type_int if cret else None
 *                 elif datatype == "Short":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueAsShort(id, deref(cvalueID), &type_short)
 *                     value_data = type_short if cret else None
 */
      __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Short, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4687, __pyx_L1_error)
      if (__pyx_t_2) {

        /* "libopenzwave.pyx":4688
 *                     value_data = type_int if cret else None
 *                 elif datatype == "Short":
 *                     cret = self.manager.SceneGetValueAsShort(id, deref(cvalueID), &type_short)             # <<<<<<<<<<<<<<
 *                     value_data = type_short if cret else None
 *                 elif datatype == "String":
 */
        __pyx_v_cret = __pyx_v_self->manager->SceneGetValueAsShort(__pyx_v_id, (*__pyx_v_cvalueID), (&__pyx_v_type_short));

        /* "libopenzwave.pyx":4689
 *                 elif datatype == "Short":
 *                     cret = self.manager.SceneGetValueAsShort(id, deref(cvalueID), &type_short)
 *                     value_data = type_short if cret else None             # <<<<<<<<<<<<<<
 *                 elif datatype == "String":
 *                     cret = self.manager.SceneGetValueAsString(id, deref(cvalueID), &type_string)
 */
        if ((__pyx_v_cret != 0)) {
          __pyx_t_3 = __Pyx_PyInt_From_int16_t(__pyx_v_type_short); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4689, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_4 = __pyx_t_3;
          __pyx_t_3 = 0;
        } else {
          __Pyx_INCREF(Py_None);
          __pyx_t_4 = Py_None;
        }
        __Pyx_DECREF_SET(__pyx_v_value_data, __pyx_t_4);
        __pyx_t_4 = 0;

        /* "libopenzwave.pyx":4687
 *                     cret = self.manager.SceneGetValueAsInt(id, deref(cvalueID), &type_int)
 *                     value_data = type_int if cret else None
 *                 elif datatype == "Short":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueAsShort(id, deref(cvalueID), &type_short)
 *                     value_data = type_short if cret else None
 */
        goto __pyx_L6;
      }

      /* "libopenzwave.pyx":4690
 *                     cret = self.manager.SceneGetValueAsShort(id, deref(cvalueID), &type_short)
 *                     value_data = type_short if cret else None
 *                 elif datatype == "String":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueAsString(id, deref(cvalueID), &type_string)
 *                     value_data = type_string.c_str() if cret else None
 */
      __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_String, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4690, __pyx_L1_error)
      if (__pyx_t_2) {

        /* "libopenzwave.pyx":4691
 *                     value_data = type_short if cret else None
 *                 elif datatype == "String":
 *                     cret = self.manager.SceneGetValueAsString(id, deref(cvalueID), &type_string)             # <<<<<<<<<<<<<<
 *                     value_data = type_string.c_str() if cret else None
 *                 elif datatype == "Button":
 */
        __pyx_v_cret = __pyx_v_self->manager->SceneGetValueAsString(__pyx_v_id, (*__pyx_v_cvalueID), (&__pyx_v_type_string));

        /* "libopenzwave.pyx":4692
 *                 elif datatype == "String":
 *                     cret = self.manager.SceneGetValueAsString(id, deref(cvalueID), &type_string)
 *                     value_data = type_string.c_str() if cret else None             # <<<<<<<<<<<<<<
 *                 elif datatype == "Button":
 *                     cret = self.manager.SceneGetValueAsBool(id, deref(cvalueID), &type_bool)
 */
        if ((__pyx_v_cret != 0)) {
          __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_type_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4692, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_4 = __pyx_t_3;
          __pyx_t_3 = 0;
        } else {
          __Pyx_INCREF(Py_None);
          __pyx_t_4 = Py_None;
        }
        __Pyx_DECREF_SET(__pyx_v_value_data, __pyx_t_4);
        __pyx_t_4 = 0;

        /* "libopenzwave.pyx":4690
 *                     cret = self.manager.SceneGetValueAsShort(id, deref(cvalueID), &type_short)
 *                     value_data = type_short if cret else None
 *                 elif datatype == "String":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueAsString(id, deref(cvalueID), &type_string)
 *                     value_data = type_string.c_str() if cret else None
 */
        goto __pyx_L6;
      }

      /* "libopenzwave.pyx":4693
 *                     cret = self.manager.SceneGetValueAsString(id, deref(cvalueID), &type_string)
 *                     value_data = type_string.c_str() if cret else None
 *                 elif datatype == "Button":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueAsBool(id, deref(cvalueID), &type_bool)
 *                     value_data = type_bool if cret else None
 */
      __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Button, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4693, __pyx_L1_error)
      if (__pyx_t_2) {

        /* "libopenzwave.pyx":4694
 *                     value_data = type_string.c_str() if cret else None
 *                 elif datatype == "Button":
 *                     cret = self.manager.SceneGetValueAsBool(id, deref(cvalueID), &type_bool)             # <<<<<<<<<<<<<<
 *                     value_data = type_bool if cret else None
 *                 elif datatype == "List":
 */
        __pyx_v_cret = __pyx_v_self->manager->SceneGetValueAsBool(__pyx_v_id, (*__pyx_v_cvalueID), (&__pyx_v_type_bool));

        /* "libopenzwave.pyx":4695
 *                 elif datatype == "Button":
 *                     cret = self.manager.SceneGetValueAsBool(id, deref(cvalueID), &type_bool)
 *                     value_data = type_bool if cret else None             # <<<<<<<<<<<<<<
 *                 elif datatype == "List":
 *                     cret = self.manager.SceneGetValueListSelection(id, deref(cvalueID), &type_string)
 */
        if ((__pyx_v_cret != 0)) {
          __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_type_bool); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4695, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_4 = __pyx_t_3;
          __pyx_t_3 = 0;
        } else {
          __Pyx_INCREF(Py_None);
          __pyx_t_4 = Py_None;
        }
        __Pyx_DECREF_SET(__pyx_v_value_data, __pyx_t_4);
        __pyx_t_4 = 0;

        /* "libopenzwave.pyx":4693
 *                     cret = self.manager.SceneGetValueAsString(id, deref(cvalueID), &type_string)
 *                     value_data = type_string.c_str() if cret else None
 *                 elif datatype == "Button":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueAsBool(id, deref(cvalueID), &type_bool)
 *                     value_data = type_bool if cret else None
 */
        goto __pyx_L6;
      }

      /* "libopenzwave.pyx":4696
 *                     cret = self.manager.SceneGetValueAsBool(id, deref(cvalueID), &type_bool)
 *                     value_data = type_bool if cret else None
 *                 elif datatype == "List":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueListSelection(id, deref(cvalueID), &type_string)
 *                     value_data = type_string.c_str() if cret else None
 */
      __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_List, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4696, __pyx_L1_error)
      if (__pyx_t_2) {

        /* "libopenzwave.pyx":4697
 *                     value_data = type_bool if cret else None
 *                 elif datatype == "List":
 *                     cret = self.manager.SceneGetValueListSelection(id, deref(cvalueID), &type_string)             # <<<<<<<<<<<<<<
 *                     value_data = type_string.c_str() if cret else None
 *                 else :
 */
        __pyx_v_cret = __pyx_v_self->manager->SceneGetValueListSelection(__pyx_v_id, (*__pyx_v_cvalueID), (&__pyx_v_type_string));

        /* "libopenzwave.pyx":4698
 *                 elif datatype == "List":
 *                     cret = self.manager.SceneGetValueListSelection(id, deref(cvalueID), &type_string)
 *                     value_data = type_string.c_str() if cret else None             # <<<<<<<<<<<<<<
 *                 else :
 *                     cret = self.manager.SceneGetValueAsString(id, deref(cvalueID), &type_string)
 */
        if ((__pyx_v_cret != 0)) {
          __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_type_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4698, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_4 = __pyx_t_3;
          __pyx_t_3 = 0;
        } else {
          __Pyx_INCREF(Py_None);
          __pyx_t_4 = Py_None;
        }
        __Pyx_DECREF_SET(__pyx_v_value_data, __pyx_t_4);
        __pyx_t_4 = 0;

        /* "libopenzwave.pyx":4696
 *                     cret = self.manager.SceneGetValueAsBool(id, deref(cvalueID), &type_bool)
 *                     value_data = type_bool if cret else None
 *                 elif datatype == "List":             # <<<<<<<<<<<<<<
 *                     cret = self.manager.SceneGetValueListSelection(id, deref(cvalueID), &type_string)
 *                     value_data = type_string.c_str() if cret else None
 */
        goto __pyx_L6;
      }

      /* "libopenzwave.pyx":4700
 *                     value_data = type_string.c_str() if cret else None
 *                 else :
 *                     cret = self.manager.SceneGetValueAsString(id, deref(cvalueID), &type_string)             # <<<<<<<<<<<<<<
 *                     value_data = type_string.c_str() if cret else None
 *                 ret[value_id] = value_data
 */
      /*else*/ {
        __pyx_v_cret = __pyx_v_self->manager->SceneGetValueAsString(__pyx_v_id, (*__pyx_v_cvalueID), (&__pyx_v_type_string));

        /* "libopenzwave.pyx":4701
 *                 else :
 *                     cret = self.manager.SceneGetValueAsString(id, deref(cvalueID), &type_string)
 *                     value_data = type_string.c_str() if cret else None             # <<<<<<<<<<<<<<
 *                 ret[value_id] = value_data
 *                 vect.pop_back();
 */
        if ((__pyx_v_cret != 0)) {
          __pyx_t_3 = __Pyx_PyUnicode_FromString(__pyx_v_type_string.c_str()); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4701, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_4 = __pyx_t_3;
          __pyx_t_3 = 0;
        } else {
          __Pyx_INCREF(Py_None);
          __pyx_t_4 = Py_None;
        }
        __Pyx_DECREF_SET(__pyx_v_value_data, __pyx_t_4);
        __pyx_t_4 = 0;
      }
      __pyx_L6:;

      /* "libopenzwave.pyx":4702
 *                     cret = self.manager.SceneGetValueAsString(id, deref(cvalueID), &type_string)
 *                     value_data = type_string.c_str() if cret else None
 *                 ret[value_id] = value_data             # <<<<<<<<<<<<<<
 *                 vect.pop_back();
 *         return ret
 */
      __pyx_t_4 = __Pyx_PyInt_From_uint64_t(__pyx_v_value_id); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4702, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      if (unlikely(PyDict_SetItem(__pyx_v_ret, __pyx_t_4, __pyx_v_value_data) < 0)) __PYX_ERR(0, 4702, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

      /* "libopenzwave.pyx":4703
 *                     value_data = type_string.c_str() if cret else None
 *                 ret[value_id] = value_data
 *                 vect.pop_back();             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
      __pyx_v_vect.pop_back();
    }

    /* "libopenzwave.pyx":4669
 *         cdef vector[ValueID] vect
 *         ret = dict()
 *         if self.manager.SceneGetValues(id, &vect):             # <<<<<<<<<<<<<<
 *             while not vect.empty() :
 *                 cvalueID = &vect.back()
 */
  }

  /* "libopenzwave.pyx":4704
 *                 ret[value_id] = value_data
 *                 vect.pop_back();
 *         return ret             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4644
 *         return self.manager.CreateScene()
 * 
 *     def sceneGetValues(self, uint8_t id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _sceneGetValues:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.sceneGetValues", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_ret);
  __Pyx_XDECREF(__pyx_v_datatype);
  __Pyx_XDECREF(__pyx_v_value_data);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4707
 * 
 * 
 *     def addSceneValue(self, uint8_t sceneid, id, value):             # <<<<<<<<<<<<<<
 *         '''
 * .. _addSceneValue:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_317addSceneValue(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_316addSceneValue[] = "\n.. _addSceneValue:\n\nAdd a ValueID of value to an existing scene.\n\nActually I don't know how to use it :)\n\n:param sceneid: The ID of a scene.\n:type sceneid: int\n:param id: The ID of a value.\n:type id: int\n:param value: The value to set\n:type value: bool, int, float, string\n:return: An integer representing the result of the operation\n    0 : The C method fails\n    1 : The C method succeed\n    2 : Can't find id in the map\n:rtype: int\n:see: getNumScenes_, getAllScenes_, sceneExists_, removeAllScenes_, createScene_, removeScene_, activateScene_, getSceneLabel_, setSceneLabel_, removeSceneValue_, setSceneValue_, sceneGetValues_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_317addSceneValue(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  uint8_t __pyx_v_sceneid;
  PyObject *__pyx_v_id = 0;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("addSceneValue (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_sceneid,&__pyx_n_s_id,&__pyx_n_s_value,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_sceneid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("addSceneValue", 1, 3, 3, 1); __PYX_ERR(0, 4707, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("addSceneValue", 1, 3, 3, 2); __PYX_ERR(0, 4707, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "addSceneValue") < 0)) __PYX_ERR(0, 4707, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_sceneid = __Pyx_PyInt_As_uint8_t(values[0]); if (unlikely((__pyx_v_sceneid == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4707, __pyx_L3_error)
    __pyx_v_id = values[1];
    __pyx_v_value = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("addSceneValue", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4707, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.addSceneValue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_316addSceneValue(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_sceneid, __pyx_v_id, __pyx_v_value);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_316addSceneValue(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, uint8_t __pyx_v_sceneid, PyObject *__pyx_v_id, PyObject *__pyx_v_value) {
  float __pyx_v_type_float;
  bool __pyx_v_type_bool;
  uint8_t __pyx_v_type_byte;
  int32_t __pyx_v_type_int;
  int16_t __pyx_v_type_short;
  std::string __pyx_v_type_string;
  long __pyx_v_ret;
  PyObject *__pyx_v_datatype = NULL;
  bool __pyx_v_cret;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  bool __pyx_t_7;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_8;
  long __pyx_t_9;
  uint8_t __pyx_t_10;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_11;
  float __pyx_t_12;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_13;
  int32_t __pyx_t_14;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_15;
  int16_t __pyx_t_16;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_17;
  char *__pyx_t_18;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_19;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_20;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_21;
  __Pyx_RefNannySetupContext("addSceneValue", 0);

  /* "libopenzwave.pyx":4737
 *         cdef int16_t type_short
 *         cdef string type_string
 *         ret = 2             # <<<<<<<<<<<<<<
 *         if values_map.find(id) != values_map.end():
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 */
  __pyx_v_ret = 2;

  /* "libopenzwave.pyx":4738
 *         cdef string type_string
 *         ret = 2
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4738, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":4739
 *         ret = 2
 *         if values_map.find(id) != values_map.end():
 *             datatype = PyValueTypes[values_map.at(id).GetType()]             # <<<<<<<<<<<<<<
 *             if datatype == "Bool":
 *                 type_bool = value
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyValueTypes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4739, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4739, __pyx_L1_error)
    try {
      __pyx_t_4 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 4739, __pyx_L1_error)
    }
    __pyx_t_5 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueType(__pyx_t_4->GetType()); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4739, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = PyObject_GetItem(__pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4739, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_v_datatype = __pyx_t_6;
    __pyx_t_6 = 0;

    /* "libopenzwave.pyx":4740
 *         if values_map.find(id) != values_map.end():
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":             # <<<<<<<<<<<<<<
 *                 type_bool = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Bool, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4740, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4741
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":
 *                 type_bool = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_7 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4741, __pyx_L1_error)
      __pyx_v_type_bool = __pyx_t_7;

      /* "libopenzwave.pyx":4742
 *             if datatype == "Bool":
 *                 type_bool = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Byte":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4742, __pyx_L1_error)
      try {
        __pyx_t_8 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4742, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->AddSceneValue(__pyx_v_sceneid, __pyx_t_8, __pyx_v_type_bool);

      /* "libopenzwave.pyx":4743
 *                 type_bool = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Byte":
 *                 type_byte = value
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4740
 *         if values_map.find(id) != values_map.end():
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":             # <<<<<<<<<<<<<<
 *                 type_bool = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":4744
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Byte":             # <<<<<<<<<<<<<<
 *                 type_byte = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_byte)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Byte, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4744, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4745
 *                 ret = 1 if cret else 0
 *             elif datatype == "Byte":
 *                 type_byte = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_byte)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_10 = __Pyx_PyInt_As_uint8_t(__pyx_v_value); if (unlikely((__pyx_t_10 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4745, __pyx_L1_error)
      __pyx_v_type_byte = __pyx_t_10;

      /* "libopenzwave.pyx":4746
 *             elif datatype == "Byte":
 *                 type_byte = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_byte)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Decimal":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4746, __pyx_L1_error)
      try {
        __pyx_t_11 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4746, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->AddSceneValue(__pyx_v_sceneid, __pyx_t_11, __pyx_v_type_byte);

      /* "libopenzwave.pyx":4747
 *                 type_byte = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_byte)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Decimal":
 *                 type_float = value
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4744
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Byte":             # <<<<<<<<<<<<<<
 *                 type_byte = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_byte)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":4748
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_byte)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Decimal":             # <<<<<<<<<<<<<<
 *                 type_float = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_float)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Decimal, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4748, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4749
 *                 ret = 1 if cret else 0
 *             elif datatype == "Decimal":
 *                 type_float = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_float)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_12 = __pyx_PyFloat_AsFloat(__pyx_v_value); if (unlikely((__pyx_t_12 == (float)-1) && PyErr_Occurred())) __PYX_ERR(0, 4749, __pyx_L1_error)
      __pyx_v_type_float = __pyx_t_12;

      /* "libopenzwave.pyx":4750
 *             elif datatype == "Decimal":
 *                 type_float = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_float)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Int":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4750, __pyx_L1_error)
      try {
        __pyx_t_13 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4750, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->AddSceneValue(__pyx_v_sceneid, __pyx_t_13, __pyx_v_type_float);

      /* "libopenzwave.pyx":4751
 *                 type_float = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_float)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Int":
 *                 type_int = value
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4748
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_byte)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Decimal":             # <<<<<<<<<<<<<<
 *                 type_float = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_float)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":4752
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_float)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Int":             # <<<<<<<<<<<<<<
 *                 type_int = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_int)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Int, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4752, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4753
 *                 ret = 1 if cret else 0
 *             elif datatype == "Int":
 *                 type_int = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_int)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_14 = __Pyx_PyInt_As_int32_t(__pyx_v_value); if (unlikely((__pyx_t_14 == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4753, __pyx_L1_error)
      __pyx_v_type_int = __pyx_t_14;

      /* "libopenzwave.pyx":4754
 *             elif datatype == "Int":
 *                 type_int = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_int)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Short":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4754, __pyx_L1_error)
      try {
        __pyx_t_15 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4754, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->AddSceneValue(__pyx_v_sceneid, __pyx_t_15, __pyx_v_type_int);

      /* "libopenzwave.pyx":4755
 *                 type_int = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_int)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Short":
 *                 type_short = value
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4752
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_float)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Int":             # <<<<<<<<<<<<<<
 *                 type_int = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_int)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":4756
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_int)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Short":             # <<<<<<<<<<<<<<
 *                 type_short = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_short)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Short, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4756, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4757
 *                 ret = 1 if cret else 0
 *             elif datatype == "Short":
 *                 type_short = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_short)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_16 = __Pyx_PyInt_As_int16_t(__pyx_v_value); if (unlikely((__pyx_t_16 == ((int16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4757, __pyx_L1_error)
      __pyx_v_type_short = __pyx_t_16;

      /* "libopenzwave.pyx":4758
 *             elif datatype == "Short":
 *                 type_short = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_short)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "String":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4758, __pyx_L1_error)
      try {
        __pyx_t_17 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4758, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->AddSceneValue(__pyx_v_sceneid, __pyx_t_17, __pyx_v_type_short);

      /* "libopenzwave.pyx":4759
 *                 type_short = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_short)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "String":
 *                 type_string = string(value)
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4756
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_int)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Short":             # <<<<<<<<<<<<<<
 *                 type_short = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_short)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":4760
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_short)
 *                 ret = 1 if cret else 0
 *             elif datatype == "String":             # <<<<<<<<<<<<<<
 *                 type_string = string(value)
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_string)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_String, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4760, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4761
 *                 ret = 1 if cret else 0
 *             elif datatype == "String":
 *                 type_string = string(value)             # <<<<<<<<<<<<<<
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_string)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_18 = __Pyx_PyObject_AsString(__pyx_v_value); if (unlikely((!__pyx_t_18) && PyErr_Occurred())) __PYX_ERR(0, 4761, __pyx_L1_error)
      __pyx_v_type_string = std::string(__pyx_t_18);

      /* "libopenzwave.pyx":4762
 *             elif datatype == "String":
 *                 type_string = string(value)
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_string)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Button":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4762, __pyx_L1_error)
      try {
        __pyx_t_19 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4762, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->AddSceneValue(__pyx_v_sceneid, __pyx_t_19, __pyx_v_type_string);

      /* "libopenzwave.pyx":4763
 *                 type_string = string(value)
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_string)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Button":
 *                 type_bool = value
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4760
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_short)
 *                 ret = 1 if cret else 0
 *             elif datatype == "String":             # <<<<<<<<<<<<<<
 *                 type_string = string(value)
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_string)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":4764
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_string)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Button":             # <<<<<<<<<<<<<<
 *                 type_bool = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Button, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4764, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4765
 *                 ret = 1 if cret else 0
 *             elif datatype == "Button":
 *                 type_bool = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_7 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4765, __pyx_L1_error)
      __pyx_v_type_bool = __pyx_t_7;

      /* "libopenzwave.pyx":4766
 *             elif datatype == "Button":
 *                 type_bool = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "List":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4766, __pyx_L1_error)
      try {
        __pyx_t_20 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4766, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->AddSceneValue(__pyx_v_sceneid, __pyx_t_20, __pyx_v_type_bool);

      /* "libopenzwave.pyx":4767
 *                 type_bool = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "List":
 *                 type_string = string(value)
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4764
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_string)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Button":             # <<<<<<<<<<<<<<
 *                 type_bool = value
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":4768
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 *             elif datatype == "List":             # <<<<<<<<<<<<<<
 *                 type_string = string(value)
 *                 cret = self.manager.AddSceneValueListSelection(sceneid, values_map.at(id), type_string)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_List, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4768, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4769
 *                 ret = 1 if cret else 0
 *             elif datatype == "List":
 *                 type_string = string(value)             # <<<<<<<<<<<<<<
 *                 cret = self.manager.AddSceneValueListSelection(sceneid, values_map.at(id), type_string)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_18 = __Pyx_PyObject_AsString(__pyx_v_value); if (unlikely((!__pyx_t_18) && PyErr_Occurred())) __PYX_ERR(0, 4769, __pyx_L1_error)
      __pyx_v_type_string = std::string(__pyx_t_18);

      /* "libopenzwave.pyx":4770
 *             elif datatype == "List":
 *                 type_string = string(value)
 *                 cret = self.manager.AddSceneValueListSelection(sceneid, values_map.at(id), type_string)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *         return ret
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4770, __pyx_L1_error)
      try {
        __pyx_t_21 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4770, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->AddSceneValueListSelection(__pyx_v_sceneid, __pyx_t_21, __pyx_v_type_string);

      /* "libopenzwave.pyx":4771
 *                 type_string = string(value)
 *                 cret = self.manager.AddSceneValueListSelection(sceneid, values_map.at(id), type_string)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4768
 *                 cret = self.manager.AddSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 *             elif datatype == "List":             # <<<<<<<<<<<<<<
 *                 type_string = string(value)
 *                 cret = self.manager.AddSceneValueListSelection(sceneid, values_map.at(id), type_string)
 */
    }
    __pyx_L4:;

    /* "libopenzwave.pyx":4738
 *         cdef string type_string
 *         ret = 2
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":
 */
  }

  /* "libopenzwave.pyx":4772
 *                 cret = self.manager.AddSceneValueListSelection(sceneid, values_map.at(id), type_string)
 *                 ret = 1 if cret else 0
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def removeSceneValue(self, uint8_t sceneid, id):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_6 = __Pyx_PyInt_From_long(__pyx_v_ret); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4772, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_r = __pyx_t_6;
  __pyx_t_6 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4707
 * 
 * 
 *     def addSceneValue(self, uint8_t sceneid, id, value):             # <<<<<<<<<<<<<<
 *         '''
 * .. _addSceneValue:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("libopenzwave.PyManager.addSceneValue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_datatype);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4774
 *         return ret
 * 
 *     def removeSceneValue(self, uint8_t sceneid, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeSceneValue:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_319removeSceneValue(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_318removeSceneValue[] = "\n.. _removeSceneValue:\n\nRemove the Value ID from an existing scene.\n\n:param sceneid: The ID of a scene.\n:type sceneid: int\n:param id: The ID of a value.\n:type id: int\n:return: True if succee. False otherwise\n:rtype: bool\n:see: getNumScenes_, getAllScenes_, sceneExists_, removeAllScenes_, createScene_, removeScene_, activateScene_, getSceneLabel_, setSceneLabel_, removeSceneValue_, setSceneValue_, sceneGetValues_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_319removeSceneValue(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  uint8_t __pyx_v_sceneid;
  PyObject *__pyx_v_id = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("removeSceneValue (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_sceneid,&__pyx_n_s_id,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_sceneid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("removeSceneValue", 1, 2, 2, 1); __PYX_ERR(0, 4774, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "removeSceneValue") < 0)) __PYX_ERR(0, 4774, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_sceneid = __Pyx_PyInt_As_uint8_t(values[0]); if (unlikely((__pyx_v_sceneid == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4774, __pyx_L3_error)
    __pyx_v_id = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("removeSceneValue", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4774, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.removeSceneValue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_318removeSceneValue(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_sceneid, __pyx_v_id);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_318removeSceneValue(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, uint8_t __pyx_v_sceneid, PyObject *__pyx_v_id) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("removeSceneValue", 0);

  /* "libopenzwave.pyx":4792
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.RemoveSceneValue(sceneid, values_map.at(id))
 *         return False
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4792, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":4793
 *         '''
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.RemoveSceneValue(sceneid, values_map.at(id))             # <<<<<<<<<<<<<<
 *         return False
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4793, __pyx_L1_error)
    try {
      __pyx_t_3 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 4793, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->RemoveSceneValue(__pyx_v_sceneid, __pyx_t_3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4793, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "libopenzwave.pyx":4792
 * 
 *         '''
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             return self.manager.RemoveSceneValue(sceneid, values_map.at(id))
 *         return False
 */
  }

  /* "libopenzwave.pyx":4794
 *         if values_map.find(id) != values_map.end():
 *             return self.manager.RemoveSceneValue(sceneid, values_map.at(id))
 *         return False             # <<<<<<<<<<<<<<
 * 
 *     def setSceneValue(self, uint8_t sceneid, id, value):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_False);
  __pyx_r = Py_False;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4774
 *         return ret
 * 
 *     def removeSceneValue(self, uint8_t sceneid, id):             # <<<<<<<<<<<<<<
 *         '''
 * .. _removeSceneValue:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("libopenzwave.PyManager.removeSceneValue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4796
 *         return False
 * 
 *     def setSceneValue(self, uint8_t sceneid, id, value):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setSceneValue:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_321setSceneValue(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_320setSceneValue[] = "\n.. _setSceneValue:\n\nSet a value to an existing scene's ValueID.\n\n:param sceneid: The ID of a scene.\n:type sceneid: int\n:param id: The ID of a value.\n:type id: int\n:param value: The value to set\n:type value: bool, int, float, string\n:return: An integer representing the result of the operation\n    0 : The C method fails\n    1 : The C method succeed\n    2 : Can't find id in the map\n:rtype: int\n:see: getNumScenes_, getAllScenes_, sceneExists_, removeAllScenes_, createScene_, removeScene_, activateScene_, getSceneLabel_, setSceneLabel_, removeSceneValue_, addSceneValue_, sceneGetValues_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_321setSceneValue(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  uint8_t __pyx_v_sceneid;
  PyObject *__pyx_v_id = 0;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setSceneValue (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_sceneid,&__pyx_n_s_id,&__pyx_n_s_value,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_sceneid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setSceneValue", 1, 3, 3, 1); __PYX_ERR(0, 4796, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setSceneValue", 1, 3, 3, 2); __PYX_ERR(0, 4796, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setSceneValue") < 0)) __PYX_ERR(0, 4796, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_sceneid = __Pyx_PyInt_As_uint8_t(values[0]); if (unlikely((__pyx_v_sceneid == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4796, __pyx_L3_error)
    __pyx_v_id = values[1];
    __pyx_v_value = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setSceneValue", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4796, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setSceneValue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_320setSceneValue(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_sceneid, __pyx_v_id, __pyx_v_value);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_320setSceneValue(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, uint8_t __pyx_v_sceneid, PyObject *__pyx_v_id, PyObject *__pyx_v_value) {
  float __pyx_v_type_float;
  bool __pyx_v_type_bool;
  uint8_t __pyx_v_type_byte;
  int32_t __pyx_v_type_int;
  int16_t __pyx_v_type_short;
  std::string __pyx_v_type_string;
  long __pyx_v_ret;
  PyObject *__pyx_v_datatype = NULL;
  bool __pyx_v_cret;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint64_t __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  bool __pyx_t_7;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_8;
  long __pyx_t_9;
  uint8_t __pyx_t_10;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_11;
  float __pyx_t_12;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_13;
  int32_t __pyx_t_14;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_15;
  int16_t __pyx_t_16;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_17;
  char *__pyx_t_18;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_19;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_20;
  __Pyx_FakeReference<OpenZWave::ValueID> __pyx_t_21;
  __Pyx_RefNannySetupContext("setSceneValue", 0);

  /* "libopenzwave.pyx":4825
 *         cdef int16_t type_short
 *         cdef string type_string
 *         ret = 2             # <<<<<<<<<<<<<<
 *         if values_map.find(id) != values_map.end():
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 */
  __pyx_v_ret = 2;

  /* "libopenzwave.pyx":4826
 *         cdef string type_string
 *         ret = 2
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4826, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_v_12libopenzwave_values_map.find(__pyx_t_1) != __pyx_v_12libopenzwave_values_map.end()) != 0);
  if (__pyx_t_2) {

    /* "libopenzwave.pyx":4827
 *         ret = 2
 *         if values_map.find(id) != values_map.end():
 *             datatype = PyValueTypes[values_map.at(id).GetType()]             # <<<<<<<<<<<<<<
 *             if datatype == "Bool":
 *                 type_bool = value
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_PyValueTypes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4827, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4827, __pyx_L1_error)
    try {
      __pyx_t_4 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 4827, __pyx_L1_error)
    }
    __pyx_t_5 = __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueType(__pyx_t_4->GetType()); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4827, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = PyObject_GetItem(__pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4827, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_v_datatype = __pyx_t_6;
    __pyx_t_6 = 0;

    /* "libopenzwave.pyx":4828
 *         if values_map.find(id) != values_map.end():
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":             # <<<<<<<<<<<<<<
 *                 type_bool = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Bool, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4828, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4829
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":
 *                 type_bool = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_7 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4829, __pyx_L1_error)
      __pyx_v_type_bool = __pyx_t_7;

      /* "libopenzwave.pyx":4830
 *             if datatype == "Bool":
 *                 type_bool = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Byte":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4830, __pyx_L1_error)
      try {
        __pyx_t_8 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4830, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetSceneValue(__pyx_v_sceneid, __pyx_t_8, __pyx_v_type_bool);

      /* "libopenzwave.pyx":4831
 *                 type_bool = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Byte":
 *                 type_byte = value
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4828
 *         if values_map.find(id) != values_map.end():
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":             # <<<<<<<<<<<<<<
 *                 type_bool = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":4832
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Byte":             # <<<<<<<<<<<<<<
 *                 type_byte = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_byte)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Byte, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4832, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4833
 *                 ret = 1 if cret else 0
 *             elif datatype == "Byte":
 *                 type_byte = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_byte)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_10 = __Pyx_PyInt_As_uint8_t(__pyx_v_value); if (unlikely((__pyx_t_10 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4833, __pyx_L1_error)
      __pyx_v_type_byte = __pyx_t_10;

      /* "libopenzwave.pyx":4834
 *             elif datatype == "Byte":
 *                 type_byte = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_byte)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Decimal":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4834, __pyx_L1_error)
      try {
        __pyx_t_11 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4834, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetSceneValue(__pyx_v_sceneid, __pyx_t_11, __pyx_v_type_byte);

      /* "libopenzwave.pyx":4835
 *                 type_byte = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_byte)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Decimal":
 *                 type_float = value
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4832
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Byte":             # <<<<<<<<<<<<<<
 *                 type_byte = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_byte)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":4836
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_byte)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Decimal":             # <<<<<<<<<<<<<<
 *                 type_float = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_float)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Decimal, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4836, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4837
 *                 ret = 1 if cret else 0
 *             elif datatype == "Decimal":
 *                 type_float = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_float)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_12 = __pyx_PyFloat_AsFloat(__pyx_v_value); if (unlikely((__pyx_t_12 == (float)-1) && PyErr_Occurred())) __PYX_ERR(0, 4837, __pyx_L1_error)
      __pyx_v_type_float = __pyx_t_12;

      /* "libopenzwave.pyx":4838
 *             elif datatype == "Decimal":
 *                 type_float = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_float)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Int":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4838, __pyx_L1_error)
      try {
        __pyx_t_13 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4838, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetSceneValue(__pyx_v_sceneid, __pyx_t_13, __pyx_v_type_float);

      /* "libopenzwave.pyx":4839
 *                 type_float = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_float)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Int":
 *                 type_int = value
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4836
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_byte)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Decimal":             # <<<<<<<<<<<<<<
 *                 type_float = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_float)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":4840
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_float)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Int":             # <<<<<<<<<<<<<<
 *                 type_int = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_int)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Int, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4840, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4841
 *                 ret = 1 if cret else 0
 *             elif datatype == "Int":
 *                 type_int = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_int)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_14 = __Pyx_PyInt_As_int32_t(__pyx_v_value); if (unlikely((__pyx_t_14 == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4841, __pyx_L1_error)
      __pyx_v_type_int = __pyx_t_14;

      /* "libopenzwave.pyx":4842
 *             elif datatype == "Int":
 *                 type_int = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_int)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Short":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4842, __pyx_L1_error)
      try {
        __pyx_t_15 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4842, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetSceneValue(__pyx_v_sceneid, __pyx_t_15, __pyx_v_type_int);

      /* "libopenzwave.pyx":4843
 *                 type_int = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_int)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Short":
 *                 type_short = value
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4840
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_float)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Int":             # <<<<<<<<<<<<<<
 *                 type_int = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_int)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":4844
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_int)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Short":             # <<<<<<<<<<<<<<
 *                 type_short = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_short)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Short, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4844, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4845
 *                 ret = 1 if cret else 0
 *             elif datatype == "Short":
 *                 type_short = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_short)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_16 = __Pyx_PyInt_As_int16_t(__pyx_v_value); if (unlikely((__pyx_t_16 == ((int16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4845, __pyx_L1_error)
      __pyx_v_type_short = __pyx_t_16;

      /* "libopenzwave.pyx":4846
 *             elif datatype == "Short":
 *                 type_short = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_short)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "String":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4846, __pyx_L1_error)
      try {
        __pyx_t_17 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4846, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetSceneValue(__pyx_v_sceneid, __pyx_t_17, __pyx_v_type_short);

      /* "libopenzwave.pyx":4847
 *                 type_short = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_short)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "String":
 *                 type_string = string(value)
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4844
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_int)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Short":             # <<<<<<<<<<<<<<
 *                 type_short = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_short)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":4848
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_short)
 *                 ret = 1 if cret else 0
 *             elif datatype == "String":             # <<<<<<<<<<<<<<
 *                 type_string = string(value)
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_string)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_String, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4848, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4849
 *                 ret = 1 if cret else 0
 *             elif datatype == "String":
 *                 type_string = string(value)             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_string)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_18 = __Pyx_PyObject_AsString(__pyx_v_value); if (unlikely((!__pyx_t_18) && PyErr_Occurred())) __PYX_ERR(0, 4849, __pyx_L1_error)
      __pyx_v_type_string = std::string(__pyx_t_18);

      /* "libopenzwave.pyx":4850
 *             elif datatype == "String":
 *                 type_string = string(value)
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_string)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "Button":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4850, __pyx_L1_error)
      try {
        __pyx_t_19 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4850, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetSceneValue(__pyx_v_sceneid, __pyx_t_19, __pyx_v_type_string);

      /* "libopenzwave.pyx":4851
 *                 type_string = string(value)
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_string)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "Button":
 *                 type_bool = value
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4848
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_short)
 *                 ret = 1 if cret else 0
 *             elif datatype == "String":             # <<<<<<<<<<<<<<
 *                 type_string = string(value)
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_string)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":4852
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_string)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Button":             # <<<<<<<<<<<<<<
 *                 type_bool = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_Button, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4852, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4853
 *                 ret = 1 if cret else 0
 *             elif datatype == "Button":
 *                 type_bool = value             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_7 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4853, __pyx_L1_error)
      __pyx_v_type_bool = __pyx_t_7;

      /* "libopenzwave.pyx":4854
 *             elif datatype == "Button":
 *                 type_bool = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *             elif datatype == "List":
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4854, __pyx_L1_error)
      try {
        __pyx_t_20 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4854, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetSceneValue(__pyx_v_sceneid, __pyx_t_20, __pyx_v_type_bool);

      /* "libopenzwave.pyx":4855
 *                 type_bool = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *             elif datatype == "List":
 *                 type_string = string(value)
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4852
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_string)
 *                 ret = 1 if cret else 0
 *             elif datatype == "Button":             # <<<<<<<<<<<<<<
 *                 type_bool = value
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)
 */
      goto __pyx_L4;
    }

    /* "libopenzwave.pyx":4856
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 *             elif datatype == "List":             # <<<<<<<<<<<<<<
 *                 type_string = string(value)
 *                 cret = self.manager.SetSceneValueListSelection(sceneid, values_map.at(id), type_string)
 */
    __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_datatype, __pyx_n_s_List, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4856, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "libopenzwave.pyx":4857
 *                 ret = 1 if cret else 0
 *             elif datatype == "List":
 *                 type_string = string(value)             # <<<<<<<<<<<<<<
 *                 cret = self.manager.SetSceneValueListSelection(sceneid, values_map.at(id), type_string)
 *                 ret = 1 if cret else 0
 */
      __pyx_t_18 = __Pyx_PyObject_AsString(__pyx_v_value); if (unlikely((!__pyx_t_18) && PyErr_Occurred())) __PYX_ERR(0, 4857, __pyx_L1_error)
      __pyx_v_type_string = std::string(__pyx_t_18);

      /* "libopenzwave.pyx":4858
 *             elif datatype == "List":
 *                 type_string = string(value)
 *                 cret = self.manager.SetSceneValueListSelection(sceneid, values_map.at(id), type_string)             # <<<<<<<<<<<<<<
 *                 ret = 1 if cret else 0
 *         return ret
 */
      __pyx_t_1 = __Pyx_PyInt_As_uint64_t(__pyx_v_id); if (unlikely((__pyx_t_1 == ((uint64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4858, __pyx_L1_error)
      try {
        __pyx_t_21 = __pyx_v_12libopenzwave_values_map.at(__pyx_t_1);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        __PYX_ERR(0, 4858, __pyx_L1_error)
      }
      __pyx_v_cret = __pyx_v_self->manager->SetSceneValueListSelection(__pyx_v_sceneid, __pyx_t_21, __pyx_v_type_string);

      /* "libopenzwave.pyx":4859
 *                 type_string = string(value)
 *                 cret = self.manager.SetSceneValueListSelection(sceneid, values_map.at(id), type_string)
 *                 ret = 1 if cret else 0             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
      if ((__pyx_v_cret != 0)) {
        __pyx_t_9 = 1;
      } else {
        __pyx_t_9 = 0;
      }
      __pyx_v_ret = __pyx_t_9;

      /* "libopenzwave.pyx":4856
 *                 cret = self.manager.SetSceneValue(sceneid, values_map.at(id), type_bool)
 *                 ret = 1 if cret else 0
 *             elif datatype == "List":             # <<<<<<<<<<<<<<
 *                 type_string = string(value)
 *                 cret = self.manager.SetSceneValueListSelection(sceneid, values_map.at(id), type_string)
 */
    }
    __pyx_L4:;

    /* "libopenzwave.pyx":4826
 *         cdef string type_string
 *         ret = 2
 *         if values_map.find(id) != values_map.end():             # <<<<<<<<<<<<<<
 *             datatype = PyValueTypes[values_map.at(id).GetType()]
 *             if datatype == "Bool":
 */
  }

  /* "libopenzwave.pyx":4860
 *                 cret = self.manager.SetSceneValueListSelection(sceneid, values_map.at(id), type_string)
 *                 ret = 1 if cret else 0
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def getSceneLabel(self, sceneid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_6 = __Pyx_PyInt_From_long(__pyx_v_ret); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4860, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_r = __pyx_t_6;
  __pyx_t_6 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4796
 *         return False
 * 
 *     def setSceneValue(self, uint8_t sceneid, id, value):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setSceneValue:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("libopenzwave.PyManager.setSceneValue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_datatype);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4862
 *         return ret
 * 
 *     def getSceneLabel(self, sceneid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getSceneLabel:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_323getSceneLabel(PyObject *__pyx_v_self, PyObject *__pyx_v_sceneid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_322getSceneLabel[] = "\n.. _getSceneLabel:\n\nReturns a label for the particular scene.\n\n:param sceneId: The ID of a scene.\n:type sceneId: int\n:param value: The value to set\n:type value: int\n:return: The label string.\n:rtype: str\n:see: getNumScenes_, getAllScenes_, sceneExists_, removeAllScenes_, createScene_, removeScene_, activateScene_, setSceneLabel_, removeSceneValue_, addSceneValue_, setSceneValue_, sceneGetValues_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_323getSceneLabel(PyObject *__pyx_v_self, PyObject *__pyx_v_sceneid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getSceneLabel (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_322getSceneLabel(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_sceneid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_322getSceneLabel(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_sceneid) {
  std::string __pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint8_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("getSceneLabel", 0);

  /* "libopenzwave.pyx":4880
 * 
 *         '''
 *         cdef string c_string = self.manager.GetSceneLabel(sceneid)             # <<<<<<<<<<<<<<
 *         return cstr_to_str(c_string.c_str())
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint8_t(__pyx_v_sceneid); if (unlikely((__pyx_t_1 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4880, __pyx_L1_error)
  __pyx_v_c_string = __pyx_v_self->manager->GetSceneLabel(__pyx_t_1);

  /* "libopenzwave.pyx":4881
 *         '''
 *         cdef string c_string = self.manager.GetSceneLabel(sceneid)
 *         return cstr_to_str(c_string.c_str())             # <<<<<<<<<<<<<<
 * 
 *     def setSceneLabel(self, sceneid, str label):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyUnicode_FromString(__pyx_v_c_string.c_str()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4881, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __pyx_f_12libopenzwave_cstr_to_str(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4881, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4862
 *         return ret
 * 
 *     def getSceneLabel(self, sceneid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _getSceneLabel:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("libopenzwave.PyManager.getSceneLabel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4883
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def setSceneLabel(self, sceneid, str label):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setSceneLabel:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_325setSceneLabel(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_324setSceneLabel[] = "\n.. _setSceneLabel:\n\nSets a label for the particular scene.\n\n:param sceneId: The ID of the scene.\n:type sceneId: int\n:param value: The new value of the label.\n:type value: int\n:see: getNumScenes_, getAllScenes_, sceneExists_, removeAllScenes_, createScene_, removeScene_, activateScene_, getSceneLabel_, removeSceneValue_, addSceneValue_, setSceneValue_, sceneGetValues_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_325setSceneLabel(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_sceneid = 0;
  PyObject *__pyx_v_label = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setSceneLabel (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_sceneid,&__pyx_n_s_label,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_sceneid)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_label)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setSceneLabel", 1, 2, 2, 1); __PYX_ERR(0, 4883, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setSceneLabel") < 0)) __PYX_ERR(0, 4883, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_sceneid = values[0];
    __pyx_v_label = ((PyObject*)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setSceneLabel", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4883, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setSceneLabel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_label), (&PyString_Type), 1, "label", 1))) __PYX_ERR(0, 4883, __pyx_L1_error)
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_324setSceneLabel(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), __pyx_v_sceneid, __pyx_v_label);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_324setSceneLabel(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_sceneid, PyObject *__pyx_v_label) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint8_t __pyx_t_1;
  __Pyx_RefNannySetupContext("setSceneLabel", 0);

  /* "libopenzwave.pyx":4899
 * 
 *         '''
 *         self.manager.SetSceneLabel(sceneid, str_to_cppstr(label))             # <<<<<<<<<<<<<<
 * 
 *     def sceneExists(self, sceneid):
 */
  __pyx_t_1 = __Pyx_PyInt_As_uint8_t(__pyx_v_sceneid); if (unlikely((__pyx_t_1 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4899, __pyx_L1_error)
  __pyx_v_self->manager->SetSceneLabel(__pyx_t_1, __pyx_f_12libopenzwave_str_to_cppstr(__pyx_v_label));

  /* "libopenzwave.pyx":4883
 *         return cstr_to_str(c_string.c_str())
 * 
 *     def setSceneLabel(self, sceneid, str label):             # <<<<<<<<<<<<<<
 *         '''
 * .. _setSceneLabel:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("libopenzwave.PyManager.setSceneLabel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4901
 *         self.manager.SetSceneLabel(sceneid, str_to_cppstr(label))
 * 
 *     def sceneExists(self, sceneid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _sceneExists:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_327sceneExists(PyObject *__pyx_v_self, PyObject *__pyx_v_sceneid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_326sceneExists[] = "\n.. _sceneExists:\n\nCheck if a Scene ID is defined.\n\n:param sceneId: The ID of the scene to check.\n:type sceneId: int\n:return: True if Scene ID exists.\n:rtype: bool\n:see: getNumScenes_, getAllScenes_, removeAllScenes_, createScene_, removeScene_, activateScene_, getSceneLabel_, setSceneLabel_, removeSceneValue_, addSceneValue_, setSceneValue_, sceneGetValues_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_327sceneExists(PyObject *__pyx_v_self, PyObject *__pyx_v_sceneid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sceneExists (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_326sceneExists(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_sceneid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_326sceneExists(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_sceneid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint8_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("sceneExists", 0);

  /* "libopenzwave.pyx":4917
 * 
 *         '''
 *         return self.manager.SceneExists(sceneid)             # <<<<<<<<<<<<<<
 * 
 *     def activateScene(self, sceneid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint8_t(__pyx_v_sceneid); if (unlikely((__pyx_t_1 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4917, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->SceneExists(__pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4917, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4901
 *         self.manager.SetSceneLabel(sceneid, str_to_cppstr(label))
 * 
 *     def sceneExists(self, sceneid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _sceneExists:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.sceneExists", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "libopenzwave.pyx":4919
 *         return self.manager.SceneExists(sceneid)
 * 
 *     def activateScene(self, sceneid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _activateScene:
 */

/* Python wrapper */
static PyObject *__pyx_pw_12libopenzwave_9PyManager_329activateScene(PyObject *__pyx_v_self, PyObject *__pyx_v_sceneid); /*proto*/
static char __pyx_doc_12libopenzwave_9PyManager_328activateScene[] = "\n.. _activateScene:\n\nActivate given scene to perform all its actions.\n\n:param sceneId: The ID of the scene to activate.\n:type sceneId: int\n:return: True if it is successful.\n:rtype: bool\n:see: getNumScenes_, getAllScenes_, sceneExists_, removeAllScenes_, createScene_, removeScene_, getSceneLabel_, setSceneLabel_, removeSceneValue_, addSceneValue_, setSceneValue_, sceneGetValues_\n\n        ";
static PyObject *__pyx_pw_12libopenzwave_9PyManager_329activateScene(PyObject *__pyx_v_self, PyObject *__pyx_v_sceneid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("activateScene (wrapper)", 0);
  __pyx_r = __pyx_pf_12libopenzwave_9PyManager_328activateScene(((struct __pyx_obj_12libopenzwave_PyManager *)__pyx_v_self), ((PyObject *)__pyx_v_sceneid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_12libopenzwave_9PyManager_328activateScene(struct __pyx_obj_12libopenzwave_PyManager *__pyx_v_self, PyObject *__pyx_v_sceneid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  uint8_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("activateScene", 0);

  /* "libopenzwave.pyx":4935
 * 
 *         '''
 *         return self.manager.ActivateScene(sceneid)             # <<<<<<<<<<<<<<
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_As_uint8_t(__pyx_v_sceneid); if (unlikely((__pyx_t_1 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4935, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->manager->ActivateScene(__pyx_t_1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4935, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "libopenzwave.pyx":4919
 *         return self.manager.SceneExists(sceneid)
 * 
 *     def activateScene(self, sceneid):             # <<<<<<<<<<<<<<
 *         '''
 * .. _activateScene:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("libopenzwave.PyManager.activateScene", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":31
 * 
 * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyObject_string_to_py_std__in_string", 0);

  /* "string.to_py":32
 * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyUnicode_FromStringAndSize(char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":31
 * 
 * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyObject_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":37
 * 
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyUnicode_string_to_py_std__in_string", 0);

  /* "string.to_py":38
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyStr_FromStringAndSize(char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 38, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":37
 * 
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyUnicode_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":43
 * 
 * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyStr_string_to_py_std__in_string", 0);

  /* "string.to_py":44
 * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyBytes_FromStringAndSize(char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyStr_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 44, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":43
 * 
 * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyStr_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":49
 * 
 * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyBytes_string_to_py_std__in_string", 0);

  /* "string.to_py":50
 * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyByteArray_FromStringAndSize(char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 50, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":49
 * 
 * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyBytes_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":55
 * 
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
 * 
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyByteArray_string_to_py_std__in_string", 0);

  /* "string.to_py":56
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyByteArray_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 56, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":55
 * 
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyByteArray_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_tp_new_12libopenzwave_PyOptions(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_12libopenzwave_PyOptions *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_12libopenzwave_PyOptions *)o);
  p->_config_path = ((PyObject*)Py_None); Py_INCREF(Py_None);
  p->_user_path = ((PyObject*)Py_None); Py_INCREF(Py_None);
  p->_cmd_line = ((PyObject*)Py_None); Py_INCREF(Py_None);
  return o;
}

static void __pyx_tp_dealloc_12libopenzwave_PyOptions(PyObject *o) {
  struct __pyx_obj_12libopenzwave_PyOptions *p = (struct __pyx_obj_12libopenzwave_PyOptions *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  Py_CLEAR(p->_config_path);
  Py_CLEAR(p->_user_path);
  Py_CLEAR(p->_cmd_line);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_12libopenzwave_PyOptions[] = {
  {"create", (PyCFunction)__pyx_pw_12libopenzwave_9PyOptions_3create, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyOptions_2create},
  {"destroy", (PyCFunction)__pyx_pw_12libopenzwave_9PyOptions_5destroy, METH_NOARGS, __pyx_doc_12libopenzwave_9PyOptions_4destroy},
  {"lock", (PyCFunction)__pyx_pw_12libopenzwave_9PyOptions_7lock, METH_NOARGS, __pyx_doc_12libopenzwave_9PyOptions_6lock},
  {"areLocked", (PyCFunction)__pyx_pw_12libopenzwave_9PyOptions_9areLocked, METH_NOARGS, __pyx_doc_12libopenzwave_9PyOptions_8areLocked},
  {"addOptionBool", (PyCFunction)__pyx_pw_12libopenzwave_9PyOptions_11addOptionBool, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyOptions_10addOptionBool},
  {"addOptionInt", (PyCFunction)__pyx_pw_12libopenzwave_9PyOptions_13addOptionInt, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyOptions_12addOptionInt},
  {"addOptionString", (PyCFunction)__pyx_pw_12libopenzwave_9PyOptions_15addOptionString, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyOptions_14addOptionString},
  {"addOption", (PyCFunction)__pyx_pw_12libopenzwave_9PyOptions_17addOption, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyOptions_16addOption},
  {"getOption", (PyCFunction)__pyx_pw_12libopenzwave_9PyOptions_19getOption, METH_O, __pyx_doc_12libopenzwave_9PyOptions_18getOption},
  {"getOptionAsBool", (PyCFunction)__pyx_pw_12libopenzwave_9PyOptions_21getOptionAsBool, METH_O, __pyx_doc_12libopenzwave_9PyOptions_20getOptionAsBool},
  {"getOptionAsInt", (PyCFunction)__pyx_pw_12libopenzwave_9PyOptions_23getOptionAsInt, METH_O, __pyx_doc_12libopenzwave_9PyOptions_22getOptionAsInt},
  {"getOptionAsString", (PyCFunction)__pyx_pw_12libopenzwave_9PyOptions_25getOptionAsString, METH_O, __pyx_doc_12libopenzwave_9PyOptions_24getOptionAsString},
  {"getConfigPath", (PyCFunction)__pyx_pw_12libopenzwave_9PyOptions_27getConfigPath, METH_NOARGS, __pyx_doc_12libopenzwave_9PyOptions_26getConfigPath},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_12libopenzwave_PyOptions = {
  PyVarObject_HEAD_INIT(0, 0)
  "libopenzwave.PyOptions", /*tp_name*/
  sizeof(struct __pyx_obj_12libopenzwave_PyOptions), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_12libopenzwave_PyOptions, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n    Manage options manager\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_12libopenzwave_PyOptions, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_12libopenzwave_9PyOptions_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_12libopenzwave_PyOptions, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_12libopenzwave_RetAlloc(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  if (unlikely(__pyx_pw_12libopenzwave_8RetAlloc_1__cinit__(o, a, k) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_12libopenzwave_RetAlloc(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_12libopenzwave_8RetAlloc_3__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_12libopenzwave_RetAlloc[] = {
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_12libopenzwave_RetAlloc = {
  PyVarObject_HEAD_INIT(0, 0)
  "libopenzwave.RetAlloc", /*tp_name*/
  sizeof(struct __pyx_obj_12libopenzwave_RetAlloc), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_12libopenzwave_RetAlloc, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n    Map an array of uint8_t used when retrieving sets.\n    Allocate memory at init and free it when no more reference to it exist.\n    Give it to lion as Nico0084 says : http://blog.naviso.fr/wordpress/wp-sphinxdoc/uploads/2011/11/MemoryLeaks3.jpg\n\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_12libopenzwave_RetAlloc, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_12libopenzwave_RetAlloc, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_12libopenzwave_InstanceAssociationAlloc(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  if (unlikely(__pyx_pw_12libopenzwave_24InstanceAssociationAlloc_1__cinit__(o, a, k) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_12libopenzwave_InstanceAssociationAlloc(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_12libopenzwave_24InstanceAssociationAlloc_3__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_12libopenzwave_InstanceAssociationAlloc[] = {
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_12libopenzwave_InstanceAssociationAlloc = {
  PyVarObject_HEAD_INIT(0, 0)
  "libopenzwave.InstanceAssociationAlloc", /*tp_name*/
  sizeof(struct __pyx_obj_12libopenzwave_InstanceAssociationAlloc), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_12libopenzwave_InstanceAssociationAlloc, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n    Map an array of InstanceAssociation_t used when retrieving sets of associationInstances.\n    Allocate memory at init and free it when no more reference to it exist.\n    Give it to lion as Nico0084 says : http://blog.naviso.fr/wordpress/wp-sphinxdoc/uploads/2011/11/MemoryLeaks3.jpg\n\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_12libopenzwave_InstanceAssociationAlloc, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_12libopenzwave_InstanceAssociationAlloc, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_12libopenzwave_PyManager(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_12libopenzwave_PyManager *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_12libopenzwave_PyManager *)o);
  p->_watcherCallback = Py_None; Py_INCREF(Py_None);
  p->_controllerCallback = Py_None; Py_INCREF(Py_None);
  return o;
}

static void __pyx_tp_dealloc_12libopenzwave_PyManager(PyObject *o) {
  struct __pyx_obj_12libopenzwave_PyManager *p = (struct __pyx_obj_12libopenzwave_PyManager *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->_watcherCallback);
  Py_CLEAR(p->_controllerCallback);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_12libopenzwave_PyManager(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_12libopenzwave_PyManager *p = (struct __pyx_obj_12libopenzwave_PyManager *)o;
  if (p->_watcherCallback) {
    e = (*v)(p->_watcherCallback, a); if (e) return e;
  }
  if (p->_controllerCallback) {
    e = (*v)(p->_controllerCallback, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_12libopenzwave_PyManager(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_12libopenzwave_PyManager *p = (struct __pyx_obj_12libopenzwave_PyManager *)o;
  tmp = ((PyObject*)p->_watcherCallback);
  p->_watcherCallback = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->_controllerCallback);
  p->_controllerCallback = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_12libopenzwave_PyManager[] = {
  {"create", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_1create, METH_NOARGS, __pyx_doc_12libopenzwave_9PyManager_create},
  {"destroy", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_3destroy, METH_NOARGS, __pyx_doc_12libopenzwave_9PyManager_2destroy},
  {"writeConfig", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_5writeConfig, METH_O, __pyx_doc_12libopenzwave_9PyManager_4writeConfig},
  {"addDriver", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_7addDriver, METH_O, __pyx_doc_12libopenzwave_9PyManager_6addDriver},
  {"removeDriver", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_9removeDriver, METH_O, __pyx_doc_12libopenzwave_9PyManager_8removeDriver},
  {"getControllerInterfaceType", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_11getControllerInterfaceType, METH_O, __pyx_doc_12libopenzwave_9PyManager_10getControllerInterfaceType},
  {"getControllerPath", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_13getControllerPath, METH_O, __pyx_doc_12libopenzwave_9PyManager_12getControllerPath},
  {"getControllerNodeId", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_15getControllerNodeId, METH_O, __pyx_doc_12libopenzwave_9PyManager_14getControllerNodeId},
  {"getSUCNodeId", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_17getSUCNodeId, METH_O, __pyx_doc_12libopenzwave_9PyManager_16getSUCNodeId},
  {"isPrimaryController", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_19isPrimaryController, METH_O, __pyx_doc_12libopenzwave_9PyManager_18isPrimaryController},
  {"isStaticUpdateController", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_21isStaticUpdateController, METH_O, __pyx_doc_12libopenzwave_9PyManager_20isStaticUpdateController},
  {"isBridgeController", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_23isBridgeController, METH_O, __pyx_doc_12libopenzwave_9PyManager_22isBridgeController},
  {"getLibraryVersion", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_25getLibraryVersion, METH_O, __pyx_doc_12libopenzwave_9PyManager_24getLibraryVersion},
  {"getPythonLibraryVersion", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_27getPythonLibraryVersion, METH_NOARGS, __pyx_doc_12libopenzwave_9PyManager_26getPythonLibraryVersion},
  {"getPythonLibraryVersionNumber", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_29getPythonLibraryVersionNumber, METH_NOARGS, __pyx_doc_12libopenzwave_9PyManager_28getPythonLibraryVersionNumber},
  {"getOzwLibraryVersion", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_31getOzwLibraryVersion, METH_NOARGS, __pyx_doc_12libopenzwave_9PyManager_30getOzwLibraryVersion},
  {"getOzwLibraryLongVersion", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_33getOzwLibraryLongVersion, METH_NOARGS, __pyx_doc_12libopenzwave_9PyManager_32getOzwLibraryLongVersion},
  {"getOzwLibraryVersionNumber", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_35getOzwLibraryVersionNumber, METH_NOARGS, __pyx_doc_12libopenzwave_9PyManager_34getOzwLibraryVersionNumber},
  {"getLibraryTypeName", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_37getLibraryTypeName, METH_O, __pyx_doc_12libopenzwave_9PyManager_36getLibraryTypeName},
  {"getSendQueueCount", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_39getSendQueueCount, METH_O, __pyx_doc_12libopenzwave_9PyManager_38getSendQueueCount},
  {"logDriverStatistics", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_41logDriverStatistics, METH_O, __pyx_doc_12libopenzwave_9PyManager_40logDriverStatistics},
  {"getDriverStatistics", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_43getDriverStatistics, METH_O, __pyx_doc_12libopenzwave_9PyManager_42getDriverStatistics},
  {"testNetworkNode", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_45testNetworkNode, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_44testNetworkNode},
  {"testNetwork", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_47testNetwork, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_46testNetwork},
  {"healNetworkNode", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_49healNetworkNode, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_48healNetworkNode},
  {"healNetwork", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_51healNetwork, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_50healNetwork},
  {"getPollInterval", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_53getPollInterval, METH_NOARGS, __pyx_doc_12libopenzwave_9PyManager_52getPollInterval},
  {"setPollInterval", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_55setPollInterval, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_54setPollInterval},
  {"enablePoll", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_57enablePoll, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_56enablePoll},
  {"disablePoll", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_59disablePoll, METH_O, __pyx_doc_12libopenzwave_9PyManager_58disablePoll},
  {"isPolled", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_61isPolled, METH_O, __pyx_doc_12libopenzwave_9PyManager_60isPolled},
  {"getPollIntensity", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_63getPollIntensity, METH_O, __pyx_doc_12libopenzwave_9PyManager_62getPollIntensity},
  {"setPollIntensity", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_65setPollIntensity, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_64setPollIntensity},
  {"getNodeStatistics", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_67getNodeStatistics, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_66getNodeStatistics},
  {"requestNodeDynamic", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_69requestNodeDynamic, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_68requestNodeDynamic},
  {"refreshNodeInfo", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_71refreshNodeInfo, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_70refreshNodeInfo},
  {"requestNodeState", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_73requestNodeState, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_72requestNodeState},
  {"isNodeBeamingDevice", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_75isNodeBeamingDevice, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_74isNodeBeamingDevice},
  {"isNodeListeningDevice", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_77isNodeListeningDevice, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_76isNodeListeningDevice},
  {"isNodeFrequentListeningDevice", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_79isNodeFrequentListeningDevice, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_78isNodeFrequentListeningDevice},
  {"isNodeSecurityDevice", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_81isNodeSecurityDevice, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_80isNodeSecurityDevice},
  {"isNodeRoutingDevice", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_83isNodeRoutingDevice, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_82isNodeRoutingDevice},
  {"getNodeMaxBaudRate", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_85getNodeMaxBaudRate, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_84getNodeMaxBaudRate},
  {"getNodeVersion", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_87getNodeVersion, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_86getNodeVersion},
  {"getNodeSecurity", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_89getNodeSecurity, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_88getNodeSecurity},
  {"getNodeBasic", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_91getNodeBasic, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_90getNodeBasic},
  {"getNodeGeneric", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_93getNodeGeneric, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_92getNodeGeneric},
  {"getNodeSpecific", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_95getNodeSpecific, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_94getNodeSpecific},
  {"getNodeType", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_97getNodeType, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_96getNodeType},
  {"getNodeNeighbors", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_99getNodeNeighbors, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_98getNodeNeighbors},
  {"getNodeManufacturerName", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_101getNodeManufacturerName, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_100getNodeManufacturerName},
  {"getNodeProductName", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_103getNodeProductName, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_102getNodeProductName},
  {"getNodeName", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_105getNodeName, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_104getNodeName},
  {"getNodeLocation", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_107getNodeLocation, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_106getNodeLocation},
  {"getNodeManufacturerId", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_109getNodeManufacturerId, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_108getNodeManufacturerId},
  {"getNodeProductType", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_111getNodeProductType, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_110getNodeProductType},
  {"getNodeProductId", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_113getNodeProductId, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_112getNodeProductId},
  {"setNodeManufacturerName", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_115setNodeManufacturerName, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_114setNodeManufacturerName},
  {"setNodeProductName", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_117setNodeProductName, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_116setNodeProductName},
  {"setNodeName", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_119setNodeName, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_118setNodeName},
  {"setNodeLocation", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_121setNodeLocation, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_120setNodeLocation},
  {"setNodeOn", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_123setNodeOn, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_122setNodeOn},
  {"setNodeOff", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_125setNodeOff, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_124setNodeOff},
  {"setNodeLevel", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_127setNodeLevel, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_126setNodeLevel},
  {"isNodeInfoReceived", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_129isNodeInfoReceived, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_128isNodeInfoReceived},
  {"getNodeRole", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_131getNodeRole, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_130getNodeRole},
  {"getNodeRoleString", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_133getNodeRoleString, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_132getNodeRoleString},
  {"getNodeDeviceType", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_135getNodeDeviceType, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_134getNodeDeviceType},
  {"getNodeDeviceTypeString", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_137getNodeDeviceTypeString, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_136getNodeDeviceTypeString},
  {"getNodePlusType", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_139getNodePlusType, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_138getNodePlusType},
  {"getNodePlusTypeString", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_141getNodePlusTypeString, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_140getNodePlusTypeString},
  {"getNodeClassInformation", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_143getNodeClassInformation, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_142getNodeClassInformation},
  {"isNodeAwake", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_145isNodeAwake, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_144isNodeAwake},
  {"isNodeFailed", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_147isNodeFailed, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_146isNodeFailed},
  {"isNodeZWavePlus", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_149isNodeZWavePlus, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_148isNodeZWavePlus},
  {"getNodeQueryStage", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_151getNodeQueryStage, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_150getNodeQueryStage},
  {"getNodeQueryStageCode", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_153getNodeQueryStageCode, METH_O, __pyx_doc_12libopenzwave_9PyManager_152getNodeQueryStageCode},
  {"setValue", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_155setValue, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_154setValue},
  {"refreshValue", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_157refreshValue, METH_O, __pyx_doc_12libopenzwave_9PyManager_156refreshValue},
  {"getValueLabel", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_159getValueLabel, METH_O, __pyx_doc_12libopenzwave_9PyManager_158getValueLabel},
  {"setValueLabel", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_161setValueLabel, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_160setValueLabel},
  {"getValueUnits", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_163getValueUnits, METH_O, __pyx_doc_12libopenzwave_9PyManager_162getValueUnits},
  {"setValueUnits", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_165setValueUnits, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_164setValueUnits},
  {"getValueHelp", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_167getValueHelp, METH_O, __pyx_doc_12libopenzwave_9PyManager_166getValueHelp},
  {"setValueHelp", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_169setValueHelp, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_168setValueHelp},
  {"getValueMin", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_171getValueMin, METH_O, __pyx_doc_12libopenzwave_9PyManager_170getValueMin},
  {"getValueMax", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_173getValueMax, METH_O, __pyx_doc_12libopenzwave_9PyManager_172getValueMax},
  {"isValueReadOnly", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_175isValueReadOnly, METH_O, __pyx_doc_12libopenzwave_9PyManager_174isValueReadOnly},
  {"isValueWriteOnly", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_177isValueWriteOnly, METH_O, __pyx_doc_12libopenzwave_9PyManager_176isValueWriteOnly},
  {"isValueSet", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_179isValueSet, METH_O, __pyx_doc_12libopenzwave_9PyManager_178isValueSet},
  {"isValuePolled", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_181isValuePolled, METH_O, __pyx_doc_12libopenzwave_9PyManager_180isValuePolled},
  {"getValueGenre", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_183getValueGenre, METH_O, __pyx_doc_12libopenzwave_9PyManager_182getValueGenre},
  {"getValueCommandClass", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_185getValueCommandClass, METH_O, __pyx_doc_12libopenzwave_9PyManager_184getValueCommandClass},
  {"getValueInstance", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_187getValueInstance, METH_O, __pyx_doc_12libopenzwave_9PyManager_186getValueInstance},
  {"getValueIndex", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_189getValueIndex, METH_O, __pyx_doc_12libopenzwave_9PyManager_188getValueIndex},
  {"getValueType", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_191getValueType, METH_O, __pyx_doc_12libopenzwave_9PyManager_190getValueType},
  {"getValue", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_193getValue, METH_O, __pyx_doc_12libopenzwave_9PyManager_192getValue},
  {"getValueAsBool", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_195getValueAsBool, METH_O, __pyx_doc_12libopenzwave_9PyManager_194getValueAsBool},
  {"getValueAsByte", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_197getValueAsByte, METH_O, __pyx_doc_12libopenzwave_9PyManager_196getValueAsByte},
  {"getValueAsFloat", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_199getValueAsFloat, METH_O, __pyx_doc_12libopenzwave_9PyManager_198getValueAsFloat},
  {"getValueAsShort", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_201getValueAsShort, METH_O, __pyx_doc_12libopenzwave_9PyManager_200getValueAsShort},
  {"getValueAsInt", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_203getValueAsInt, METH_O, __pyx_doc_12libopenzwave_9PyManager_202getValueAsInt},
  {"getValueAsString", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_205getValueAsString, METH_O, __pyx_doc_12libopenzwave_9PyManager_204getValueAsString},
  {"getValueAsRaw", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_207getValueAsRaw, METH_O, __pyx_doc_12libopenzwave_9PyManager_206getValueAsRaw},
  {"getValueListSelectionStr", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_209getValueListSelectionStr, METH_O, __pyx_doc_12libopenzwave_9PyManager_208getValueListSelectionStr},
  {"getValueListSelectionNum", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_211getValueListSelectionNum, METH_O, __pyx_doc_12libopenzwave_9PyManager_210getValueListSelectionNum},
  {"getValueListItems", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_213getValueListItems, METH_O, __pyx_doc_12libopenzwave_9PyManager_212getValueListItems},
  {"getValueListValues", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_215getValueListValues, METH_O, __pyx_doc_12libopenzwave_9PyManager_214getValueListValues},
  {"pressButton", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_217pressButton, METH_O, __pyx_doc_12libopenzwave_9PyManager_216pressButton},
  {"releaseButton", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_219releaseButton, METH_O, __pyx_doc_12libopenzwave_9PyManager_218releaseButton},
  {"getValueFloatPrecision", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_221getValueFloatPrecision, METH_O, __pyx_doc_12libopenzwave_9PyManager_220getValueFloatPrecision},
  {"getChangeVerified", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_223getChangeVerified, METH_O, __pyx_doc_12libopenzwave_9PyManager_222getChangeVerified},
  {"setChangeVerified", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_225setChangeVerified, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_224setChangeVerified},
  {"setSwitchPoint", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_227setSwitchPoint, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_226setSwitchPoint},
  {"removeSwitchPoint", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_229removeSwitchPoint, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_228removeSwitchPoint},
  {"clearSwitchPoints", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_231clearSwitchPoints, METH_O, __pyx_doc_12libopenzwave_9PyManager_230clearSwitchPoints},
  {"getSwitchPoint", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_233getSwitchPoint, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_232getSwitchPoint},
  {"getNumSwitchPoints", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_235getNumSwitchPoints, METH_O, __pyx_doc_12libopenzwave_9PyManager_234getNumSwitchPoints},
  {"switchAllOn", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_237switchAllOn, METH_O, __pyx_doc_12libopenzwave_9PyManager_236switchAllOn},
  {"switchAllOff", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_239switchAllOff, METH_O, __pyx_doc_12libopenzwave_9PyManager_238switchAllOff},
  {"setConfigParam", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_241setConfigParam, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_240setConfigParam},
  {"requestConfigParam", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_243requestConfigParam, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_242requestConfigParam},
  {"requestAllConfigParams", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_245requestAllConfigParams, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_244requestAllConfigParams},
  {"getNumGroups", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_247getNumGroups, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_246getNumGroups},
  {"getAssociations", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_249getAssociations, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_248getAssociations},
  {"getAssociationsInstances", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_251getAssociationsInstances, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_250getAssociationsInstances},
  {"getMaxAssociations", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_253getMaxAssociations, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_252getMaxAssociations},
  {"getGroupLabel", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_255getGroupLabel, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_254getGroupLabel},
  {"addAssociation", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_257addAssociation, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_256addAssociation},
  {"removeAssociation", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_259removeAssociation, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_258removeAssociation},
  {"addWatcher", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_261addWatcher, METH_O, __pyx_doc_12libopenzwave_9PyManager_260addWatcher},
  {"removeWatcher", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_263removeWatcher, METH_O, __pyx_doc_12libopenzwave_9PyManager_262removeWatcher},
  {"resetController", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_265resetController, METH_O, __pyx_doc_12libopenzwave_9PyManager_264resetController},
  {"softResetController", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_267softResetController, METH_O, __pyx_doc_12libopenzwave_9PyManager_266softResetController},
  {"cancelControllerCommand", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_269cancelControllerCommand, METH_O, __pyx_doc_12libopenzwave_9PyManager_268cancelControllerCommand},
  {"beginControllerCommand", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_271beginControllerCommand, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_270beginControllerCommand},
  {"createNewPrimary", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_273createNewPrimary, METH_O, __pyx_doc_12libopenzwave_9PyManager_272createNewPrimary},
  {"transferPrimaryRole", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_275transferPrimaryRole, METH_O, __pyx_doc_12libopenzwave_9PyManager_274transferPrimaryRole},
  {"receiveConfiguration", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_277receiveConfiguration, METH_O, __pyx_doc_12libopenzwave_9PyManager_276receiveConfiguration},
  {"addNode", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_279addNode, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_278addNode},
  {"removeNode", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_281removeNode, METH_O, __pyx_doc_12libopenzwave_9PyManager_280removeNode},
  {"removeFailedNode", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_283removeFailedNode, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_282removeFailedNode},
  {"hasNodeFailed", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_285hasNodeFailed, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_284hasNodeFailed},
  {"requestNodeNeighborUpdate", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_287requestNodeNeighborUpdate, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_286requestNodeNeighborUpdate},
  {"assignReturnRoute", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_289assignReturnRoute, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_288assignReturnRoute},
  {"deleteAllReturnRoutes", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_291deleteAllReturnRoutes, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_290deleteAllReturnRoutes},
  {"sendNodeInformation", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_293sendNodeInformation, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_292sendNodeInformation},
  {"replaceFailedNode", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_295replaceFailedNode, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_294replaceFailedNode},
  {"requestNetworkUpdate", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_297requestNetworkUpdate, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_296requestNetworkUpdate},
  {"replicationSend", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_299replicationSend, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_298replicationSend},
  {"createButton", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_301createButton, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_300createButton},
  {"deleteButton", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_303deleteButton, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_302deleteButton},
  {"getNumScenes", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_305getNumScenes, METH_NOARGS, __pyx_doc_12libopenzwave_9PyManager_304getNumScenes},
  {"getAllScenes", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_307getAllScenes, METH_NOARGS, __pyx_doc_12libopenzwave_9PyManager_306getAllScenes},
  {"removeAllScenes", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_309removeAllScenes, METH_O, __pyx_doc_12libopenzwave_9PyManager_308removeAllScenes},
  {"removeScene", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_311removeScene, METH_O, __pyx_doc_12libopenzwave_9PyManager_310removeScene},
  {"createScene", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_313createScene, METH_NOARGS, __pyx_doc_12libopenzwave_9PyManager_312createScene},
  {"sceneGetValues", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_315sceneGetValues, METH_O, __pyx_doc_12libopenzwave_9PyManager_314sceneGetValues},
  {"addSceneValue", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_317addSceneValue, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_316addSceneValue},
  {"removeSceneValue", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_319removeSceneValue, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_318removeSceneValue},
  {"setSceneValue", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_321setSceneValue, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_320setSceneValue},
  {"getSceneLabel", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_323getSceneLabel, METH_O, __pyx_doc_12libopenzwave_9PyManager_322getSceneLabel},
  {"setSceneLabel", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_325setSceneLabel, METH_VARARGS|METH_KEYWORDS, __pyx_doc_12libopenzwave_9PyManager_324setSceneLabel},
  {"sceneExists", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_327sceneExists, METH_O, __pyx_doc_12libopenzwave_9PyManager_326sceneExists},
  {"activateScene", (PyCFunction)__pyx_pw_12libopenzwave_9PyManager_329activateScene, METH_O, __pyx_doc_12libopenzwave_9PyManager_328activateScene},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_12libopenzwave_PyManager = {
  PyVarObject_HEAD_INIT(0, 0)
  "libopenzwave.PyManager", /*tp_name*/
  sizeof(struct __pyx_obj_12libopenzwave_PyManager), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_12libopenzwave_PyManager, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\nThe main public interface to OpenZWave.\n\nA singleton class providing the main public interface to OpenZWave.  The\nManager class exposes all the functionality required to add Z-Wave support to\nan application.  It handles the sending and receiving of Z-Wave messages as\nwell as the configuration of a Z-Wave network and its devices, freeing the\nlibrary user from the burden of learning the low-level details of the Z-Wave\nprotocol.\n\nAll Z-Wave functionality is accessed via the Manager class.  While this does\nnot make for the most efficient code structure, it does enable the library to\nhandle potentially complex and hard-to-debug issues such as multi-threading and\nobject lifespans behind the scenes. Application development is therefore\nsimplified and less prone to bugs.\n\nThere can be only one instance of the Manager class, and all applications will\nstart by calling Manager::Create static method to create that instance.  From\nthen on, a call to the Manager::Get static method will return the pointer to\nthe Manager object.  On application exit, Manager::Destroy should be called to\nallow OpenZWave to clean up and delete any other objects it has created.\n\nOnce the Manager has been created, a call should be made to Manager::AddWatcher\nto install a notification callback handler.  This handler will receive\nnotifications of Z-Wave network changes and updates to device values, and is an\nessential element of OpenZWave.\n\nNext, a call should be made to Manager::AddDriver for each Z-Wave controller\nattached to the PC.  Each Driver will handle the sending and receiving of\nmessages for all the devices in its controller's Z-Wave network.  The Driver\nwill read any previously saved configuration and then query the Z-Wave\ncontroller for any missing information.  Once that process is complete, a\nDriverReady notification callback will be sent containing the Home ID of the\ncontroller, which is required by most of the other Manager class methods.\n\nAfter the Dri""verReady notification is sent, the Driver will poll each node on\nthe network to update information about each node.  After all \"awake\" nodes\nhave been polled, an \"AllAwakeNodesQueried\" notification is sent.  This is when\na client application can expect all of the node information (both static\ninformation, like the physical device's capabilities, session information (like\n[associations and/or names] and dynamic information (like temperature or on/off\nstate) to be available.  Finally, after all nodes (whether setening or\nsleeping) have been polled, an \"AllNodesQueried\" notification is sent.\n    ", /*tp_doc*/
  __pyx_tp_traverse_12libopenzwave_PyManager, /*tp_traverse*/
  __pyx_tp_clear_12libopenzwave_PyManager, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_12libopenzwave_PyManager, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_12libopenzwave_PyManager, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyMethodDef __pyx_methods[] = {
  {"driverData", (PyCFunction)__pyx_pw_12libopenzwave_1driverData, METH_NOARGS, 0},
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
  #if PY_VERSION_HEX < 0x03020000
    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
  #else
    PyModuleDef_HEAD_INIT,
  #endif
    "libopenzwave",
    __pyx_k_module_libopenzwave_This_file_i, /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_s_0x62_0x4c_0x63, __pyx_k_0x62_0x4c_0x63, sizeof(__pyx_k_0x62_0x4c_0x63), 0, 0, 1, 0},
  {&__pyx_kp_s_16_bit_signed_value, __pyx_k_16_bit_signed_value, sizeof(__pyx_k_16_bit_signed_value), 0, 0, 1, 0},
  {&__pyx_kp_s_30_seconds_can_easily_poll_30_va, __pyx_k_30_seconds_can_easily_poll_30_va, sizeof(__pyx_k_30_seconds_can_easily_poll_30_va), 0, 0, 1, 0},
  {&__pyx_kp_s_32_bit_signed_value, __pyx_k_32_bit_signed_value, sizeof(__pyx_k_32_bit_signed_value), 0, 0, 1, 0},
  {&__pyx_kp_s_8_bit_unsigned_value, __pyx_k_8_bit_unsigned_value, sizeof(__pyx_k_8_bit_unsigned_value), 0, 0, 1, 0},
  {&__pyx_n_s_ACKCnt, __pyx_k_ACKCnt, sizeof(__pyx_k_ACKCnt), 0, 0, 1, 1},
  {&__pyx_n_s_ACKWaiting, __pyx_k_ACKWaiting, sizeof(__pyx_k_ACKWaiting), 0, 0, 1, 1},
  {&__pyx_kp_s_A_driver_for_a_PC_Z_Wave_control, __pyx_k_A_driver_for_a_PC_Z_Wave_control, sizeof(__pyx_k_A_driver_for_a_PC_Z_Wave_control), 0, 0, 1, 0},
  {&__pyx_kp_s_A_likely_fatal_issue_in_the_libr, __pyx_k_A_likely_fatal_issue_in_the_libr, sizeof(__pyx_k_A_likely_fatal_issue_in_the_libr), 0, 0, 1, 0},
  {&__pyx_kp_s_A_manager_notification_report, __pyx_k_A_manager_notification_report, sizeof(__pyx_k_A_manager_notification_report), 0, 0, 1, 0},
  {&__pyx_kp_s_A_minor_issue_from_which_the_lib, __pyx_k_A_minor_issue_from_which_the_lib, sizeof(__pyx_k_A_minor_issue_from_which_the_lib), 0, 0, 1, 0},
  {&__pyx_kp_s_A_new_node_has_been_added_to_Ope, __pyx_k_A_new_node_has_been_added_to_Ope, sizeof(__pyx_k_A_new_node_has_been_added_to_Ope), 0, 0, 1, 0},
  {&__pyx_kp_s_A_new_node_has_been_found_not_al, __pyx_k_A_new_node_has_been_found_not_al, sizeof(__pyx_k_A_new_node_has_been_found_not_al), 0, 0, 1, 0},
  {&__pyx_kp_s_A_new_node_value_has_been_added, __pyx_k_A_new_node_value_has_been_added, sizeof(__pyx_k_A_new_node_value_has_been_added), 0, 0, 1, 0},
  {&__pyx_kp_s_A_node_has_been_removed_from_Ope, __pyx_k_A_node_has_been_removed_from_Ope, sizeof(__pyx_k_A_node_has_been_removed_from_Ope), 0, 0, 1, 0},
  {&__pyx_kp_s_A_node_has_been_reset_from_OpenZ, __pyx_k_A_node_has_been_reset_from_OpenZ, sizeof(__pyx_k_A_node_has_been_reset_from_OpenZ), 0, 0, 1, 0},
  {&__pyx_kp_s_A_node_has_triggered_an_event_Th, __pyx_k_A_node_has_triggered_an_event_Th, sizeof(__pyx_k_A_node_has_triggered_an_event_Th), 0, 0, 1, 0},
  {&__pyx_kp_s_A_node_value_has_been_removed_fr, __pyx_k_A_node_value_has_been_removed_fr, sizeof(__pyx_k_A_node_value_has_been_removed_fr), 0, 0, 1, 0},
  {&__pyx_kp_s_A_node_value_has_been_updated_fr, __pyx_k_A_node_value_has_been_updated_fr, sizeof(__pyx_k_A_node_value_has_been_updated_fr), 0, 0, 1, 0},
  {&__pyx_kp_s_A_node_value_has_been_updated_fr_2, __pyx_k_A_node_value_has_been_updated_fr_2, sizeof(__pyx_k_A_node_value_has_been_updated_fr_2), 0, 0, 1, 0},
  {&__pyx_kp_s_A_serious_issue_with_the_library, __pyx_k_A_serious_issue_with_the_library, sizeof(__pyx_k_A_serious_issue_with_the_library), 0, 0, 1, 0},
  {&__pyx_kp_s_A_write_only_value_that_is_the_e, __pyx_k_A_write_only_value_that_is_the_e, sizeof(__pyx_k_A_write_only_value_that_is_the_e), 0, 0, 1, 0},
  {&__pyx_n_s_AddDevice, __pyx_k_AddDevice, sizeof(__pyx_k_AddDevice), 0, 0, 1, 1},
  {&__pyx_kp_s_Add_a_new_controller_to_the_Z_Wa, __pyx_k_Add_a_new_controller_to_the_Z_Wa, sizeof(__pyx_k_Add_a_new_controller_to_the_Z_Wa), 0, 0, 1, 0},
  {&__pyx_kp_s_Add_a_new_device_but_not_a_contr, __pyx_k_Add_a_new_device_but_not_a_contr, sizeof(__pyx_k_Add_a_new_device_but_not_a_contr), 0, 0, 1, 0},
  {&__pyx_n_s_Alert, __pyx_k_Alert, sizeof(__pyx_k_Alert), 0, 0, 1, 1},
  {&__pyx_n_s_Alive, __pyx_k_Alive, sizeof(__pyx_k_Alive), 0, 0, 1, 1},
  {&__pyx_n_s_AllNodesQueried, __pyx_k_AllNodesQueried, sizeof(__pyx_k_AllNodesQueried), 0, 0, 1, 1},
  {&__pyx_n_s_AllNodesQueriedSomeDead, __pyx_k_AllNodesQueriedSomeDead, sizeof(__pyx_k_AllNodesQueriedSomeDead), 0, 0, 1, 1},
  {&__pyx_kp_s_All_awake_nodes_have_been_querie, __pyx_k_All_awake_nodes_have_been_querie, sizeof(__pyx_k_All_awake_nodes_have_been_querie), 0, 0, 1, 0},
  {&__pyx_kp_s_All_nodes_and_values_for_this_dr, __pyx_k_All_nodes_and_values_for_this_dr, sizeof(__pyx_k_All_nodes_and_values_for_this_dr), 0, 0, 1, 0},
  {&__pyx_kp_s_All_nodes_have_been_queried_but, __pyx_k_All_nodes_have_been_queried_but, sizeof(__pyx_k_All_nodes_have_been_queried_but), 0, 0, 1, 0},
  {&__pyx_kp_s_All_nodes_have_been_queried_so_c, __pyx_k_All_nodes_have_been_queried_so_c, sizeof(__pyx_k_All_nodes_have_been_queried_so_c), 0, 0, 1, 0},
  {&__pyx_kp_s_All_the_initialisation_queries_o, __pyx_k_All_the_initialisation_queries_o, sizeof(__pyx_k_All_the_initialisation_queries_o), 0, 0, 1, 0},
  {&__pyx_n_s_Always, __pyx_k_Always, sizeof(__pyx_k_Always), 0, 0, 1, 1},
  {&__pyx_n_s_AppendLogFile, __pyx_k_AppendLogFile, sizeof(__pyx_k_AppendLogFile), 0, 0, 1, 1},
  {&__pyx_kp_s_Append_new_session_logs_to_exist, __pyx_k_Append_new_session_logs_to_exist, sizeof(__pyx_k_Append_new_session_logs_to_exist), 0, 0, 1, 0},
  {&__pyx_n_s_AssignReturnRoute, __pyx_k_AssignReturnRoute, sizeof(__pyx_k_AssignReturnRoute), 0, 0, 1, 1},
  {&__pyx_kp_s_Assign_a_network_return_routes_t, __pyx_k_Assign_a_network_return_routes_t, sizeof(__pyx_k_Assign_a_network_return_routes_t), 0, 0, 1, 0},
  {&__pyx_n_s_Associate, __pyx_k_Associate, sizeof(__pyx_k_Associate), 0, 0, 1, 1},
  {&__pyx_n_s_Associations, __pyx_k_Associations, sizeof(__pyx_k_Associations), 0, 0, 1, 1},
  {&__pyx_n_s_AssumeAwake, __pyx_k_AssumeAwake, sizeof(__pyx_k_AssumeAwake), 0, 0, 1, 1},
  {&__pyx_kp_s_Assume_Devices_that_Support_the, __pyx_k_Assume_Devices_that_Support_the, sizeof(__pyx_k_Assume_Devices_that_Support_the), 0, 0, 1, 0},
  {&__pyx_n_s_AttributeError, __pyx_k_AttributeError, sizeof(__pyx_k_AttributeError), 0, 0, 1, 1},
  {&__pyx_kp_s_Automatically_become_a_SUC_if_th, __pyx_k_Automatically_become_a_SUC_if_th, sizeof(__pyx_k_Automatically_become_a_SUC_if_th), 0, 0, 1, 0},
  {&__pyx_n_s_Awake, __pyx_k_Awake, sizeof(__pyx_k_Awake), 0, 0, 1, 1},
  {&__pyx_n_s_AwakeNodesQueried, __pyx_k_AwakeNodesQueried, sizeof(__pyx_k_AwakeNodesQueried), 0, 0, 1, 1},
  {&__pyx_n_s_Basic, __pyx_k_Basic, sizeof(__pyx_k_Basic), 0, 0, 1, 1},
  {&__pyx_kp_s_Basic_node_information_has_been, __pyx_k_Basic_node_information_has_been, sizeof(__pyx_k_Basic_node_information_has_been), 0, 0, 1, 0},
  {&__pyx_kp_s_Basic_values_an_ordinary_user_wo, __pyx_k_Basic_values_an_ordinary_user_wo, sizeof(__pyx_k_Basic_values_an_ordinary_user_wo), 0, 0, 1, 0},
  {&__pyx_n_s_Bool, __pyx_k_Bool, sizeof(__pyx_k_Bool), 0, 0, 1, 1},
  {&__pyx_kp_s_Boolean, __pyx_k_Boolean, sizeof(__pyx_k_Boolean), 0, 0, 1, 0},
  {&__pyx_kp_s_Boolean_true_or_false, __pyx_k_Boolean_true_or_false, sizeof(__pyx_k_Boolean_true_or_false), 0, 0, 1, 0},
  {&__pyx_n_s_Busy, __pyx_k_Busy, sizeof(__pyx_k_Busy), 0, 0, 1, 1},
  {&__pyx_n_s_Button, __pyx_k_Button, sizeof(__pyx_k_Button), 0, 0, 1, 1},
  {&__pyx_n_s_ButtonNotFound, __pyx_k_ButtonNotFound, sizeof(__pyx_k_ButtonNotFound), 0, 0, 1, 1},
  {&__pyx_n_s_ButtonOff, __pyx_k_ButtonOff, sizeof(__pyx_k_ButtonOff), 0, 0, 1, 1},
  {&__pyx_n_s_ButtonOn, __pyx_k_ButtonOn, sizeof(__pyx_k_ButtonOn), 0, 0, 1, 1},
  {&__pyx_kp_s_Button_2, __pyx_k_Button_2, sizeof(__pyx_k_Button_2), 0, 0, 1, 0},
  {&__pyx_n_s_Byte, __pyx_k_Byte, sizeof(__pyx_k_Byte), 0, 0, 1, 1},
  {&__pyx_n_s_CALLBACK_DESC, __pyx_k_CALLBACK_DESC, sizeof(__pyx_k_CALLBACK_DESC), 0, 0, 1, 1},
  {&__pyx_n_s_CANCnt, __pyx_k_CANCnt, sizeof(__pyx_k_CANCnt), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_ACTUATOR_MULTILEVE, __pyx_k_COMMAND_CLASS_ACTUATOR_MULTILEVE, sizeof(__pyx_k_COMMAND_CLASS_ACTUATOR_MULTILEVE), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_ALARM, __pyx_k_COMMAND_CLASS_ALARM, sizeof(__pyx_k_COMMAND_CLASS_ALARM), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_APPLICATION_STATUS, __pyx_k_COMMAND_CLASS_APPLICATION_STATUS, sizeof(__pyx_k_COMMAND_CLASS_APPLICATION_STATUS), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_ASSOCIATION, __pyx_k_COMMAND_CLASS_ASSOCIATION, sizeof(__pyx_k_COMMAND_CLASS_ASSOCIATION), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_ASSOCIATION_COMMAN, __pyx_k_COMMAND_CLASS_ASSOCIATION_COMMAN, sizeof(__pyx_k_COMMAND_CLASS_ASSOCIATION_COMMAN), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_AV_CONTENT_DIRECTO, __pyx_k_COMMAND_CLASS_AV_CONTENT_DIRECTO, sizeof(__pyx_k_COMMAND_CLASS_AV_CONTENT_DIRECTO), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_AV_CONTENT_SEARCH, __pyx_k_COMMAND_CLASS_AV_CONTENT_SEARCH, sizeof(__pyx_k_COMMAND_CLASS_AV_CONTENT_SEARCH), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_AV_RENDERER_STATUS, __pyx_k_COMMAND_CLASS_AV_RENDERER_STATUS, sizeof(__pyx_k_COMMAND_CLASS_AV_RENDERER_STATUS), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_AV_TAGGING_MD, __pyx_k_COMMAND_CLASS_AV_TAGGING_MD, sizeof(__pyx_k_COMMAND_CLASS_AV_TAGGING_MD), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_BARRIER_OPERATOR, __pyx_k_COMMAND_CLASS_BARRIER_OPERATOR, sizeof(__pyx_k_COMMAND_CLASS_BARRIER_OPERATOR), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_BASIC, __pyx_k_COMMAND_CLASS_BASIC, sizeof(__pyx_k_COMMAND_CLASS_BASIC), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_BASIC_WINDOW_COVER, __pyx_k_COMMAND_CLASS_BASIC_WINDOW_COVER, sizeof(__pyx_k_COMMAND_CLASS_BASIC_WINDOW_COVER), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_BATTERY, __pyx_k_COMMAND_CLASS_BATTERY, sizeof(__pyx_k_COMMAND_CLASS_BATTERY), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_CENTRAL_SCENE, __pyx_k_COMMAND_CLASS_CENTRAL_SCENE, sizeof(__pyx_k_COMMAND_CLASS_CENTRAL_SCENE), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_CHIMNEY_FAN, __pyx_k_COMMAND_CLASS_CHIMNEY_FAN, sizeof(__pyx_k_COMMAND_CLASS_CHIMNEY_FAN), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_CLIMATE_CONTROL_SC, __pyx_k_COMMAND_CLASS_CLIMATE_CONTROL_SC, sizeof(__pyx_k_COMMAND_CLASS_CLIMATE_CONTROL_SC), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_CLOCK, __pyx_k_COMMAND_CLASS_CLOCK, sizeof(__pyx_k_COMMAND_CLASS_CLOCK), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_COLOR, __pyx_k_COMMAND_CLASS_COLOR, sizeof(__pyx_k_COMMAND_CLASS_COLOR), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_COMPOSITE, __pyx_k_COMMAND_CLASS_COMPOSITE, sizeof(__pyx_k_COMMAND_CLASS_COMPOSITE), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_CONFIGURATION, __pyx_k_COMMAND_CLASS_CONFIGURATION, sizeof(__pyx_k_COMMAND_CLASS_CONFIGURATION), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_CONTROLLER_REPLICA, __pyx_k_COMMAND_CLASS_CONTROLLER_REPLICA, sizeof(__pyx_k_COMMAND_CLASS_CONTROLLER_REPLICA), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_CRC_16_ENCAP, __pyx_k_COMMAND_CLASS_CRC_16_ENCAP, sizeof(__pyx_k_COMMAND_CLASS_CRC_16_ENCAP), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_DESC, __pyx_k_COMMAND_CLASS_DESC, sizeof(__pyx_k_COMMAND_CLASS_DESC), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_DEVICE_RESET_LOCAL, __pyx_k_COMMAND_CLASS_DEVICE_RESET_LOCAL, sizeof(__pyx_k_COMMAND_CLASS_DEVICE_RESET_LOCAL), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_DISPLAY, __pyx_k_COMMAND_CLASS_DISPLAY, sizeof(__pyx_k_COMMAND_CLASS_DISPLAY), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_DOOR_LOCK, __pyx_k_COMMAND_CLASS_DOOR_LOCK, sizeof(__pyx_k_COMMAND_CLASS_DOOR_LOCK), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_DOOR_LOCK_LOGGING, __pyx_k_COMMAND_CLASS_DOOR_LOCK_LOGGING, sizeof(__pyx_k_COMMAND_CLASS_DOOR_LOCK_LOGGING), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_ENERGY_PRODUCTION, __pyx_k_COMMAND_CLASS_ENERGY_PRODUCTION, sizeof(__pyx_k_COMMAND_CLASS_ENERGY_PRODUCTION), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_FIRMWARE_UPDATE_MD, __pyx_k_COMMAND_CLASS_FIRMWARE_UPDATE_MD, sizeof(__pyx_k_COMMAND_CLASS_FIRMWARE_UPDATE_MD), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_GARAGE_DOOR, __pyx_k_COMMAND_CLASS_GARAGE_DOOR, sizeof(__pyx_k_COMMAND_CLASS_GARAGE_DOOR), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_GEOGRAPHIC_LOCATIO, __pyx_k_COMMAND_CLASS_GEOGRAPHIC_LOCATIO, sizeof(__pyx_k_COMMAND_CLASS_GEOGRAPHIC_LOCATIO), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_GROUPING_NAME, __pyx_k_COMMAND_CLASS_GROUPING_NAME, sizeof(__pyx_k_COMMAND_CLASS_GROUPING_NAME), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_HAIL, __pyx_k_COMMAND_CLASS_HAIL, sizeof(__pyx_k_COMMAND_CLASS_HAIL), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_INDICATOR, __pyx_k_COMMAND_CLASS_INDICATOR, sizeof(__pyx_k_COMMAND_CLASS_INDICATOR), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_IP_CONFIGURATION, __pyx_k_COMMAND_CLASS_IP_CONFIGURATION, sizeof(__pyx_k_COMMAND_CLASS_IP_CONFIGURATION), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_KICK, __pyx_k_COMMAND_CLASS_KICK, sizeof(__pyx_k_COMMAND_CLASS_KICK), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_LANGUAGE, __pyx_k_COMMAND_CLASS_LANGUAGE, sizeof(__pyx_k_COMMAND_CLASS_LANGUAGE), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_LOCK, __pyx_k_COMMAND_CLASS_LOCK, sizeof(__pyx_k_COMMAND_CLASS_LOCK), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_MANUFACTURER_PROPR, __pyx_k_COMMAND_CLASS_MANUFACTURER_PROPR, sizeof(__pyx_k_COMMAND_CLASS_MANUFACTURER_PROPR), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_MANUFACTURER_SPECI, __pyx_k_COMMAND_CLASS_MANUFACTURER_SPECI, sizeof(__pyx_k_COMMAND_CLASS_MANUFACTURER_SPECI), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_MARK, __pyx_k_COMMAND_CLASS_MARK, sizeof(__pyx_k_COMMAND_CLASS_MARK), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_METER, __pyx_k_COMMAND_CLASS_METER, sizeof(__pyx_k_COMMAND_CLASS_METER), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_METER_PULSE, __pyx_k_COMMAND_CLASS_METER_PULSE, sizeof(__pyx_k_COMMAND_CLASS_METER_PULSE), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_METER_TBL_CONFIG, __pyx_k_COMMAND_CLASS_METER_TBL_CONFIG, sizeof(__pyx_k_COMMAND_CLASS_METER_TBL_CONFIG), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_METER_TBL_MONITOR, __pyx_k_COMMAND_CLASS_METER_TBL_MONITOR, sizeof(__pyx_k_COMMAND_CLASS_METER_TBL_MONITOR), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_METER_TBL_PUSH, __pyx_k_COMMAND_CLASS_METER_TBL_PUSH, sizeof(__pyx_k_COMMAND_CLASS_METER_TBL_PUSH), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_MTP_WINDOW_COVERIN, __pyx_k_COMMAND_CLASS_MTP_WINDOW_COVERIN, sizeof(__pyx_k_COMMAND_CLASS_MTP_WINDOW_COVERIN), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_MULTI_CHANNEL_ASSO, __pyx_k_COMMAND_CLASS_MULTI_CHANNEL_ASSO, sizeof(__pyx_k_COMMAND_CLASS_MULTI_CHANNEL_ASSO), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_MULTI_CMD, __pyx_k_COMMAND_CLASS_MULTI_CMD, sizeof(__pyx_k_COMMAND_CLASS_MULTI_CMD), 0, 0, 1, 1},
  {&__pyx_kp_s_COMMAND_CLASS_MULTI_INSTANCE_CHA, __pyx_k_COMMAND_CLASS_MULTI_INSTANCE_CHA, sizeof(__pyx_k_COMMAND_CLASS_MULTI_INSTANCE_CHA), 0, 0, 1, 0},
  {&__pyx_n_s_COMMAND_CLASS_NETWORK_STAT, __pyx_k_COMMAND_CLASS_NETWORK_STAT, sizeof(__pyx_k_COMMAND_CLASS_NETWORK_STAT), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_NODE_NAMING, __pyx_k_COMMAND_CLASS_NODE_NAMING, sizeof(__pyx_k_COMMAND_CLASS_NODE_NAMING), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_NON_INTEROPERABLE, __pyx_k_COMMAND_CLASS_NON_INTEROPERABLE, sizeof(__pyx_k_COMMAND_CLASS_NON_INTEROPERABLE), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_NO_OPERATION, __pyx_k_COMMAND_CLASS_NO_OPERATION, sizeof(__pyx_k_COMMAND_CLASS_NO_OPERATION), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_POWERLEVEL, __pyx_k_COMMAND_CLASS_POWERLEVEL, sizeof(__pyx_k_COMMAND_CLASS_POWERLEVEL), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_PROPRIETARY, __pyx_k_COMMAND_CLASS_PROPRIETARY, sizeof(__pyx_k_COMMAND_CLASS_PROPRIETARY), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_PROTECTION, __pyx_k_COMMAND_CLASS_PROTECTION, sizeof(__pyx_k_COMMAND_CLASS_PROTECTION), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_REMOTE_ASSOCIATION, __pyx_k_COMMAND_CLASS_REMOTE_ASSOCIATION, sizeof(__pyx_k_COMMAND_CLASS_REMOTE_ASSOCIATION), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_REMOTE_ASSOCIATION_2, __pyx_k_COMMAND_CLASS_REMOTE_ASSOCIATION_2, sizeof(__pyx_k_COMMAND_CLASS_REMOTE_ASSOCIATION_2), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SCENE_ACTIVATION, __pyx_k_COMMAND_CLASS_SCENE_ACTIVATION, sizeof(__pyx_k_COMMAND_CLASS_SCENE_ACTIVATION), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SCENE_ACTUATOR_CON, __pyx_k_COMMAND_CLASS_SCENE_ACTUATOR_CON, sizeof(__pyx_k_COMMAND_CLASS_SCENE_ACTUATOR_CON), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SCENE_CONTROLLER_C, __pyx_k_COMMAND_CLASS_SCENE_CONTROLLER_C, sizeof(__pyx_k_COMMAND_CLASS_SCENE_CONTROLLER_C), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SCHEDULE_ENTRY_LOC, __pyx_k_COMMAND_CLASS_SCHEDULE_ENTRY_LOC, sizeof(__pyx_k_COMMAND_CLASS_SCHEDULE_ENTRY_LOC), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SCREEN_ATTRIBUTES, __pyx_k_COMMAND_CLASS_SCREEN_ATTRIBUTES, sizeof(__pyx_k_COMMAND_CLASS_SCREEN_ATTRIBUTES), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SCREEN_MD, __pyx_k_COMMAND_CLASS_SCREEN_MD, sizeof(__pyx_k_COMMAND_CLASS_SCREEN_MD), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SECURITY, __pyx_k_COMMAND_CLASS_SECURITY, sizeof(__pyx_k_COMMAND_CLASS_SECURITY), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SENSOR_ALARM, __pyx_k_COMMAND_CLASS_SENSOR_ALARM, sizeof(__pyx_k_COMMAND_CLASS_SENSOR_ALARM), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SENSOR_BINARY, __pyx_k_COMMAND_CLASS_SENSOR_BINARY, sizeof(__pyx_k_COMMAND_CLASS_SENSOR_BINARY), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SENSOR_CONFIGURATI, __pyx_k_COMMAND_CLASS_SENSOR_CONFIGURATI, sizeof(__pyx_k_COMMAND_CLASS_SENSOR_CONFIGURATI), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SENSOR_MULTILEVEL, __pyx_k_COMMAND_CLASS_SENSOR_MULTILEVEL, sizeof(__pyx_k_COMMAND_CLASS_SENSOR_MULTILEVEL), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SILENCE_ALARM, __pyx_k_COMMAND_CLASS_SILENCE_ALARM, sizeof(__pyx_k_COMMAND_CLASS_SILENCE_ALARM), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SIMPLE_AV_CONTROL, __pyx_k_COMMAND_CLASS_SIMPLE_AV_CONTROL, sizeof(__pyx_k_COMMAND_CLASS_SIMPLE_AV_CONTROL), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SWITCH_ALL, __pyx_k_COMMAND_CLASS_SWITCH_ALL, sizeof(__pyx_k_COMMAND_CLASS_SWITCH_ALL), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SWITCH_BINARY, __pyx_k_COMMAND_CLASS_SWITCH_BINARY, sizeof(__pyx_k_COMMAND_CLASS_SWITCH_BINARY), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SWITCH_MULTILEVEL, __pyx_k_COMMAND_CLASS_SWITCH_MULTILEVEL, sizeof(__pyx_k_COMMAND_CLASS_SWITCH_MULTILEVEL), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SWITCH_TOGGLE_BINA, __pyx_k_COMMAND_CLASS_SWITCH_TOGGLE_BINA, sizeof(__pyx_k_COMMAND_CLASS_SWITCH_TOGGLE_BINA), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_SWITCH_TOGGLE_MULT, __pyx_k_COMMAND_CLASS_SWITCH_TOGGLE_MULT, sizeof(__pyx_k_COMMAND_CLASS_SWITCH_TOGGLE_MULT), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_THERMOSTAT_FAN_MOD, __pyx_k_COMMAND_CLASS_THERMOSTAT_FAN_MOD, sizeof(__pyx_k_COMMAND_CLASS_THERMOSTAT_FAN_MOD), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_THERMOSTAT_FAN_STA, __pyx_k_COMMAND_CLASS_THERMOSTAT_FAN_STA, sizeof(__pyx_k_COMMAND_CLASS_THERMOSTAT_FAN_STA), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_THERMOSTAT_HEATING, __pyx_k_COMMAND_CLASS_THERMOSTAT_HEATING, sizeof(__pyx_k_COMMAND_CLASS_THERMOSTAT_HEATING), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_THERMOSTAT_MODE, __pyx_k_COMMAND_CLASS_THERMOSTAT_MODE, sizeof(__pyx_k_COMMAND_CLASS_THERMOSTAT_MODE), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_THERMOSTAT_OPERATI, __pyx_k_COMMAND_CLASS_THERMOSTAT_OPERATI, sizeof(__pyx_k_COMMAND_CLASS_THERMOSTAT_OPERATI), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_THERMOSTAT_SETBACK, __pyx_k_COMMAND_CLASS_THERMOSTAT_SETBACK, sizeof(__pyx_k_COMMAND_CLASS_THERMOSTAT_SETBACK), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_THERMOSTAT_SETPOIN, __pyx_k_COMMAND_CLASS_THERMOSTAT_SETPOIN, sizeof(__pyx_k_COMMAND_CLASS_THERMOSTAT_SETPOIN), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_TIME, __pyx_k_COMMAND_CLASS_TIME, sizeof(__pyx_k_COMMAND_CLASS_TIME), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_TIME_PARAMETERS, __pyx_k_COMMAND_CLASS_TIME_PARAMETERS, sizeof(__pyx_k_COMMAND_CLASS_TIME_PARAMETERS), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_USER_CODE, __pyx_k_COMMAND_CLASS_USER_CODE, sizeof(__pyx_k_COMMAND_CLASS_USER_CODE), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_VERSION, __pyx_k_COMMAND_CLASS_VERSION, sizeof(__pyx_k_COMMAND_CLASS_VERSION), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_WAKE_UP, __pyx_k_COMMAND_CLASS_WAKE_UP, sizeof(__pyx_k_COMMAND_CLASS_WAKE_UP), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_ZIP_ADV_CLIENT, __pyx_k_COMMAND_CLASS_ZIP_ADV_CLIENT, sizeof(__pyx_k_COMMAND_CLASS_ZIP_ADV_CLIENT), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_ZIP_ADV_SERVICES, __pyx_k_COMMAND_CLASS_ZIP_ADV_SERVICES, sizeof(__pyx_k_COMMAND_CLASS_ZIP_ADV_SERVICES), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_ZIP_CLIENT, __pyx_k_COMMAND_CLASS_ZIP_CLIENT, sizeof(__pyx_k_COMMAND_CLASS_ZIP_CLIENT), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_ZIP_SERVER, __pyx_k_COMMAND_CLASS_ZIP_SERVER, sizeof(__pyx_k_COMMAND_CLASS_ZIP_SERVER), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_ZIP_SERVICES, __pyx_k_COMMAND_CLASS_ZIP_SERVICES, sizeof(__pyx_k_COMMAND_CLASS_ZIP_SERVICES), 0, 0, 1, 1},
  {&__pyx_n_s_COMMAND_CLASS_ZWAVE_PLUS_INFO, __pyx_k_COMMAND_CLASS_ZWAVE_PLUS_INFO, sizeof(__pyx_k_COMMAND_CLASS_ZWAVE_PLUS_INFO), 0, 0, 1, 1},
  {&__pyx_n_s_CWD_CONFIG_DIRECTORY, __pyx_k_CWD_CONFIG_DIRECTORY, sizeof(__pyx_k_CWD_CONFIG_DIRECTORY), 0, 0, 1, 1},
  {&__pyx_kp_s_Can_t_autoconfigure_path_to_conf, __pyx_k_Can_t_autoconfigure_path_to_conf, sizeof(__pyx_k_Can_t_autoconfigure_path_to_conf), 0, 0, 1, 0},
  {&__pyx_kp_s_Can_t_find_config_directory_s, __pyx_k_Can_t_find_config_directory_s, sizeof(__pyx_k_Can_t_find_config_directory_s), 0, 0, 1, 0},
  {&__pyx_kp_s_Can_t_find_options_xml_in_s, __pyx_k_Can_t_find_options_xml_in_s, sizeof(__pyx_k_Can_t_find_options_xml_in_s), 0, 0, 1, 0},
  {&__pyx_kp_s_Can_t_find_user_directory_s, __pyx_k_Can_t_find_user_directory_s, sizeof(__pyx_k_Can_t_find_user_directory_s), 0, 0, 1, 0},
  {&__pyx_kp_s_Can_t_retrieve_zwcfg_xsd_from_s, __pyx_k_Can_t_retrieve_zwcfg_xsd_from_s, sizeof(__pyx_k_Can_t_retrieve_zwcfg_xsd_from_s), 0, 0, 1, 0},
  {&__pyx_kp_s_Can_t_write_in_user_directory_s, __pyx_k_Can_t_write_in_user_directory_s, sizeof(__pyx_k_Can_t_write_in_user_directory_s), 0, 0, 1, 0},
  {&__pyx_n_s_Cancel, __pyx_k_Cancel, sizeof(__pyx_k_Cancel), 0, 0, 1, 1},
  {&__pyx_kp_s_Check_whether_a_node_is_in_the_c, __pyx_k_Check_whether_a_node_is_in_the_c, sizeof(__pyx_k_Check_whether_a_node_is_in_the_c), 0, 0, 1, 0},
  {&__pyx_kp_s_Command_invocation_had_error_s_a, __pyx_k_Command_invocation_had_error_s_a, sizeof(__pyx_k_Command_invocation_had_error_s_a), 0, 0, 1, 0},
  {&__pyx_n_s_Complete, __pyx_k_Complete, sizeof(__pyx_k_Complete), 0, 0, 1, 1},
  {&__pyx_n_s_Completed, __pyx_k_Completed, sizeof(__pyx_k_Completed), 0, 0, 1, 1},
  {&__pyx_kp_s_Completed_messages, __pyx_k_Completed_messages, sizeof(__pyx_k_Completed_messages), 0, 0, 1, 0},
  {&__pyx_kp_s_Complex_type_used_with_the_Clima, __pyx_k_Complex_type_used_with_the_Clima, sizeof(__pyx_k_Complex_type_used_with_the_Clima), 0, 0, 1, 0},
  {&__pyx_n_s_Config, __pyx_k_Config, sizeof(__pyx_k_Config), 0, 0, 1, 1},
  {&__pyx_n_s_ConfigPath, __pyx_k_ConfigPath, sizeof(__pyx_k_ConfigPath), 0, 0, 1, 1},
  {&__pyx_n_s_Configuration, __pyx_k_Configuration, sizeof(__pyx_k_Configuration), 0, 0, 1, 1},
  {&__pyx_n_s_ConsoleOutput, __pyx_k_ConsoleOutput, sizeof(__pyx_k_ConsoleOutput), 0, 0, 1, 1},
  {&__pyx_n_s_ControllerCommand, __pyx_k_ControllerCommand, sizeof(__pyx_k_ControllerCommand), 0, 0, 1, 1},
  {&__pyx_kp_s_Controller_command_is_on_a_sleep, __pyx_k_Controller_command_is_on_a_sleep, sizeof(__pyx_k_Controller_command_is_on_a_sleep), 0, 0, 1, 0},
  {&__pyx_kp_s_Controller_interface_use_human_i, __pyx_k_Controller_interface_use_human_i, sizeof(__pyx_k_Controller_interface_use_human_i), 0, 0, 1, 0},
  {&__pyx_kp_s_Controller_interface_use_serial, __pyx_k_Controller_interface_use_serial, sizeof(__pyx_k_Controller_interface_use_serial), 0, 0, 1, 0},
  {&__pyx_kp_s_Controller_interface_use_unknown, __pyx_k_Controller_interface_use_unknown, sizeof(__pyx_k_Controller_interface_use_unknown), 0, 0, 1, 0},
  {&__pyx_kp_s_Controller_is_waiting_for_a_user, __pyx_k_Controller_is_waiting_for_a_user, sizeof(__pyx_k_Controller_is_waiting_for_a_user), 0, 0, 1, 0},
  {&__pyx_n_s_CreateButton, __pyx_k_CreateButton, sizeof(__pyx_k_CreateButton), 0, 0, 1, 1},
  {&__pyx_n_s_CreateNewPrimary, __pyx_k_CreateNewPrimary, sizeof(__pyx_k_CreateNewPrimary), 0, 0, 1, 1},
  {&__pyx_kp_s_CreateNewPrimary_2, __pyx_k_CreateNewPrimary_2, sizeof(__pyx_k_CreateNewPrimary_2), 0, 0, 1, 0},
  {&__pyx_kp_s_Create_an_id_that_tracks_handhel, __pyx_k_Create_an_id_that_tracks_handhel, sizeof(__pyx_k_Create_an_id_that_tracks_handhel), 0, 0, 1, 0},
  {&__pyx_n_s_CustomSecuredCC, __pyx_k_CustomSecuredCC, sizeof(__pyx_k_CustomSecuredCC), 0, 0, 1, 1},
  {&__pyx_n_s_Dead, __pyx_k_Dead, sizeof(__pyx_k_Dead), 0, 0, 1, 1},
  {&__pyx_n_s_Debug, __pyx_k_Debug, sizeof(__pyx_k_Debug), 0, 0, 1, 1},
  {&__pyx_n_s_Decimal, __pyx_k_Decimal, sizeof(__pyx_k_Decimal), 0, 0, 1, 1},
  {&__pyx_kp_s_Default_is_to_never_dump_RAM_sto, __pyx_k_Default_is_to_never_dump_RAM_sto, sizeof(__pyx_k_Default_is_to_never_dump_RAM_sto), 0, 0, 1, 0},
  {&__pyx_n_s_DeleteAllReturnRoutes, __pyx_k_DeleteAllReturnRoutes, sizeof(__pyx_k_DeleteAllReturnRoutes), 0, 0, 1, 1},
  {&__pyx_n_s_DeleteButton, __pyx_k_DeleteButton, sizeof(__pyx_k_DeleteButton), 0, 0, 1, 1},
  {&__pyx_kp_s_Delete_all_return_routes_from_a, __pyx_k_Delete_all_return_routes_from_a, sizeof(__pyx_k_Delete_all_return_routes_from_a), 0, 0, 1, 0},
  {&__pyx_kp_s_Delete_id_that_tracks_handheld_b, __pyx_k_Delete_id_that_tracks_handheld_b, sizeof(__pyx_k_Delete_id_that_tracks_handheld_b), 0, 0, 1, 0},
  {&__pyx_n_s_Detail, __pyx_k_Detail, sizeof(__pyx_k_Detail), 0, 0, 1, 1},
  {&__pyx_kp_s_Detailed_information_on_the_prog, __pyx_k_Detailed_information_on_the_prog, sizeof(__pyx_k_Detailed_information_on_the_prog), 0, 0, 1, 0},
  {&__pyx_kp_s_Device_specific_configuration_pa, __pyx_k_Device_specific_configuration_pa, sizeof(__pyx_k_Device_specific_configuration_pa), 0, 0, 1, 0},
  {&__pyx_kp_s_Disable_all_logging, __pyx_k_Disable_all_logging, sizeof(__pyx_k_Disable_all_logging), 0, 0, 1, 0},
  {&__pyx_n_s_Disabled, __pyx_k_Disabled, sizeof(__pyx_k_Disabled), 0, 0, 1, 1},
  {&__pyx_kp_s_Display_log_information_on_conso, __pyx_k_Display_log_information_on_conso, sizeof(__pyx_k_Display_log_information_on_conso), 0, 0, 1, 0},
  {&__pyx_n_s_DistributionNotFound, __pyx_k_DistributionNotFound, sizeof(__pyx_k_DistributionNotFound), 0, 0, 1, 1},
  {&__pyx_n_s_DriverFailed, __pyx_k_DriverFailed, sizeof(__pyx_k_DriverFailed), 0, 0, 1, 1},
  {&__pyx_n_s_DriverMaxAttempts, __pyx_k_DriverMaxAttempts, sizeof(__pyx_k_DriverMaxAttempts), 0, 0, 1, 1},
  {&__pyx_n_s_DriverReady, __pyx_k_DriverReady, sizeof(__pyx_k_DriverReady), 0, 0, 1, 1},
  {&__pyx_n_s_DriverRemoved, __pyx_k_DriverRemoved, sizeof(__pyx_k_DriverRemoved), 0, 0, 1, 1},
  {&__pyx_n_s_DriverReset, __pyx_k_DriverReset, sizeof(__pyx_k_DriverReset), 0, 0, 1, 1},
  {&__pyx_kp_s_Driver_failed_to_load, __pyx_k_Driver_failed_to_load, sizeof(__pyx_k_Driver_failed_to_load), 0, 0, 1, 0},
  {&__pyx_n_s_DumpTriggerLevel, __pyx_k_DumpTriggerLevel, sizeof(__pyx_k_DumpTriggerLevel), 0, 0, 1, 1},
  {&__pyx_n_s_Dynamic, __pyx_k_Dynamic, sizeof(__pyx_k_Dynamic), 0, 0, 1, 1},
  {&__pyx_n_s_EnableSIS, __pyx_k_EnableSIS, sizeof(__pyx_k_EnableSIS), 0, 0, 1, 1},
  {&__pyx_kp_s_Enable_automatic_association_of, __pyx_k_Enable_automatic_association_of, sizeof(__pyx_k_Enable_automatic_association_of), 0, 0, 1, 0},
  {&__pyx_kp_s_Enable_logging_of_library_activi, __pyx_k_Enable_logging_of_library_activi, sizeof(__pyx_k_Enable_logging_of_library_activi), 0, 0, 1, 0},
  {&__pyx_n_s_EnforceSecureReception, __pyx_k_EnforceSecureReception, sizeof(__pyx_k_EnforceSecureReception), 0, 0, 1, 1},
  {&__pyx_n_s_EnumWithDoc, __pyx_k_EnumWithDoc, sizeof(__pyx_k_EnumWithDoc), 0, 0, 1, 1},
  {&__pyx_n_s_EnumWithDocType, __pyx_k_EnumWithDocType, sizeof(__pyx_k_EnumWithDocType), 0, 0, 1, 1},
  {&__pyx_n_s_EnumWithDocType_setDocType, __pyx_k_EnumWithDocType_setDocType, sizeof(__pyx_k_EnumWithDocType_setDocType), 0, 0, 1, 1},
  {&__pyx_n_s_EnumWithDoc_setDoc, __pyx_k_EnumWithDoc_setDoc, sizeof(__pyx_k_EnumWithDoc_setDoc), 0, 0, 1, 1},
  {&__pyx_kp_s_Enum_helper, __pyx_k_Enum_helper, sizeof(__pyx_k_Enum_helper), 0, 0, 1, 0},
  {&__pyx_n_s_Error, __pyx_k_Error, sizeof(__pyx_k_Error), 0, 0, 1, 1},
  {&__pyx_n_s_EssentialNodeQueriesComplete, __pyx_k_EssentialNodeQueriesComplete, sizeof(__pyx_k_EssentialNodeQueriesComplete), 0, 0, 1, 1},
  {&__pyx_kp_s_Everything_s_working_fine_these, __pyx_k_Everything_s_working_fine_these, sizeof(__pyx_k_Everything_s_working_fine_these), 0, 0, 1, 0},
  {&__pyx_kp_s_Exception_class_for_LibOpenZWav, __pyx_k_Exception_class_for_LibOpenZWav, sizeof(__pyx_k_Exception_class_for_LibOpenZWav), 0, 0, 1, 0},
  {&__pyx_n_s_Exclude, __pyx_k_Exclude, sizeof(__pyx_k_Exclude), 0, 0, 1, 1},
  {&__pyx_n_s_Failed, __pyx_k_Failed, sizeof(__pyx_k_Failed), 0, 0, 1, 1},
  {&__pyx_n_s_Fatal, __pyx_k_Fatal, sizeof(__pyx_k_Fatal), 0, 0, 1, 1},
  {&__pyx_kp_s_Get_a_node_to_rebuild_its_neighb, __pyx_k_Get_a_node_to_rebuild_its_neighb, sizeof(__pyx_k_Get_a_node_to_rebuild_its_neighb), 0, 0, 1, 0},
  {&__pyx_n_s_Group, __pyx_k_Group, sizeof(__pyx_k_Group), 0, 0, 1, 1},
  {&__pyx_kp_s_Handheld_controller_button_event, __pyx_k_Handheld_controller_button_event, sizeof(__pyx_k_Handheld_controller_button_event), 0, 0, 1, 0},
  {&__pyx_kp_s_Handheld_controller_button_event_2, __pyx_k_Handheld_controller_button_event_2, sizeof(__pyx_k_Handheld_controller_button_event_2), 0, 0, 1, 0},
  {&__pyx_kp_s_Handheld_controller_button_off_p, __pyx_k_Handheld_controller_button_off_p, sizeof(__pyx_k_Handheld_controller_button_off_p), 0, 0, 1, 0},
  {&__pyx_kp_s_Handheld_controller_button_on_pr, __pyx_k_Handheld_controller_button_on_pr, sizeof(__pyx_k_Handheld_controller_button_on_pr), 0, 0, 1, 0},
  {&__pyx_n_s_Handler, __pyx_k_Handler, sizeof(__pyx_k_Handler), 0, 0, 1, 1},
  {&__pyx_n_s_HasNodeFailed, __pyx_k_HasNodeFailed, sizeof(__pyx_k_HasNodeFailed), 0, 0, 1, 1},
  {&__pyx_n_s_Hid, __pyx_k_Hid, sizeof(__pyx_k_Hid), 0, 0, 1, 1},
  {&__pyx_kp_s_How_long_do_we_wait_to_timeout_m, __pyx_k_How_long_do_we_wait_to_timeout_m, sizeof(__pyx_k_How_long_do_we_wait_to_timeout_m), 0, 0, 1, 0},
  {&__pyx_kp_s_Identify_the_serial_port_to_be_a, __pyx_k_Identify_the_serial_port_to_be_a, sizeof(__pyx_k_Identify_the_serial_port_to_be_a), 0, 0, 1, 0},
  {&__pyx_kp_s_If_false_try_to_execute_the_enti, __pyx_k_If_false_try_to_execute_the_enti, sizeof(__pyx_k_If_false_try_to_execute_the_enti), 0, 0, 1, 0},
  {&__pyx_kp_s_If_true_during_startup_we_refres, __pyx_k_If_true_during_startup_we_refres, sizeof(__pyx_k_If_true_during_startup_we_refres), 0, 0, 1, 0},
  {&__pyx_kp_s_If_true_notifications_for_refres, __pyx_k_If_true_notifications_for_refres, sizeof(__pyx_k_If_true_notifications_for_refres), 0, 0, 1, 0},
  {&__pyx_kp_s_If_true_return_routes_will_be_up, __pyx_k_If_true_return_routes_will_be_up, sizeof(__pyx_k_If_true_return_routes_will_be_up), 0, 0, 1, 0},
  {&__pyx_kp_s_If_we_recieve_a_clear_text_messa, __pyx_k_If_we_recieve_a_clear_text_messa, sizeof(__pyx_k_If_we_recieve_a_clear_text_messa), 0, 0, 1, 0},
  {&__pyx_n_s_ImportError, __pyx_k_ImportError, sizeof(__pyx_k_ImportError), 0, 0, 1, 1},
  {&__pyx_n_s_InProgress, __pyx_k_InProgress, sizeof(__pyx_k_InProgress), 0, 0, 1, 1},
  {&__pyx_n_s_Include, __pyx_k_Include, sizeof(__pyx_k_Include), 0, 0, 1, 1},
  {&__pyx_n_s_Info, __pyx_k_Info, sizeof(__pyx_k_Info), 0, 0, 1, 1},
  {&__pyx_n_s_Instances, __pyx_k_Instances, sizeof(__pyx_k_Instances), 0, 0, 1, 1},
  {&__pyx_n_s_Int, __pyx_k_Int, sizeof(__pyx_k_Int), 0, 0, 1, 1},
  {&__pyx_kp_s_Integer, __pyx_k_Integer, sizeof(__pyx_k_Integer), 0, 0, 1, 0},
  {&__pyx_n_s_Interface, __pyx_k_Interface, sizeof(__pyx_k_Interface), 0, 0, 1, 1},
  {&__pyx_n_s_Internal, __pyx_k_Internal, sizeof(__pyx_k_Internal), 0, 0, 1, 1},
  {&__pyx_n_s_IntervalBetweenPolls, __pyx_k_IntervalBetweenPolls, sizeof(__pyx_k_IntervalBetweenPolls), 0, 0, 1, 1},
  {&__pyx_n_s_Invalid, __pyx_k_Invalid, sizeof(__pyx_k_Invalid), 0, 0, 1, 1},
  {&__pyx_kp_s_Invalid_Log_Status, __pyx_k_Invalid_Log_Status, sizeof(__pyx_k_Invalid_Log_Status), 0, 0, 1, 0},
  {&__pyx_kp_s_Invalid_type, __pyx_k_Invalid_type, sizeof(__pyx_k_Invalid_type), 0, 0, 1, 0},
  {&__pyx_n_s_IsPrimary, __pyx_k_IsPrimary, sizeof(__pyx_k_IsPrimary), 0, 0, 1, 1},
  {&__pyx_kp_s_Key_used_to_negotiate_and_commun, __pyx_k_Key_used_to_negotiate_and_commun, sizeof(__pyx_k_Key_used_to_negotiate_and_commun), 0, 0, 1, 0},
  {&__pyx_kp_s_LibOpenZwave_Generic_Exception, __pyx_k_LibOpenZwave_Generic_Exception, sizeof(__pyx_k_LibOpenZwave_Generic_Exception), 0, 0, 1, 0},
  {&__pyx_n_s_LibZWaveException, __pyx_k_LibZWaveException, sizeof(__pyx_k_LibZWaveException), 0, 0, 1, 1},
  {&__pyx_n_s_LibZWaveException___init, __pyx_k_LibZWaveException___init, sizeof(__pyx_k_LibZWaveException___init), 0, 0, 1, 1},
  {&__pyx_n_s_LibZWaveException___str, __pyx_k_LibZWaveException___str, sizeof(__pyx_k_LibZWaveException___str), 0, 0, 1, 1},
  {&__pyx_n_s_List, __pyx_k_List, sizeof(__pyx_k_List), 0, 0, 1, 1},
  {&__pyx_kp_s_List_from_which_one_item_can_be, __pyx_k_List_from_which_one_item_can_be, sizeof(__pyx_k_List_from_which_one_item_can_be), 0, 0, 1, 0},
  {&__pyx_n_s_LogFileName, __pyx_k_LogFileName, sizeof(__pyx_k_LogFileName), 0, 0, 1, 1},
  {&__pyx_n_s_Logging, __pyx_k_Logging, sizeof(__pyx_k_Logging), 0, 0, 1, 1},
  {&__pyx_kp_s_Make_a_different_controller_the, __pyx_k_Make_a_different_controller_the, sizeof(__pyx_k_Make_a_different_controller_the), 0, 0, 1, 0},
  {&__pyx_n_s_ManufacturerSpecific1, __pyx_k_ManufacturerSpecific1, sizeof(__pyx_k_ManufacturerSpecific1), 0, 0, 1, 1},
  {&__pyx_n_s_ManufacturerSpecific2, __pyx_k_ManufacturerSpecific2, sizeof(__pyx_k_ManufacturerSpecific2), 0, 0, 1, 1},
  {&__pyx_kp_s_Messages_that_timeout_will_send, __pyx_k_Messages_that_timeout_will_send, sizeof(__pyx_k_Messages_that_timeout_will_send), 0, 0, 1, 0},
  {&__pyx_kp_s_Move_a_node_to_the_controller_s, __pyx_k_Move_a_node_to_the_controller_s, sizeof(__pyx_k_Move_a_node_to_the_controller_s), 0, 0, 1, 0},
  {&__pyx_n_s_MsgComplete, __pyx_k_MsgComplete, sizeof(__pyx_k_MsgComplete), 0, 0, 1, 1},
  {&__pyx_n_s_NAKCnt, __pyx_k_NAKCnt, sizeof(__pyx_k_NAKCnt), 0, 0, 1, 1},
  {&__pyx_kp_s_Name_of_the_log_file_can_be_chan, __pyx_k_Name_of_the_log_file_can_be_chan, sizeof(__pyx_k_Name_of_the_log_file_can_be_chan), 0, 0, 1, 0},
  {&__pyx_n_s_Neighbors, __pyx_k_Neighbors, sizeof(__pyx_k_Neighbors), 0, 0, 1, 1},
  {&__pyx_n_s_NetworkKey, __pyx_k_NetworkKey, sizeof(__pyx_k_NetworkKey), 0, 0, 1, 1},
  {&__pyx_n_s_NoOperation, __pyx_k_NoOperation, sizeof(__pyx_k_NoOperation), 0, 0, 1, 1},
  {&__pyx_kp_s_No_command, __pyx_k_No_command, sizeof(__pyx_k_No_command), 0, 0, 1, 0},
  {&__pyx_kp_s_No_command_in_progress, __pyx_k_No_command_in_progress, sizeof(__pyx_k_No_command_in_progress), 0, 0, 1, 0},
  {&__pyx_n_s_NodeAdded, __pyx_k_NodeAdded, sizeof(__pyx_k_NodeAdded), 0, 0, 1, 1},
  {&__pyx_n_s_NodeEvent, __pyx_k_NodeEvent, sizeof(__pyx_k_NodeEvent), 0, 0, 1, 1},
  {&__pyx_n_s_NodeFailed, __pyx_k_NodeFailed, sizeof(__pyx_k_NodeFailed), 0, 0, 1, 1},
  {&__pyx_n_s_NodeInfo, __pyx_k_NodeInfo, sizeof(__pyx_k_NodeInfo), 0, 0, 1, 1},
  {&__pyx_n_s_NodeNaming, __pyx_k_NodeNaming, sizeof(__pyx_k_NodeNaming), 0, 0, 1, 1},
  {&__pyx_n_s_NodeNew, __pyx_k_NodeNew, sizeof(__pyx_k_NodeNew), 0, 0, 1, 1},
  {&__pyx_n_s_NodeNotFound, __pyx_k_NodeNotFound, sizeof(__pyx_k_NodeNotFound), 0, 0, 1, 1},
  {&__pyx_n_s_NodeOK, __pyx_k_NodeOK, sizeof(__pyx_k_NodeOK), 0, 0, 1, 1},
  {&__pyx_n_s_NodeProtocolInfo, __pyx_k_NodeProtocolInfo, sizeof(__pyx_k_NodeProtocolInfo), 0, 0, 1, 1},
  {&__pyx_n_s_NodeQueriesComplete, __pyx_k_NodeQueriesComplete, sizeof(__pyx_k_NodeQueriesComplete), 0, 0, 1, 1},
  {&__pyx_n_s_NodeRemoved, __pyx_k_NodeRemoved, sizeof(__pyx_k_NodeRemoved), 0, 0, 1, 1},
  {&__pyx_n_s_NodeReset, __pyx_k_NodeReset, sizeof(__pyx_k_NodeReset), 0, 0, 1, 1},
  {&__pyx_n_s_None, __pyx_k_None, sizeof(__pyx_k_None), 0, 0, 1, 1},
  {&__pyx_kp_s_None_2, __pyx_k_None_2, sizeof(__pyx_k_None_2), 0, 0, 1, 0},
  {&__pyx_n_s_Normal, __pyx_k_Normal, sizeof(__pyx_k_Normal), 0, 0, 1, 1},
  {&__pyx_n_s_NotBridge, __pyx_k_NotBridge, sizeof(__pyx_k_NotBridge), 0, 0, 1, 1},
  {&__pyx_n_s_NotFound, __pyx_k_NotFound, sizeof(__pyx_k_NotFound), 0, 0, 1, 1},
  {&__pyx_n_s_NotPrimary, __pyx_k_NotPrimary, sizeof(__pyx_k_NotPrimary), 0, 0, 1, 1},
  {&__pyx_n_s_NotSUC, __pyx_k_NotSUC, sizeof(__pyx_k_NotSUC), 0, 0, 1, 1},
  {&__pyx_n_s_NotSecondary, __pyx_k_NotSecondary, sizeof(__pyx_k_NotSecondary), 0, 0, 1, 1},
  {&__pyx_n_s_Notification, __pyx_k_Notification, sizeof(__pyx_k_Notification), 0, 0, 1, 1},
  {&__pyx_kp_s_Notification_Type_DriverRemoved, __pyx_k_Notification_Type_DriverRemoved, sizeof(__pyx_k_Notification_Type_DriverRemoved), 0, 0, 1, 0},
  {&__pyx_kp_s_Notification_Type_DriverReset_re, __pyx_k_Notification_Type_DriverReset_re, sizeof(__pyx_k_Notification_Type_DriverReset_re), 0, 0, 1, 0},
  {&__pyx_kp_s_Notifications_when_transaction_c, __pyx_k_Notifications_when_transaction_c, sizeof(__pyx_k_Notifications_when_transaction_c), 0, 0, 1, 0},
  {&__pyx_n_s_NotifyOnDriverUnload, __pyx_k_NotifyOnDriverUnload, sizeof(__pyx_k_NotifyOnDriverUnload), 0, 0, 1, 1},
  {&__pyx_n_s_NotifyTransactions, __pyx_k_NotifyTransactions, sizeof(__pyx_k_NotifyTransactions), 0, 0, 1, 1},
  {&__pyx_n_s_NullHandler, __pyx_k_NullHandler, sizeof(__pyx_k_NullHandler), 0, 0, 1, 1},
  {&__pyx_n_s_NullHandler_emit, __pyx_k_NullHandler_emit, sizeof(__pyx_k_NullHandler_emit), 0, 0, 1, 1},
  {&__pyx_kp_s_NullHandler_logger_for_python_2, __pyx_k_NullHandler_logger_for_python_2, sizeof(__pyx_k_NullHandler_logger_for_python_2), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_ACK_bytes_received, __pyx_k_Number_of_ACK_bytes_received, sizeof(__pyx_k_Number_of_ACK_bytes_received), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_CAN_bytes_received, __pyx_k_Number_of_CAN_bytes_received, sizeof(__pyx_k_Number_of_CAN_bytes_received), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_NAK_bytes_received, __pyx_k_Number_of_NAK_bytes_received, sizeof(__pyx_k_Number_of_NAK_bytes_received), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_SOF_bytes_received, __pyx_k_Number_of_SOF_bytes_received, sizeof(__pyx_k_Number_of_SOF_bytes_received), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_bad_checksums, __pyx_k_Number_of_bad_checksums, sizeof(__pyx_k_Number_of_bad_checksums), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_broadcasts_read, __pyx_k_Number_of_broadcasts_read, sizeof(__pyx_k_Number_of_broadcasts_read), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_broadcasts_sent, __pyx_k_Number_of_broadcasts_sent, sizeof(__pyx_k_Number_of_broadcasts_sent), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_bytes_out_of_framing, __pyx_k_Number_of_bytes_out_of_framing, sizeof(__pyx_k_Number_of_bytes_out_of_framing), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_failed_messages_due_to, __pyx_k_Number_of_failed_messages_due_to, sizeof(__pyx_k_Number_of_failed_messages_due_to), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_messages_dropped_not_d, __pyx_k_Number_of_messages_dropped_not_d, sizeof(__pyx_k_Number_of_messages_dropped_not_d), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_messages_not_delivered, __pyx_k_Number_of_messages_not_delivered, sizeof(__pyx_k_Number_of_messages_not_delivered), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_messages_received_with, __pyx_k_Number_of_messages_received_with, sizeof(__pyx_k_Number_of_messages_received_with), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_messages_retransmitted, __pyx_k_Number_of_messages_retransmitted, sizeof(__pyx_k_Number_of_messages_retransmitted), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_messages_successfully, __pyx_k_Number_of_messages_successfully, sizeof(__pyx_k_Number_of_messages_successfully), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_messages_successfully_2, __pyx_k_Number_of_messages_successfully_2, sizeof(__pyx_k_Number_of_messages_successfully_2), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_network_busy_failure_m, __pyx_k_Number_of_network_busy_failure_m, sizeof(__pyx_k_Number_of_network_busy_failure_m), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_no_ACK_returned_errors, __pyx_k_Number_of_no_ACK_returned_errors, sizeof(__pyx_k_Number_of_no_ACK_returned_errors), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_times_read_were_aborte, __pyx_k_Number_of_times_read_were_aborte, sizeof(__pyx_k_Number_of_times_read_were_aborte), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_unexpected_callbacks, __pyx_k_Number_of_unexpected_callbacks, sizeof(__pyx_k_Number_of_unexpected_callbacks), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_unsolicited_messages_w, __pyx_k_Number_of_unsolicited_messages_w, sizeof(__pyx_k_Number_of_unsolicited_messages_w), 0, 0, 1, 0},
  {&__pyx_n_s_OOFCnt, __pyx_k_OOFCnt, sizeof(__pyx_k_OOFCnt), 0, 0, 1, 1},
  {&__pyx_n_s_OZWAVE_CONFIG_DIRECTORY, __pyx_k_OZWAVE_CONFIG_DIRECTORY, sizeof(__pyx_k_OZWAVE_CONFIG_DIRECTORY), 0, 0, 1, 1},
  {&__pyx_kp_s_One_of_the_node_names_has_change, __pyx_k_One_of_the_node_names_has_change, sizeof(__pyx_k_One_of_the_node_names_has_change), 0, 0, 1, 0},
  {&__pyx_kp_s_Only_handle_the_specified_comman, __pyx_k_Only_handle_the_specified_comman, sizeof(__pyx_k_Only_handle_the_specified_comman), 0, 0, 1, 0},
  {&__pyx_n_s_Overflow, __pyx_k_Overflow, sizeof(__pyx_k_Overflow), 0, 0, 1, 1},
  {&__pyx_n_s_PY3, __pyx_k_PY3, sizeof(__pyx_k_PY3), 0, 0, 1, 1},
  {&__pyx_n_s_PYLIBRARY, __pyx_k_PYLIBRARY, sizeof(__pyx_k_PYLIBRARY), 0, 0, 1, 1},
  {&__pyx_n_s_PY_OZWAVE_CONFIG_DIRECTORY, __pyx_k_PY_OZWAVE_CONFIG_DIRECTORY, sizeof(__pyx_k_PY_OZWAVE_CONFIG_DIRECTORY), 0, 0, 1, 1},
  {&__pyx_kp_s_Path_to_the_OpenZWave_config_fol, __pyx_k_Path_to_the_OpenZWave_config_fol, sizeof(__pyx_k_Path_to_the_OpenZWave_config_fol), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_the_user_s_data_folder, __pyx_k_Path_to_the_user_s_data_folder, sizeof(__pyx_k_Path_to_the_user_s_data_folder), 0, 0, 1, 0},
  {&__pyx_n_s_PerformReturnRoutes, __pyx_k_PerformReturnRoutes, sizeof(__pyx_k_PerformReturnRoutes), 0, 0, 1, 1},
  {&__pyx_n_s_PollInterval, __pyx_k_PollInterval, sizeof(__pyx_k_PollInterval), 0, 0, 1, 1},
  {&__pyx_n_s_PollingDisabled, __pyx_k_PollingDisabled, sizeof(__pyx_k_PollingDisabled), 0, 0, 1, 1},
  {&__pyx_n_s_PollingEnabled, __pyx_k_PollingEnabled, sizeof(__pyx_k_PollingEnabled), 0, 0, 1, 1},
  {&__pyx_kp_s_Polling_of_a_node_has_been_succe, __pyx_k_Polling_of_a_node_has_been_succe, sizeof(__pyx_k_Polling_of_a_node_has_been_succe), 0, 0, 1, 0},
  {&__pyx_kp_s_Polling_of_a_node_has_been_succe_2, __pyx_k_Polling_of_a_node_has_been_succe_2, sizeof(__pyx_k_Polling_of_a_node_has_been_succe_2), 0, 0, 1, 0},
  {&__pyx_n_s_Probe, __pyx_k_Probe, sizeof(__pyx_k_Probe), 0, 0, 1, 1},
  {&__pyx_n_s_Probe1, __pyx_k_Probe1, sizeof(__pyx_k_Probe1), 0, 0, 1, 1},
  {&__pyx_n_s_ProtocolInfo, __pyx_k_ProtocolInfo, sizeof(__pyx_k_ProtocolInfo), 0, 0, 1, 1},
  {&__pyx_n_s_PyControllerCommand, __pyx_k_PyControllerCommand, sizeof(__pyx_k_PyControllerCommand), 0, 0, 1, 1},
  {&__pyx_n_s_PyControllerError, __pyx_k_PyControllerError, sizeof(__pyx_k_PyControllerError), 0, 0, 1, 1},
  {&__pyx_n_s_PyControllerInterface, __pyx_k_PyControllerInterface, sizeof(__pyx_k_PyControllerInterface), 0, 0, 1, 1},
  {&__pyx_n_s_PyControllerState, __pyx_k_PyControllerState, sizeof(__pyx_k_PyControllerState), 0, 0, 1, 1},
  {&__pyx_n_s_PyGenres, __pyx_k_PyGenres, sizeof(__pyx_k_PyGenres), 0, 0, 1, 1},
  {&__pyx_n_s_PyLogLevels, __pyx_k_PyLogLevels, sizeof(__pyx_k_PyLogLevels), 0, 0, 1, 1},
  {&__pyx_n_s_PyNotificationCodes, __pyx_k_PyNotificationCodes, sizeof(__pyx_k_PyNotificationCodes), 0, 0, 1, 1},
  {&__pyx_n_s_PyNotifications, __pyx_k_PyNotifications, sizeof(__pyx_k_PyNotifications), 0, 0, 1, 1},
  {&__pyx_n_s_PyOptionList, __pyx_k_PyOptionList, sizeof(__pyx_k_PyOptionList), 0, 0, 1, 1},
  {&__pyx_n_s_PyOptionType, __pyx_k_PyOptionType, sizeof(__pyx_k_PyOptionType), 0, 0, 1, 1},
  {&__pyx_n_s_PyStatDriver, __pyx_k_PyStatDriver, sizeof(__pyx_k_PyStatDriver), 0, 0, 1, 1},
  {&__pyx_n_s_PyValueTypes, __pyx_k_PyValueTypes, sizeof(__pyx_k_PyValueTypes), 0, 0, 1, 1},
  {&__pyx_n_s_QueueLogLevel, __pyx_k_QueueLogLevel, sizeof(__pyx_k_QueueLogLevel), 0, 0, 1, 1},
  {&__pyx_n_s_R_OK, __pyx_k_R_OK, sizeof(__pyx_k_R_OK), 0, 0, 1, 1},
  {&__pyx_n_s_Raw, __pyx_k_Raw, sizeof(__pyx_k_Raw), 0, 0, 1, 1},
  {&__pyx_kp_s_Raw_byte_values, __pyx_k_Raw_byte_values, sizeof(__pyx_k_Raw_byte_values), 0, 0, 1, 0},
  {&__pyx_n_s_ReceiveConfiguration, __pyx_k_ReceiveConfiguration, sizeof(__pyx_k_ReceiveConfiguration), 0, 0, 1, 1},
  {&__pyx_kp_s_ReceiveConfiguration_2, __pyx_k_ReceiveConfiguration_2, sizeof(__pyx_k_ReceiveConfiguration_2), 0, 0, 1, 0},
  {&__pyx_kp_s_Receive_Z_Wave_network_configura, __pyx_k_Receive_Z_Wave_network_configura, sizeof(__pyx_k_Receive_Z_Wave_network_configura), 0, 0, 1, 0},
  {&__pyx_n_s_RefreshAllUserCodes, __pyx_k_RefreshAllUserCodes, sizeof(__pyx_k_RefreshAllUserCodes), 0, 0, 1, 1},
  {&__pyx_n_s_RemoveDevice, __pyx_k_RemoveDevice, sizeof(__pyx_k_RemoveDevice), 0, 0, 1, 1},
  {&__pyx_n_s_RemoveFailedNode, __pyx_k_RemoveFailedNode, sizeof(__pyx_k_RemoveFailedNode), 0, 0, 1, 1},
  {&__pyx_kp_s_RemoveFailedNode_2, __pyx_k_RemoveFailedNode_2, sizeof(__pyx_k_RemoveFailedNode_2), 0, 0, 1, 0},
  {&__pyx_kp_s_RemoveFailedNode_AddNodeToNetwor, __pyx_k_RemoveFailedNode_AddNodeToNetwor, sizeof(__pyx_k_RemoveFailedNode_AddNodeToNetwor), 0, 0, 1, 0},
  {&__pyx_kp_s_RemoveFailedNode_RequestNetworkU, __pyx_k_RemoveFailedNode_RequestNetworkU, sizeof(__pyx_k_RemoveFailedNode_RequestNetworkU), 0, 0, 1, 0},
  {&__pyx_kp_s_Remove_a_new_device_but_not_a_co, __pyx_k_Remove_a_new_device_but_not_a_co, sizeof(__pyx_k_Remove_a_new_device_but_not_a_co), 0, 0, 1, 0},
  {&__pyx_kp_s_Remove_support_for_the_listed_co, __pyx_k_Remove_support_for_the_listed_co, sizeof(__pyx_k_Remove_support_for_the_listed_co), 0, 0, 1, 0},
  {&__pyx_n_s_ReplaceFailedNode, __pyx_k_ReplaceFailedNode, sizeof(__pyx_k_ReplaceFailedNode), 0, 0, 1, 1},
  {&__pyx_kp_s_Replace_a_non_responding_node_wi, __pyx_k_Replace_a_non_responding_node_wi, sizeof(__pyx_k_Replace_a_non_responding_node_wi), 0, 0, 1, 0},
  {&__pyx_n_s_ReplicationSend, __pyx_k_ReplicationSend, sizeof(__pyx_k_ReplicationSend), 0, 0, 1, 1},
  {&__pyx_kp_s_Report_on_NoOperation_message_se, __pyx_k_Report_on_NoOperation_message_se, sizeof(__pyx_k_Report_on_NoOperation_message_se), 0, 0, 1, 0},
  {&__pyx_kp_s_Report_when_a_node_goes_to_sleep, __pyx_k_Report_when_a_node_goes_to_sleep, sizeof(__pyx_k_Report_when_a_node_goes_to_sleep), 0, 0, 1, 0},
  {&__pyx_kp_s_Report_when_a_node_is_presumed_d, __pyx_k_Report_when_a_node_is_presumed_d, sizeof(__pyx_k_Report_when_a_node_is_presumed_d), 0, 0, 1, 0},
  {&__pyx_kp_s_Report_when_a_node_is_revived, __pyx_k_Report_when_a_node_is_revived, sizeof(__pyx_k_Report_when_a_node_is_revived), 0, 0, 1, 0},
  {&__pyx_kp_s_Report_when_a_sleeping_node_wake, __pyx_k_Report_when_a_sleeping_node_wake, sizeof(__pyx_k_Report_when_a_sleeping_node_wake), 0, 0, 1, 0},
  {&__pyx_kp_s_Represents_a_non_integer_value_a, __pyx_k_Represents_a_non_integer_value_a, sizeof(__pyx_k_Represents_a_non_integer_value_a), 0, 0, 1, 0},
  {&__pyx_n_s_RequestNetworkUpdate, __pyx_k_RequestNetworkUpdate, sizeof(__pyx_k_RequestNetworkUpdate), 0, 0, 1, 1},
  {&__pyx_kp_s_RequestNetworkUpdate_error, __pyx_k_RequestNetworkUpdate_error, sizeof(__pyx_k_RequestNetworkUpdate_error), 0, 0, 1, 0},
  {&__pyx_n_s_RequestNodeNeighborUpdate, __pyx_k_RequestNodeNeighborUpdate, sizeof(__pyx_k_RequestNodeNeighborUpdate), 0, 0, 1, 1},
  {&__pyx_kp_s_Request_network_information_from, __pyx_k_Request_network_information_from, sizeof(__pyx_k_Request_network_information_from), 0, 0, 1, 0},
  {&__pyx_n_s_RetryTimeout, __pyx_k_RetryTimeout, sizeof(__pyx_k_RetryTimeout), 0, 0, 1, 1},
  {&__pyx_n_s_SOFCnt, __pyx_k_SOFCnt, sizeof(__pyx_k_SOFCnt), 0, 0, 1, 1},
  {&__pyx_n_s_SUPPORTED, __pyx_k_SUPPORTED, sizeof(__pyx_k_SUPPORTED), 0, 0, 1, 1},
  {&__pyx_n_s_SaveConfiguration, __pyx_k_SaveConfiguration, sizeof(__pyx_k_SaveConfiguration), 0, 0, 1, 1},
  {&__pyx_n_s_SaveLogLevel, __pyx_k_SaveLogLevel, sizeof(__pyx_k_SaveLogLevel), 0, 0, 1, 1},
  {&__pyx_kp_s_Save_in_RAM_log_messages_equal_t, __pyx_k_Save_in_RAM_log_messages_equal_t, sizeof(__pyx_k_Save_in_RAM_log_messages_equal_t), 0, 0, 1, 0},
  {&__pyx_kp_s_Save_the_XML_configuration_upon, __pyx_k_Save_the_XML_configuration_upon, sizeof(__pyx_k_Save_the_XML_configuration_upon), 0, 0, 1, 0},
  {&__pyx_kp_s_Save_to_file_log_messages_equal, __pyx_k_Save_to_file_log_messages_equal, sizeof(__pyx_k_Save_to_file_log_messages_equal), 0, 0, 1, 0},
  {&__pyx_n_s_SceneEvent, __pyx_k_SceneEvent, sizeof(__pyx_k_SceneEvent), 0, 0, 1, 1},
  {&__pyx_kp_s_Scene_Activation_Set_received, __pyx_k_Scene_Activation_Set_received, sizeof(__pyx_k_Scene_Activation_Set_received), 0, 0, 1, 0},
  {&__pyx_n_s_Schedule, __pyx_k_Schedule, sizeof(__pyx_k_Schedule), 0, 0, 1, 1},
  {&__pyx_n_s_SecurityStrategy, __pyx_k_SecurityStrategy, sizeof(__pyx_k_SecurityStrategy), 0, 0, 1, 1},
  {&__pyx_n_s_SendNodeInformation, __pyx_k_SendNodeInformation, sizeof(__pyx_k_SendNodeInformation), 0, 0, 1, 1},
  {&__pyx_kp_s_Send_a_node_information_frame, __pyx_k_Send_a_node_information_frame, sizeof(__pyx_k_Send_a_node_information_frame), 0, 0, 1, 0},
  {&__pyx_kp_s_Send_information_from_primary_to, __pyx_k_Send_information_from_primary_to, sizeof(__pyx_k_Send_information_from_primary_to), 0, 0, 1, 0},
  {&__pyx_n_s_Serial, __pyx_k_Serial, sizeof(__pyx_k_Serial), 0, 0, 1, 1},
  {&__pyx_n_s_Session, __pyx_k_Session, sizeof(__pyx_k_Session), 0, 0, 1, 1},
  {&__pyx_kp_s_SetValueListSelection_s, __pyx_k_SetValueListSelection_s, sizeof(__pyx_k_SetValueListSelection_s), 0, 0, 1, 0},
  {&__pyx_n_s_Short, __pyx_k_Short, sizeof(__pyx_k_Short), 0, 0, 1, 1},
  {&__pyx_kp_s_Should_we_encrypt_CC_s_that_are, __pyx_k_Should_we_encrypt_CC_s_that_are, sizeof(__pyx_k_Should_we_encrypt_CC_s_that_are), 0, 0, 1, 0},
  {&__pyx_kp_s_Should_we_send_the_Node_Value_No, __pyx_k_Should_we_send_the_Node_Value_No, sizeof(__pyx_k_Should_we_send_the_Node_Value_No), 0, 0, 1, 0},
  {&__pyx_n_s_Sleep, __pyx_k_Sleep, sizeof(__pyx_k_Sleep), 0, 0, 1, 1},
  {&__pyx_n_s_Sleeping, __pyx_k_Sleeping, sizeof(__pyx_k_Sleeping), 0, 0, 1, 1},
  {&__pyx_kp_s_Something_unexpected_by_the_libr, __pyx_k_Something_unexpected_by_the_libr, sizeof(__pyx_k_Something_unexpected_by_the_libr), 0, 0, 1, 0},
  {&__pyx_n_s_Starting, __pyx_k_Starting, sizeof(__pyx_k_Starting), 0, 0, 1, 1},
  {&__pyx_n_s_Static, __pyx_k_Static, sizeof(__pyx_k_Static), 0, 0, 1, 1},
  {&__pyx_n_s_StreamDetail, __pyx_k_StreamDetail, sizeof(__pyx_k_StreamDetail), 0, 0, 1, 1},
  {&__pyx_n_s_String, __pyx_k_String, sizeof(__pyx_k_String), 0, 0, 1, 1},
  {&__pyx_kp_s_String_2, __pyx_k_String_2, sizeof(__pyx_k_String_2), 0, 0, 1, 0},
  {&__pyx_n_s_SuppressValueRefresh, __pyx_k_SuppressValueRefresh, sizeof(__pyx_k_SuppressValueRefresh), 0, 0, 1, 1},
  {&__pyx_n_s_System, __pyx_k_System, sizeof(__pyx_k_System), 0, 0, 1, 1},
  {&__pyx_kp_s_Text_string, __pyx_k_Text_string, sizeof(__pyx_k_Text_string), 0, 0, 1, 0},
  {&__pyx_kp_s_The_Driver_is_being_removed, __pyx_k_The_Driver_is_being_removed, sizeof(__pyx_k_The_Driver_is_being_removed), 0, 0, 1, 0},
  {&__pyx_kp_s_The_associations_for_the_node_ha, __pyx_k_The_associations_for_the_node_ha, sizeof(__pyx_k_The_associations_for_the_node_ha), 0, 0, 1, 0},
  {&__pyx_kp_s_The_command_has_completed_succes, __pyx_k_The_command_has_completed_succes, sizeof(__pyx_k_The_command_has_completed_succes), 0, 0, 1, 0},
  {&__pyx_kp_s_The_command_has_failed, __pyx_k_The_command_has_failed, sizeof(__pyx_k_The_command_has_failed), 0, 0, 1, 0},
  {&__pyx_kp_s_The_command_is_starting, __pyx_k_The_command_is_starting, sizeof(__pyx_k_The_command_is_starting), 0, 0, 1, 0},
  {&__pyx_kp_s_The_command_was_cancelled, __pyx_k_The_command_was_cancelled, sizeof(__pyx_k_The_command_was_cancelled), 0, 0, 1, 0},
  {&__pyx_kp_s_The_controller_is_communicating, __pyx_k_The_controller_is_communicating, sizeof(__pyx_k_The_controller_is_communicating), 0, 0, 1, 0},
  {&__pyx_kp_s_The_level_as_controlled_by_basic, __pyx_k_The_level_as_controlled_by_basic, sizeof(__pyx_k_The_level_as_controlled_by_basic), 0, 0, 1, 0},
  {&__pyx_kp_s_The_queries_on_a_node_that_are_e, __pyx_k_The_queries_on_a_node_that_are_e, sizeof(__pyx_k_The_queries_on_a_node_that_are_e), 0, 0, 1, 0},
  {&__pyx_kp_s_These_messages_should_always_be, __pyx_k_These_messages_should_always_be, sizeof(__pyx_k_These_messages_should_always_be), 0, 0, 1, 0},
  {&__pyx_n_s_Timeout, __pyx_k_Timeout, sizeof(__pyx_k_Timeout), 0, 0, 1, 1},
  {&__pyx_n_s_TransferPrimaryRole, __pyx_k_TransferPrimaryRole, sizeof(__pyx_k_TransferPrimaryRole), 0, 0, 1, 1},
  {&__pyx_n_s_Unknown, __pyx_k_Unknown, sizeof(__pyx_k_Unknown), 0, 0, 1, 1},
  {&__pyx_kp_s_Used_only_with_ControllerCommand, __pyx_k_Used_only_with_ControllerCommand, sizeof(__pyx_k_Used_only_with_ControllerCommand), 0, 0, 1, 0},
  {&__pyx_kp_s_Used_only_with_ControllerCommand_2, __pyx_k_Used_only_with_ControllerCommand_2, sizeof(__pyx_k_Used_only_with_ControllerCommand_2), 0, 0, 1, 0},
  {&__pyx_kp_s_Used_only_within_the_log_class_u, __pyx_k_Used_only_within_the_log_class_u, sizeof(__pyx_k_Used_only_within_the_log_class_u), 0, 0, 1, 0},
  {&__pyx_n_s_User, __pyx_k_User, sizeof(__pyx_k_User), 0, 0, 1, 1},
  {&__pyx_n_s_UserPath, __pyx_k_UserPath, sizeof(__pyx_k_UserPath), 0, 0, 1, 1},
  {&__pyx_n_s_ValueAdded, __pyx_k_ValueAdded, sizeof(__pyx_k_ValueAdded), 0, 0, 1, 1},
  {&__pyx_n_s_ValueChanged, __pyx_k_ValueChanged, sizeof(__pyx_k_ValueChanged), 0, 0, 1, 1},
  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
  {&__pyx_n_s_ValueRefreshed, __pyx_k_ValueRefreshed, sizeof(__pyx_k_ValueRefreshed), 0, 0, 1, 1},
  {&__pyx_n_s_ValueRemoved, __pyx_k_ValueRemoved, sizeof(__pyx_k_ValueRemoved), 0, 0, 1, 1},
  {&__pyx_kp_s_Values_of_significance_only_to_u, __pyx_k_Values_of_significance_only_to_u, sizeof(__pyx_k_Values_of_significance_only_to_u), 0, 0, 1, 0},
  {&__pyx_n_s_Versions, __pyx_k_Versions, sizeof(__pyx_k_Versions), 0, 0, 1, 1},
  {&__pyx_kp_s_Very_detailed_information_on_pro, __pyx_k_Very_detailed_information_on_pro, sizeof(__pyx_k_Very_detailed_information_on_pro), 0, 0, 1, 0},
  {&__pyx_n_s_W_OK, __pyx_k_W_OK, sizeof(__pyx_k_W_OK), 0, 0, 1, 1},
  {&__pyx_n_s_Waiting, __pyx_k_Waiting, sizeof(__pyx_k_Waiting), 0, 0, 1, 1},
  {&__pyx_n_s_WakeUp, __pyx_k_WakeUp, sizeof(__pyx_k_WakeUp), 0, 0, 1, 1},
  {&__pyx_n_s_Warning, __pyx_k_Warning, sizeof(__pyx_k_Warning), 0, 0, 1, 1},
  {&__pyx_kp_s_What_List_of_Custom_CC_should_we, __pyx_k_What_List_of_Custom_CC_should_we, sizeof(__pyx_k_What_List_of_Custom_CC_should_we), 0, 0, 1, 0},
  {&__pyx_kp_s_When_Controller_Commands_are_exe, __pyx_k_When_Controller_Commands_are_exe, sizeof(__pyx_k_When_Controller_Commands_are_exe), 0, 0, 1, 0},
  {&__pyx_kp_s_Will_include_low_level_byte_tran, __pyx_k_Will_include_low_level_byte_tran, sizeof(__pyx_k_Will_include_low_level_byte_tran), 0, 0, 1, 0},
  {&__pyx_kp_s__29, __pyx_k__29, sizeof(__pyx_k__29), 0, 0, 1, 0},
  {&__pyx_kp_s__5, __pyx_k__5, sizeof(__pyx_k__5), 0, 0, 1, 0},
  {&__pyx_kp_s__6, __pyx_k__6, sizeof(__pyx_k__6), 0, 0, 1, 0},
  {&__pyx_n_s_a, __pyx_k_a, sizeof(__pyx_k_a), 0, 0, 1, 1},
  {&__pyx_n_s_abspath, __pyx_k_abspath, sizeof(__pyx_k_abspath), 0, 0, 1, 1},
  {&__pyx_n_s_access, __pyx_k_access, sizeof(__pyx_k_access), 0, 0, 1, 1},
  {&__pyx_n_s_addHandler, __pyx_k_addHandler, sizeof(__pyx_k_addHandler), 0, 0, 1, 1},
  {&__pyx_n_s_addOptionBool, __pyx_k_addOptionBool, sizeof(__pyx_k_addOptionBool), 0, 0, 1, 1},
  {&__pyx_n_s_addOptionInt, __pyx_k_addOptionInt, sizeof(__pyx_k_addOptionInt), 0, 0, 1, 1},
  {&__pyx_n_s_addOptionString, __pyx_k_addOptionString, sizeof(__pyx_k_addOptionString), 0, 0, 1, 1},
  {&__pyx_kp_s_addValueId_GetCommandClassId_s_G, __pyx_k_addValueId_GetCommandClassId_s_G, sizeof(__pyx_k_addValueId_GetCommandClassId_s_G), 0, 0, 1, 0},
  {&__pyx_kp_s_addValueId_Notification_s, __pyx_k_addValueId_Notification_s, sizeof(__pyx_k_addValueId_Notification_s), 0, 0, 1, 0},
  {&__pyx_kp_s_addValueId_ValueID_s, __pyx_k_addValueId_ValueID_s, sizeof(__pyx_k_addValueId_ValueID_s), 0, 0, 1, 0},
  {&__pyx_kp_s_all_nodes_queried, __pyx_k_all_nodes_queried, sizeof(__pyx_k_all_nodes_queried), 0, 0, 1, 0},
  {&__pyx_n_s_append, __pyx_k_append, sizeof(__pyx_k_append), 0, 0, 1, 1},
  {&__pyx_n_s_arg, __pyx_k_arg, sizeof(__pyx_k_arg), 0, 0, 1, 1},
  {&__pyx_n_s_averageRequestRTT, __pyx_k_averageRequestRTT, sizeof(__pyx_k_averageRequestRTT), 0, 0, 1, 1},
  {&__pyx_n_s_averageResponseRTT, __pyx_k_averageResponseRTT, sizeof(__pyx_k_averageResponseRTT), 0, 0, 1, 1},
  {&__pyx_kp_s_awake_nodes_queried, __pyx_k_awake_nodes_queried, sizeof(__pyx_k_awake_nodes_queried), 0, 0, 1, 0},
  {&__pyx_n_s_b, __pyx_k_b, sizeof(__pyx_k_b), 0, 0, 1, 1},
  {&__pyx_n_s_bIntervalBetweenPolls, __pyx_k_bIntervalBetweenPolls, sizeof(__pyx_k_bIntervalBetweenPolls), 0, 0, 1, 1},
  {&__pyx_n_s_badChecksum, __pyx_k_badChecksum, sizeof(__pyx_k_badChecksum), 0, 0, 1, 1},
  {&__pyx_n_s_badroutes, __pyx_k_badroutes, sizeof(__pyx_k_badroutes), 0, 0, 1, 1},
  {&__pyx_n_s_broadcastReadCnt, __pyx_k_broadcastReadCnt, sizeof(__pyx_k_broadcastReadCnt), 0, 0, 1, 1},
  {&__pyx_n_s_broadcastWriteCnt, __pyx_k_broadcastWriteCnt, sizeof(__pyx_k_broadcastWriteCnt), 0, 0, 1, 1},
  {&__pyx_n_s_buttonId, __pyx_k_buttonId, sizeof(__pyx_k_buttonId), 0, 0, 1, 1},
  {&__pyx_n_s_buttonid, __pyx_k_buttonid, sizeof(__pyx_k_buttonid), 0, 0, 1, 1},
  {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
  {&__pyx_kp_s_call_to_AddWatcher_failed, __pyx_k_call_to_AddWatcher_failed, sizeof(__pyx_k_call_to_AddWatcher_failed), 0, 0, 1, 0},
  {&__pyx_kp_s_call_to_RemoveWatcher_failed, __pyx_k_call_to_RemoveWatcher_failed, sizeof(__pyx_k_call_to_RemoveWatcher_failed), 0, 0, 1, 0},
  {&__pyx_n_s_callbacks, __pyx_k_callbacks, sizeof(__pyx_k_callbacks), 0, 0, 1, 1},
  {&__pyx_n_s_ccData, __pyx_k_ccData, sizeof(__pyx_k_ccData), 0, 0, 1, 1},
  {&__pyx_n_s_chr, __pyx_k_chr, sizeof(__pyx_k_chr), 0, 0, 1, 1},
  {&__pyx_n_s_className, __pyx_k_className, sizeof(__pyx_k_className), 0, 0, 1, 1},
  {&__pyx_n_s_classVersion, __pyx_k_classVersion, sizeof(__pyx_k_classVersion), 0, 0, 1, 1},
  {&__pyx_n_s_cmd_line, __pyx_k_cmd_line, sizeof(__pyx_k_cmd_line), 0, 0, 1, 1},
  {&__pyx_n_s_command, __pyx_k_command, sizeof(__pyx_k_command), 0, 0, 1, 1},
  {&__pyx_n_s_commandClass, __pyx_k_commandClass, sizeof(__pyx_k_commandClass), 0, 0, 1, 1},
  {&__pyx_n_s_commandClassId, __pyx_k_commandClassId, sizeof(__pyx_k_commandClassId), 0, 0, 1, 1},
  {&__pyx_n_s_config, __pyx_k_config, sizeof(__pyx_k_config), 0, 0, 1, 1},
  {&__pyx_n_s_configPath, __pyx_k_configPath, sizeof(__pyx_k_configPath), 0, 0, 1, 1},
  {&__pyx_n_s_config_path, __pyx_k_config_path, sizeof(__pyx_k_config_path), 0, 0, 1, 1},
  {&__pyx_n_s_controllerError, __pyx_k_controllerError, sizeof(__pyx_k_controllerError), 0, 0, 1, 1},
  {&__pyx_n_s_controllerErrorDoc, __pyx_k_controllerErrorDoc, sizeof(__pyx_k_controllerErrorDoc), 0, 0, 1, 1},
  {&__pyx_n_s_controllerErrorInt, __pyx_k_controllerErrorInt, sizeof(__pyx_k_controllerErrorInt), 0, 0, 1, 1},
  {&__pyx_n_s_controllerState, __pyx_k_controllerState, sizeof(__pyx_k_controllerState), 0, 0, 1, 1},
  {&__pyx_n_s_controllerStateDoc, __pyx_k_controllerStateDoc, sizeof(__pyx_k_controllerStateDoc), 0, 0, 1, 1},
  {&__pyx_n_s_controllerStateInt, __pyx_k_controllerStateInt, sizeof(__pyx_k_controllerStateInt), 0, 0, 1, 1},
  {&__pyx_n_s_copyfile, __pyx_k_copyfile, sizeof(__pyx_k_copyfile), 0, 0, 1, 1},
  {&__pyx_n_s_count, __pyx_k_count, sizeof(__pyx_k_count), 0, 0, 1, 1},
  {&__pyx_n_s_create, __pyx_k_create, sizeof(__pyx_k_create), 0, 0, 1, 1},
  {&__pyx_kp_s_ctrl_callback_Message_s, __pyx_k_ctrl_callback_Message_s, sizeof(__pyx_k_ctrl_callback_Message_s), 0, 0, 1, 0},
  {&__pyx_n_s_debug, __pyx_k_debug, sizeof(__pyx_k_debug), 0, 0, 1, 1},
  {&__pyx_n_s_decode, __pyx_k_decode, sizeof(__pyx_k_decode), 0, 0, 1, 1},
  {&__pyx_kp_s_delValueId_ValueID_s, __pyx_k_delValueId_ValueID_s, sizeof(__pyx_k_delValueId_ValueID_s), 0, 0, 1, 0},
  {&__pyx_kp_s_device_classes_xml, __pyx_k_device_classes_xml, sizeof(__pyx_k_device_classes_xml), 0, 0, 1, 0},
  {&__pyx_n_s_dirn, __pyx_k_dirn, sizeof(__pyx_k_dirn), 0, 0, 1, 1},
  {&__pyx_n_s_dirname, __pyx_k_dirname, sizeof(__pyx_k_dirname), 0, 0, 1, 1},
  {&__pyx_n_s_dist, __pyx_k_dist, sizeof(__pyx_k_dist), 0, 0, 1, 1},
  {&__pyx_n_s_doSecurity, __pyx_k_doSecurity, sizeof(__pyx_k_doSecurity), 0, 0, 1, 1},
  {&__pyx_n_s_doc, __pyx_k_doc, sizeof(__pyx_k_doc), 0, 0, 1, 1},
  {&__pyx_n_s_doc_2, __pyx_k_doc_2, sizeof(__pyx_k_doc_2), 0, 0, 1, 1},
  {&__pyx_kp_s_driver_ready, __pyx_k_driver_ready, sizeof(__pyx_k_driver_ready), 0, 0, 1, 0},
  {&__pyx_kp_s_driver_reset, __pyx_k_driver_reset, sizeof(__pyx_k_driver_reset), 0, 0, 1, 0},
  {&__pyx_n_s_dropped, __pyx_k_dropped, sizeof(__pyx_k_dropped), 0, 0, 1, 1},
  {&__pyx_n_s_emit, __pyx_k_emit, sizeof(__pyx_k_emit), 0, 0, 1, 1},
  {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
  {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
  {&__pyx_n_s_error_msg, __pyx_k_error_msg, sizeof(__pyx_k_error_msg), 0, 0, 1, 1},
  {&__pyx_kp_s_etc_openzwave, __pyx_k_etc_openzwave, sizeof(__pyx_k_etc_openzwave), 0, 0, 1, 0},
  {&__pyx_n_s_event, __pyx_k_event, sizeof(__pyx_k_event), 0, 0, 1, 1},
  {&__pyx_n_s_exception, __pyx_k_exception, sizeof(__pyx_k_exception), 0, 0, 1, 1},
  {&__pyx_n_s_exists, __pyx_k_exists, sizeof(__pyx_k_exists), 0, 0, 1, 1},
  {&__pyx_n_s_file, __pyx_k_file, sizeof(__pyx_k_file), 0, 0, 1, 1},
  {&__pyx_n_s_genre, __pyx_k_genre, sizeof(__pyx_k_genre), 0, 0, 1, 1},
  {&__pyx_n_s_getAssociationsInstances, __pyx_k_getAssociationsInstances, sizeof(__pyx_k_getAssociationsInstances), 0, 0, 1, 1},
  {&__pyx_n_s_getConfigPath, __pyx_k_getConfigPath, sizeof(__pyx_k_getConfigPath), 0, 0, 1, 1},
  {&__pyx_n_s_getLogger, __pyx_k_getLogger, sizeof(__pyx_k_getLogger), 0, 0, 1, 1},
  {&__pyx_n_s_getOptionAsBool, __pyx_k_getOptionAsBool, sizeof(__pyx_k_getOptionAsBool), 0, 0, 1, 1},
  {&__pyx_n_s_getOptionAsInt, __pyx_k_getOptionAsInt, sizeof(__pyx_k_getOptionAsInt), 0, 0, 1, 1},
  {&__pyx_n_s_getOptionAsString, __pyx_k_getOptionAsString, sizeof(__pyx_k_getOptionAsString), 0, 0, 1, 1},
  {&__pyx_kp_s_getValueFromType_return_s, __pyx_k_getValueFromType_return_s, sizeof(__pyx_k_getValueFromType_return_s), 0, 0, 1, 0},
  {&__pyx_n_s_get_distribution, __pyx_k_get_distribution, sizeof(__pyx_k_get_distribution), 0, 0, 1, 1},
  {&__pyx_n_s_getcwd, __pyx_k_getcwd, sizeof(__pyx_k_getcwd), 0, 0, 1, 1},
  {&__pyx_n_s_groupIdx, __pyx_k_groupIdx, sizeof(__pyx_k_groupIdx), 0, 0, 1, 1},
  {&__pyx_n_s_groupidx, __pyx_k_groupidx, sizeof(__pyx_k_groupidx), 0, 0, 1, 1},
  {&__pyx_kp_s_groups_changed, __pyx_k_groups_changed, sizeof(__pyx_k_groups_changed), 0, 0, 1, 0},
  {&__pyx_n_s_help, __pyx_k_help, sizeof(__pyx_k_help), 0, 0, 1, 1},
  {&__pyx_n_s_highPower, __pyx_k_highPower, sizeof(__pyx_k_highPower), 0, 0, 1, 1},
  {&__pyx_n_s_homeId, __pyx_k_homeId, sizeof(__pyx_k_homeId), 0, 0, 1, 1},
  {&__pyx_kp_s_home_sebastien_devel_python_ope, __pyx_k_home_sebastien_devel_python_ope, sizeof(__pyx_k_home_sebastien_devel_python_ope), 0, 0, 1, 0},
  {&__pyx_n_s_homeid, __pyx_k_homeid, sizeof(__pyx_k_homeid), 0, 0, 1, 1},
  {&__pyx_n_s_hours, __pyx_k_hours, sizeof(__pyx_k_hours), 0, 0, 1, 1},
  {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
  {&__pyx_n_s_idx, __pyx_k_idx, sizeof(__pyx_k_idx), 0, 0, 1, 1},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_n_s_index, __pyx_k_index, sizeof(__pyx_k_index), 0, 0, 1, 1},
  {&__pyx_n_s_init, __pyx_k_init, sizeof(__pyx_k_init), 0, 0, 1, 1},
  {&__pyx_kp_s_init___py, __pyx_k_init___py, sizeof(__pyx_k_init___py), 0, 0, 1, 0},
  {&__pyx_n_s_instance, __pyx_k_instance, sizeof(__pyx_k_instance), 0, 0, 1, 1},
  {&__pyx_n_s_intensity, __pyx_k_intensity, sizeof(__pyx_k_intensity), 0, 0, 1, 1},
  {&__pyx_n_s_isdir, __pyx_k_isdir, sizeof(__pyx_k_isdir), 0, 0, 1, 1},
  {&__pyx_n_s_isfile, __pyx_k_isfile, sizeof(__pyx_k_isfile), 0, 0, 1, 1},
  {&__pyx_n_s_join, __pyx_k_join, sizeof(__pyx_k_join), 0, 0, 1, 1},
  {&__pyx_n_s_label, __pyx_k_label, sizeof(__pyx_k_label), 0, 0, 1, 1},
  {&__pyx_n_s_lastReceivedMessage, __pyx_k_lastReceivedMessage, sizeof(__pyx_k_lastReceivedMessage), 0, 0, 1, 1},
  {&__pyx_n_s_lastRequestRTT, __pyx_k_lastRequestRTT, sizeof(__pyx_k_lastRequestRTT), 0, 0, 1, 1},
  {&__pyx_n_s_lastResponseRTT, __pyx_k_lastResponseRTT, sizeof(__pyx_k_lastResponseRTT), 0, 0, 1, 1},
  {&__pyx_n_s_level, __pyx_k_level, sizeof(__pyx_k_level), 0, 0, 1, 1},
  {&__pyx_n_s_libopenzwave, __pyx_k_libopenzwave, sizeof(__pyx_k_libopenzwave), 0, 0, 1, 1},
  {&__pyx_n_s_libopenzwave_file, __pyx_k_libopenzwave_file, sizeof(__pyx_k_libopenzwave_file), 0, 0, 1, 1},
  {&__pyx_n_s_libopenzwave_location, __pyx_k_libopenzwave_location, sizeof(__pyx_k_libopenzwave_location), 0, 0, 1, 1},
  {&__pyx_n_s_location, __pyx_k_location, sizeof(__pyx_k_location), 0, 0, 1, 1},
  {&__pyx_n_s_logger, __pyx_k_logger, sizeof(__pyx_k_logger), 0, 0, 1, 1},
  {&__pyx_n_s_logging, __pyx_k_logging, sizeof(__pyx_k_logging), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_manufacturerName, __pyx_k_manufacturerName, sizeof(__pyx_k_manufacturerName), 0, 0, 1, 1},
  {&__pyx_n_s_message, __pyx_k_message, sizeof(__pyx_k_message), 0, 0, 1, 1},
  {&__pyx_kp_s_message_complete, __pyx_k_message_complete, sizeof(__pyx_k_message_complete), 0, 0, 1, 0},
  {&__pyx_n_s_metaclass, __pyx_k_metaclass, sizeof(__pyx_k_metaclass), 0, 0, 1, 1},
  {&__pyx_n_s_milliseconds, __pyx_k_milliseconds, sizeof(__pyx_k_milliseconds), 0, 0, 1, 1},
  {&__pyx_n_s_minutes, __pyx_k_minutes, sizeof(__pyx_k_minutes), 0, 0, 1, 1},
  {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
  {&__pyx_n_s_msg, __pyx_k_msg, sizeof(__pyx_k_msg), 0, 0, 1, 1},
  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
  {&__pyx_n_s_netbusy, __pyx_k_netbusy, sizeof(__pyx_k_netbusy), 0, 0, 1, 1},
  {&__pyx_kp_s_new_node, __pyx_k_new_node, sizeof(__pyx_k_new_node), 0, 0, 1, 0},
  {&__pyx_n_s_noack, __pyx_k_noack, sizeof(__pyx_k_noack), 0, 0, 1, 1},
  {&__pyx_n_s_nodeId, __pyx_k_nodeId, sizeof(__pyx_k_nodeId), 0, 0, 1, 1},
  {&__pyx_kp_s_node_added, __pyx_k_node_added, sizeof(__pyx_k_node_added), 0, 0, 1, 0},
  {&__pyx_kp_s_node_event, __pyx_k_node_event, sizeof(__pyx_k_node_event), 0, 0, 1, 0},
  {&__pyx_kp_s_node_naming, __pyx_k_node_naming, sizeof(__pyx_k_node_naming), 0, 0, 1, 0},
  {&__pyx_kp_s_node_protocol_info, __pyx_k_node_protocol_info, sizeof(__pyx_k_node_protocol_info), 0, 0, 1, 0},
  {&__pyx_kp_s_node_queries_complete, __pyx_k_node_queries_complete, sizeof(__pyx_k_node_queries_complete), 0, 0, 1, 0},
  {&__pyx_kp_s_node_removed, __pyx_k_node_removed, sizeof(__pyx_k_node_removed), 0, 0, 1, 0},
  {&__pyx_n_s_nodeid, __pyx_k_nodeid, sizeof(__pyx_k_nodeid), 0, 0, 1, 1},
  {&__pyx_n_s_nondelivery, __pyx_k_nondelivery, sizeof(__pyx_k_nondelivery), 0, 0, 1, 1},
  {&__pyx_n_s_not_installed, __pyx_k_not_installed, sizeof(__pyx_k_not_installed), 0, 0, 1, 1},
  {&__pyx_kp_s_notif_callback_Notification_type, __pyx_k_notif_callback_Notification_type, sizeof(__pyx_k_notif_callback_Notification_type), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_call_callback_con, __pyx_k_notif_callback_call_callback_con, sizeof(__pyx_k_notif_callback_call_callback_con), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_end, __pyx_k_notif_callback_end, sizeof(__pyx_k_notif_callback_end), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_exception, __pyx_k_notif_callback_exception, sizeof(__pyx_k_notif_callback_exception), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_exception_Type_Co, __pyx_k_notif_callback_exception_Type_Co, sizeof(__pyx_k_notif_callback_exception_Type_Co), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_exception_Type_Cr, __pyx_k_notif_callback_exception_Type_Cr, sizeof(__pyx_k_notif_callback_exception_Type_Cr), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_exception_Type_Dr, __pyx_k_notif_callback_exception_Type_Dr, sizeof(__pyx_k_notif_callback_exception_Type_Dr), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_exception_Type_Dr_2, __pyx_k_notif_callback_exception_Type_Dr_2, sizeof(__pyx_k_notif_callback_exception_Type_Dr_2), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_exception_Type_Gr, __pyx_k_notif_callback_exception_Type_Gr, sizeof(__pyx_k_notif_callback_exception_Type_Gr), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_exception_Type_No, __pyx_k_notif_callback_exception_Type_No, sizeof(__pyx_k_notif_callback_exception_Type_No), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_exception_Type_No_2, __pyx_k_notif_callback_exception_Type_No_2, sizeof(__pyx_k_notif_callback_exception_Type_No_2), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_exception_Type_Sc, __pyx_k_notif_callback_exception_Type_Sc, sizeof(__pyx_k_notif_callback_exception_Type_Sc), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_exception_Type_Va, __pyx_k_notif_callback_exception_Type_Va, sizeof(__pyx_k_notif_callback_exception_Type_Va), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_exception_Type_Va_2, __pyx_k_notif_callback_exception_Type_Va_2, sizeof(__pyx_k_notif_callback_exception_Type_Va_2), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_exception_Type_Va_3, __pyx_k_notif_callback_exception_Type_Va_3, sizeof(__pyx_k_notif_callback_exception_Type_Va_3), 0, 0, 1, 0},
  {&__pyx_kp_s_notif_callback_new_notification, __pyx_k_notif_callback_new_notification, sizeof(__pyx_k_notif_callback_new_notification), 0, 0, 1, 0},
  {&__pyx_n_s_notificationCode, __pyx_k_notificationCode, sizeof(__pyx_k_notificationCode), 0, 0, 1, 1},
  {&__pyx_n_s_notificationType, __pyx_k_notificationType, sizeof(__pyx_k_notificationType), 0, 0, 1, 1},
  {&__pyx_kp_s_openzwave_config, __pyx_k_openzwave_config, sizeof(__pyx_k_openzwave_config), 0, 0, 1, 0},
  {&__pyx_kp_s_options_xml, __pyx_k_options_xml, sizeof(__pyx_k_options_xml), 0, 0, 1, 0},
  {&__pyx_n_s_os, __pyx_k_os, sizeof(__pyx_k_os), 0, 0, 1, 1},
  {&__pyx_n_s_param, __pyx_k_param, sizeof(__pyx_k_param), 0, 0, 1, 1},
  {&__pyx_n_s_path, __pyx_k_path, sizeof(__pyx_k_path), 0, 0, 1, 1},
  {&__pyx_n_s_pkg_resources, __pyx_k_pkg_resources, sizeof(__pyx_k_pkg_resources), 0, 0, 1, 1},
  {&__pyx_kp_s_polling_disabled, __pyx_k_polling_disabled, sizeof(__pyx_k_polling_disabled), 0, 0, 1, 0},
  {&__pyx_kp_s_polling_enabled, __pyx_k_polling_enabled, sizeof(__pyx_k_polling_enabled), 0, 0, 1, 0},
  {&__pyx_n_s_prepare, __pyx_k_prepare, sizeof(__pyx_k_prepare), 0, 0, 1, 1},
  {&__pyx_n_s_productName, __pyx_k_productName, sizeof(__pyx_k_productName), 0, 0, 1, 1},
  {&__pyx_kp_s_python_openzwave_ozw_config, __pyx_k_python_openzwave_ozw_config, sizeof(__pyx_k_python_openzwave_ozw_config), 0, 0, 1, 0},
  {&__pyx_kp_s_python_openzwave_version_s_s_s_s, __pyx_k_python_openzwave_version_s_s_s_s, sizeof(__pyx_k_python_openzwave_version_s_s_s_s), 0, 0, 1, 0},
  {&__pyx_n_s_pythonfunc, __pyx_k_pythonfunc, sizeof(__pyx_k_pythonfunc), 0, 0, 1, 1},
  {&__pyx_n_s_quality, __pyx_k_quality, sizeof(__pyx_k_quality), 0, 0, 1, 1},
  {&__pyx_n_s_qualname, __pyx_k_qualname, sizeof(__pyx_k_qualname), 0, 0, 1, 1},
  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
  {&__pyx_n_s_readAborts, __pyx_k_readAborts, sizeof(__pyx_k_readAborts), 0, 0, 1, 1},
  {&__pyx_n_s_readCnt, __pyx_k_readCnt, sizeof(__pyx_k_readCnt), 0, 0, 1, 1},
  {&__pyx_n_s_readOnly, __pyx_k_readOnly, sizeof(__pyx_k_readOnly), 0, 0, 1, 1},
  {&__pyx_n_s_receivedCnt, __pyx_k_receivedCnt, sizeof(__pyx_k_receivedCnt), 0, 0, 1, 1},
  {&__pyx_n_s_receivedDups, __pyx_k_receivedDups, sizeof(__pyx_k_receivedDups), 0, 0, 1, 1},
  {&__pyx_n_s_receivedTS, __pyx_k_receivedTS, sizeof(__pyx_k_receivedTS), 0, 0, 1, 1},
  {&__pyx_n_s_receivedUnsolicited, __pyx_k_receivedUnsolicited, sizeof(__pyx_k_receivedUnsolicited), 0, 0, 1, 1},
  {&__pyx_n_s_record, __pyx_k_record, sizeof(__pyx_k_record), 0, 0, 1, 1},
  {&__pyx_n_s_resource_filename, __pyx_k_resource_filename, sizeof(__pyx_k_resource_filename), 0, 0, 1, 1},
  {&__pyx_n_s_retries, __pyx_k_retries, sizeof(__pyx_k_retries), 0, 0, 1, 1},
  {&__pyx_n_s_routedbusy, __pyx_k_routedbusy, sizeof(__pyx_k_routedbusy), 0, 0, 1, 1},
  {&__pyx_n_s_sceneId, __pyx_k_sceneId, sizeof(__pyx_k_sceneId), 0, 0, 1, 1},
  {&__pyx_n_s_sceneid, __pyx_k_sceneid, sizeof(__pyx_k_sceneid), 0, 0, 1, 1},
  {&__pyx_n_s_self, __pyx_k_self, sizeof(__pyx_k_self), 0, 0, 1, 1},
  {&__pyx_n_s_sentCnt, __pyx_k_sentCnt, sizeof(__pyx_k_sentCnt), 0, 0, 1, 1},
  {&__pyx_n_s_sentFailed, __pyx_k_sentFailed, sizeof(__pyx_k_sentFailed), 0, 0, 1, 1},
  {&__pyx_n_s_sentTS, __pyx_k_sentTS, sizeof(__pyx_k_sentTS), 0, 0, 1, 1},
  {&__pyx_n_s_setDoc, __pyx_k_setDoc, sizeof(__pyx_k_setDoc), 0, 0, 1, 1},
  {&__pyx_n_s_setDocType, __pyx_k_setDocType, sizeof(__pyx_k_setDocType), 0, 0, 1, 1},
  {&__pyx_n_s_setback, __pyx_k_setback, sizeof(__pyx_k_setback), 0, 0, 1, 1},
  {&__pyx_kp_s_share_openzwave_config, __pyx_k_share_openzwave_config, sizeof(__pyx_k_share_openzwave_config), 0, 0, 1, 0},
  {&__pyx_n_s_shutil, __pyx_k_shutil, sizeof(__pyx_k_shutil), 0, 0, 1, 1},
  {&__pyx_n_s_six, __pyx_k_six, sizeof(__pyx_k_six), 0, 0, 1, 1},
  {&__pyx_n_s_siz, __pyx_k_siz, sizeof(__pyx_k_siz), 0, 0, 1, 1},
  {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
  {&__pyx_n_s_state, __pyx_k_state, sizeof(__pyx_k_state), 0, 0, 1, 1},
  {&__pyx_n_s_str, __pyx_k_str, sizeof(__pyx_k_str), 0, 0, 1, 1},
  {&__pyx_n_s_stype, __pyx_k_stype, sizeof(__pyx_k_stype), 0, 0, 1, 1},
  {&__pyx_n_s_sys, __pyx_k_sys, sizeof(__pyx_k_sys), 0, 0, 1, 1},
  {&__pyx_n_s_targetnodeid, __pyx_k_targetnodeid, sizeof(__pyx_k_targetnodeid), 0, 0, 1, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_n_s_type, __pyx_k_type, sizeof(__pyx_k_type), 0, 0, 1, 1},
  {&__pyx_n_s_unit, __pyx_k_unit, sizeof(__pyx_k_unit), 0, 0, 1, 1},
  {&__pyx_n_s_units, __pyx_k_units, sizeof(__pyx_k_units), 0, 0, 1, 1},
  {&__pyx_n_s_upNodeRoute, __pyx_k_upNodeRoute, sizeof(__pyx_k_upNodeRoute), 0, 0, 1, 1},
  {&__pyx_n_s_user_path, __pyx_k_user_path, sizeof(__pyx_k_user_path), 0, 0, 1, 1},
  {&__pyx_kp_s_usr, __pyx_k_usr, sizeof(__pyx_k_usr), 0, 0, 1, 0},
  {&__pyx_kp_s_usr_local, __pyx_k_usr_local, sizeof(__pyx_k_usr_local), 0, 0, 1, 0},
  {&__pyx_kp_s_usr_local_etc_openzwave, __pyx_k_usr_local_etc_openzwave, sizeof(__pyx_k_usr_local_etc_openzwave), 0, 0, 1, 0},
  {&__pyx_kp_s_utf_8, __pyx_k_utf_8, sizeof(__pyx_k_utf_8), 0, 0, 1, 0},
  {&__pyx_n_s_value, __pyx_k_value, sizeof(__pyx_k_value), 0, 0, 1, 1},
  {&__pyx_n_s_valueId, __pyx_k_valueId, sizeof(__pyx_k_valueId), 0, 0, 1, 1},
  {&__pyx_kp_s_value_added, __pyx_k_value_added, sizeof(__pyx_k_value_added), 0, 0, 1, 0},
  {&__pyx_kp_s_value_changed, __pyx_k_value_changed, sizeof(__pyx_k_value_changed), 0, 0, 1, 0},
  {&__pyx_kp_s_value_removed, __pyx_k_value_removed, sizeof(__pyx_k_value_removed), 0, 0, 1, 0},
  {&__pyx_n_s_verify, __pyx_k_verify, sizeof(__pyx_k_verify), 0, 0, 1, 1},
  {&__pyx_n_s_version, __pyx_k_version, sizeof(__pyx_k_version), 0, 0, 1, 1},
  {&__pyx_n_s_warning, __pyx_k_warning, sizeof(__pyx_k_warning), 0, 0, 1, 1},
  {&__pyx_n_s_warnings, __pyx_k_warnings, sizeof(__pyx_k_warnings), 0, 0, 1, 1},
  {&__pyx_n_s_writeCnt, __pyx_k_writeCnt, sizeof(__pyx_k_writeCnt), 0, 0, 1, 1},
  {&__pyx_kp_s_zwcfg_xsd, __pyx_k_zwcfg_xsd, sizeof(__pyx_k_zwcfg_xsd), 0, 0, 1, 0},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s_ImportError); if (!__pyx_builtin_ImportError) __PYX_ERR(0, 67, __pyx_L1_error)
  __pyx_builtin_AttributeError = __Pyx_GetBuiltinName(__pyx_n_s_AttributeError); if (!__pyx_builtin_AttributeError) __PYX_ERR(0, 99, __pyx_L1_error)
  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 403, __pyx_L1_error)
  __pyx_builtin_chr = __Pyx_GetBuiltinName(__pyx_n_s_chr); if (!__pyx_builtin_chr) __PYX_ERR(0, 404, __pyx_L1_error)
  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 4051, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "libopenzwave.pyx":106
 * cdef string str_to_cppstr(str s):
 *     if isinstance(s, unicode):
 *         b = s.encode('utf-8')             # <<<<<<<<<<<<<<
 *     else:
 *         b = s
 */
  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_utf_8); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 106, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple_);
  __Pyx_GIVEREF(__pyx_tuple_);

  /* "libopenzwave.pyx":113
 * cdef cstr_to_str(s):
 *     if six.PY3 and not isinstance(s, str):
 *         return s.decode('utf-8')             # <<<<<<<<<<<<<<
 *     elif six.PY3:
 *         return s
 */
  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_utf_8); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 113, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__2);
  __Pyx_GIVEREF(__pyx_tuple__2);

  /* "libopenzwave.pyx":118
 *     else:
 *         try:
 *             return s.encode('utf-8')             # <<<<<<<<<<<<<<
 *         except:
 *             try:
 */
  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_utf_8); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 118, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__3);
  __Pyx_GIVEREF(__pyx_tuple__3);

  /* "libopenzwave.pyx":121
 *         except:
 *             try:
 *                 return s.decode('utf-8')             # <<<<<<<<<<<<<<
 *             except:
 *                 return s
 */
  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_utf_8); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 121, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__4);
  __Pyx_GIVEREF(__pyx_tuple__4);

  /* "libopenzwave.pyx":490
 * 
 *     """
 *     logger.debug("notif_callback : new notification")             # <<<<<<<<<<<<<<
 *     cdef Notification* notification = <Notification*>_notification
 *     logger.debug("notif_callback : Notification type : %s, nodeId : %s", notification.GetType(), notification.GetNodeId())
 */
  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_new_notification); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(0, 490, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__7);
  __Pyx_GIVEREF(__pyx_tuple__7);

  /* "libopenzwave.pyx":499
 *             }
 *     except:
 *         logger.exception("notif_callback exception")             # <<<<<<<<<<<<<<
 *     if notification.GetType() == Type_Group:
 *         try:
 */
  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_exception); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(0, 499, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__8);
  __Pyx_GIVEREF(__pyx_tuple__8);

  /* "libopenzwave.pyx":504
 *             n['groupIdx'] = notification.GetGroupIdx()
 *         except:
 *             logger.exception("notif_callback exception Type_Group")             # <<<<<<<<<<<<<<
 *     elif notification.GetType() == Type_NodeEvent:
 *         try:
 */
  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_exception_Type_Gr); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 504, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__9);
  __Pyx_GIVEREF(__pyx_tuple__9);

  /* "libopenzwave.pyx":509
 *             n['event'] = notification.GetEvent()
 *         except:
 *             logger.exception("notif_callback exception Type_NodeEvent")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() == Type_Notification:
 */
  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_exception_Type_No); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 509, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__10);
  __Pyx_GIVEREF(__pyx_tuple__10);

  /* "libopenzwave.pyx":515
 *             n['notificationCode'] = notification.GetNotification()
 *         except:
 *             logger.exception("notif_callback exception Type_Notification")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() == Type_ControllerCommand:
 */
  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_exception_Type_No_2); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 515, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__11);
  __Pyx_GIVEREF(__pyx_tuple__11);

  /* "libopenzwave.pyx":529
 *             n['controllerErrorDoc'] = PyControllerError[error].doc
 *         except:
 *             logger.exception("notif_callback exception Type_ControllerCommand")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() in (Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff):
 */
  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_exception_Type_Co); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(0, 529, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__12);
  __Pyx_GIVEREF(__pyx_tuple__12);

  /* "libopenzwave.pyx":535
 *             n['buttonId'] = notification.GetButtonId()
 *         except:
 *             logger.exception("notif_callback exception Type_CreateButton, Type_DeleteButton, Type_ButtonOn, Type_ButtonOff")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() == Type_DriverRemoved:
 */
  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_exception_Type_Cr); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(0, 535, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__13);
  __Pyx_GIVEREF(__pyx_tuple__13);

  /* "libopenzwave.pyx":539
 *     elif notification.GetType() == Type_DriverRemoved:
 *         try:
 *             logger.debug("Notification : Type_DriverRemoved received : clean all valueids")             # <<<<<<<<<<<<<<
 *             values_map.empty()
 *         except:
 */
  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_Notification_Type_DriverRemoved); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(0, 539, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__14);
  __Pyx_GIVEREF(__pyx_tuple__14);

  /* "libopenzwave.pyx":542
 *             values_map.empty()
 *         except:
 *             logger.exception("notif_callback exception Type_DriverRemoved")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() == Type_DriverReset:
 */
  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_exception_Type_Dr); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(0, 542, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__15);
  __Pyx_GIVEREF(__pyx_tuple__15);

  /* "libopenzwave.pyx":546
 *     elif notification.GetType() == Type_DriverReset:
 *         try:
 *             logger.debug("Notification : Type_DriverReset received : clean all valueids")             # <<<<<<<<<<<<<<
 *             values_map.empty()
 *         except:
 */
  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_Notification_Type_DriverReset_re); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 546, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__16);
  __Pyx_GIVEREF(__pyx_tuple__16);

  /* "libopenzwave.pyx":549
 *             values_map.empty()
 *         except:
 *             logger.exception("notif_callback exception Type_DriverReset")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() == Type_SceneEvent:
 */
  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_exception_Type_Dr_2); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(0, 549, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__17);
  __Pyx_GIVEREF(__pyx_tuple__17);

  /* "libopenzwave.pyx":555
 *             n['sceneId'] = notification.GetSceneId()
 *         except:
 *             logger.exception("notif_callback exception Type_SceneEvent")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() in (Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed):
 */
  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_exception_Type_Sc); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 555, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__18);
  __Pyx_GIVEREF(__pyx_tuple__18);

  /* "libopenzwave.pyx":561
 *             addValueId(notification.GetValueID(), n)
 *         except:
 *             logger.exception("notif_callback exception Type_ValueAdded, Type_ValueChanged, Type_ValueRefreshed")             # <<<<<<<<<<<<<<
 *             raise
 *     elif notification.GetType() == Type_ValueRemoved:
 */
  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_exception_Type_Va); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(0, 561, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__19);
  __Pyx_GIVEREF(__pyx_tuple__19);

  /* "libopenzwave.pyx":567
 *             n['valueId'] = {'id' : notification.GetValueID().GetId()}
 *         except:
 *             logger.exception("notif_callback exception Type_ValueRemoved")             # <<<<<<<<<<<<<<
 *             raise
 *     #elif notification.GetType() in (Type_PollingEnabled, Type_PollingDisabled):
 */
  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_exception_Type_Va_2); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 567, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__20);
  __Pyx_GIVEREF(__pyx_tuple__20);

  /* "libopenzwave.pyx":572
 *     #    #Maybe we should enable/disable this
 *     #    addValueId(notification.GetValueID(), n)
 *     logger.debug("notif_callback : call callback context")             # <<<<<<<<<<<<<<
 *     (<object>_context)(n)
 *     if notification.GetType() == Type_ValueRemoved:
 */
  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_call_callback_con); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 572, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__21);
  __Pyx_GIVEREF(__pyx_tuple__21);

  /* "libopenzwave.pyx":578
 *             delValueId(notification.GetValueID(), n)
 *         except:
 *             logger.exception("notif_callback exception Type_ValueRemoved delete")             # <<<<<<<<<<<<<<
 *             raise
 *     logger.debug("notif_callback : end")
 */
  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_exception_Type_Va_3); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(0, 578, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__22);
  __Pyx_GIVEREF(__pyx_tuple__22);

  /* "libopenzwave.pyx":580
 *             logger.exception("notif_callback exception Type_ValueRemoved delete")
 *             raise
 *     logger.debug("notif_callback : end")             # <<<<<<<<<<<<<<
 * 
 * cdef void ctrl_callback(ControllerState _state, ControllerError _error, void* _context) with gil:
 */
  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_notif_callback_end); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(0, 580, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__23);
  __Pyx_GIVEREF(__pyx_tuple__23);

  /* "libopenzwave.pyx":606
 * 
 *     '''
 *     if os.path.isfile(os.path.join("/etc/openzwave/",'device_classes.xml')):             # <<<<<<<<<<<<<<
 *         #At first, check in /etc/openzwave
 *         return "/etc/openzwave/"
 */
  __pyx_tuple__24 = PyTuple_Pack(2, __pyx_kp_s_etc_openzwave, __pyx_kp_s_device_classes_xml); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(0, 606, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__24);
  __Pyx_GIVEREF(__pyx_tuple__24);

  /* "libopenzwave.pyx":609
 *         #At first, check in /etc/openzwave
 *         return "/etc/openzwave/"
 *     elif os.path.isfile(os.path.join("/usr/local/etc/openzwave/",'device_classes.xml')):             # <<<<<<<<<<<<<<
 *         #Next, check in /usr/local/etc/openzwave
 *         return "/usr/local/etc/openzwave/"
 */
  __pyx_tuple__25 = PyTuple_Pack(2, __pyx_kp_s_usr_local_etc_openzwave, __pyx_kp_s_device_classes_xml); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 609, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__25);
  __Pyx_GIVEREF(__pyx_tuple__25);

  /* "libopenzwave.pyx":617
 *         try:
 *             from pkg_resources import resource_filename
 *             dirn = resource_filename('python_openzwave.ozw_config', '__init__.py')             # <<<<<<<<<<<<<<
 *             dirn = os.path.dirname(dirn)
 *         except ImportError:
 */
  __pyx_tuple__26 = PyTuple_Pack(2, __pyx_kp_s_python_openzwave_ozw_config, __pyx_kp_s_init___py); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(0, 617, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__26);
  __Pyx_GIVEREF(__pyx_tuple__26);

  /* "libopenzwave.pyx":624
 *             #At first, check in /etc/openzwave
 *             return dirn
 *         elif os.path.isfile(os.path.join("openzwave/config",'device_classes.xml')):             # <<<<<<<<<<<<<<
 *             return os.path.abspath('openzwave/config')
 *         #For historical reasons.
 */
  __pyx_tuple__27 = PyTuple_Pack(2, __pyx_kp_s_openzwave_config, __pyx_kp_s_device_classes_xml); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 624, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__27);
  __Pyx_GIVEREF(__pyx_tuple__27);

  /* "libopenzwave.pyx":625
 *             return dirn
 *         elif os.path.isfile(os.path.join("openzwave/config",'device_classes.xml')):
 *             return os.path.abspath('openzwave/config')             # <<<<<<<<<<<<<<
 *         #For historical reasons.
 *         elif os.path.isdir(os.path.join("/usr",PY_OZWAVE_CONFIG_DIRECTORY)):
 */
  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_kp_s_openzwave_config); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(0, 625, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__28);
  __Pyx_GIVEREF(__pyx_tuple__28);

  /* "libopenzwave.pyx":672
 *             config_path = self.getConfigPath()
 *         if config_path is None:
 *             raise LibZWaveException("Can't autoconfigure path to config")             # <<<<<<<<<<<<<<
 *         if os.path.exists(config_path):
 *             if not os.path.exists(os.path.join(config_path, "zwcfg.xsd")):
 */
  __pyx_tuple__30 = PyTuple_Pack(1, __pyx_kp_s_Can_t_autoconfigure_path_to_conf); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(0, 672, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__30);
  __Pyx_GIVEREF(__pyx_tuple__30);

  /* "libopenzwave.pyx":4051
 *         self._watcherCallback = pythonfunc # need to keep a reference to this
 *         if not self.manager.AddWatcher(notif_callback, <void*>pythonfunc):
 *             raise ValueError("call to AddWatcher failed")             # <<<<<<<<<<<<<<
 * 
 *     def removeWatcher(self, pythonfunc):
 */
  __pyx_tuple__31 = PyTuple_Pack(1, __pyx_kp_s_call_to_AddWatcher_failed); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(0, 4051, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__31);
  __Pyx_GIVEREF(__pyx_tuple__31);

  /* "libopenzwave.pyx":4065
 *         '''
 *         if not self.manager.RemoveWatcher(notif_callback, <void*>self._watcherCallback):
 *             raise ValueError("call to RemoveWatcher failed")             # <<<<<<<<<<<<<<
 *         else:
 *             self._watcherCallback = None
 */
  __pyx_tuple__32 = PyTuple_Pack(1, __pyx_kp_s_call_to_RemoveWatcher_failed); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(0, 4065, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__32);
  __Pyx_GIVEREF(__pyx_tuple__32);

  /* "libopenzwave.pyx":70
 *     class NullHandler(logging.Handler):
 *         """NullHandler logger for python 2.6"""
 *         def emit(self, record):             # <<<<<<<<<<<<<<
 *             pass
 * logger = logging.getLogger('libopenzwave')
 */
  __pyx_tuple__33 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_record); if (unlikely(!__pyx_tuple__33)) __PYX_ERR(0, 70, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__33);
  __Pyx_GIVEREF(__pyx_tuple__33);
  __pyx_codeobj__34 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__33, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_sebastien_devel_python_ope, __pyx_n_s_emit, 70, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__34)) __PYX_ERR(0, 70, __pyx_L1_error)

  /* "libopenzwave.pyx":72
 *         def emit(self, record):
 *             pass
 * logger = logging.getLogger('libopenzwave')             # <<<<<<<<<<<<<<
 * logger.addHandler(NullHandler())
 * 
 */
  __pyx_tuple__35 = PyTuple_Pack(1, __pyx_n_s_libopenzwave); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 72, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__35);
  __Pyx_GIVEREF(__pyx_tuple__35);

  /* "libopenzwave.pyx":90
 * libopenzwave_file = 'not_installed'
 * try:
 *     _dist = get_distribution('libopenzwave')             # <<<<<<<<<<<<<<
 * except DistributionNotFound:
 *     pass
 */
  __pyx_tuple__36 = PyTuple_Pack(1, __pyx_n_s_libopenzwave); if (unlikely(!__pyx_tuple__36)) __PYX_ERR(0, 90, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__36);
  __Pyx_GIVEREF(__pyx_tuple__36);

  /* "libopenzwave.pyx":97
 * if libopenzwave_location == 'not_installed' :
 *    try:
 *         _dist = get_distribution('libopenzwave')             # <<<<<<<<<<<<<<
 *         libopenzwave_file = _dist.__file__
 *    except AttributeError:
 */
  __pyx_tuple__37 = PyTuple_Pack(1, __pyx_n_s_libopenzwave); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 97, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__37);
  __Pyx_GIVEREF(__pyx_tuple__37);

  /* "libopenzwave.pyx":129
 *     Exception class for LibOpenZWave
 *     """
 *     def __init__(self, value):             # <<<<<<<<<<<<<<
 *         Exception.__init__(self)
 *         self.msg = "LibOpenZwave Generic Exception"
 */
  __pyx_tuple__38 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_value); if (unlikely(!__pyx_tuple__38)) __PYX_ERR(0, 129, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__38);
  __Pyx_GIVEREF(__pyx_tuple__38);
  __pyx_codeobj__39 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__38, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_sebastien_devel_python_ope, __pyx_n_s_init, 129, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__39)) __PYX_ERR(0, 129, __pyx_L1_error)

  /* "libopenzwave.pyx":134
 *         self.value = value
 * 
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         return repr(self.msg+' : '+self.value)
 * 
 */
  __pyx_tuple__40 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__40)) __PYX_ERR(0, 134, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__40);
  __Pyx_GIVEREF(__pyx_tuple__40);
  __pyx_codeobj__41 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__40, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_sebastien_devel_python_ope, __pyx_n_s_str, 134, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__41)) __PYX_ERR(0, 134, __pyx_L1_error)

  /* "libopenzwave.pyx":165
 * class EnumWithDoc(str):
 *     """Enum helper"""
 *     def setDoc(self, doc):             # <<<<<<<<<<<<<<
 *         self.doc = doc
 *         return self
 */
  __pyx_tuple__42 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_doc); if (unlikely(!__pyx_tuple__42)) __PYX_ERR(0, 165, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__42);
  __Pyx_GIVEREF(__pyx_tuple__42);
  __pyx_codeobj__43 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__42, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_sebastien_devel_python_ope, __pyx_n_s_setDoc, 165, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__43)) __PYX_ERR(0, 165, __pyx_L1_error)

  /* "libopenzwave.pyx":170
 * 
 * PyNotifications = [
 *     EnumWithDoc('ValueAdded').setDoc("A new node value has been added to OpenZWave's set. These notifications occur after a node has been discovered, and details of its command classes have been received.  Each command class may generate one or more values depending on the complexity of the item being represented."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ValueRemoved').setDoc("A node value has been removed from OpenZWave's set.  This only occurs when a node is removed."),
 *     EnumWithDoc('ValueChanged').setDoc("A node value has been updated from the Z-Wave network and it is different from the previous value."),
 */
  __pyx_tuple__44 = PyTuple_Pack(1, __pyx_n_s_ValueAdded); if (unlikely(!__pyx_tuple__44)) __PYX_ERR(0, 170, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__44);
  __Pyx_GIVEREF(__pyx_tuple__44);
  __pyx_tuple__45 = PyTuple_Pack(1, __pyx_kp_s_A_new_node_value_has_been_added); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(0, 170, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__45);
  __Pyx_GIVEREF(__pyx_tuple__45);

  /* "libopenzwave.pyx":171
 * PyNotifications = [
 *     EnumWithDoc('ValueAdded').setDoc("A new node value has been added to OpenZWave's set. These notifications occur after a node has been discovered, and details of its command classes have been received.  Each command class may generate one or more values depending on the complexity of the item being represented."),
 *     EnumWithDoc('ValueRemoved').setDoc("A node value has been removed from OpenZWave's set.  This only occurs when a node is removed."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ValueChanged').setDoc("A node value has been updated from the Z-Wave network and it is different from the previous value."),
 *     EnumWithDoc('ValueRefreshed').setDoc("A node value has been updated from the Z-Wave network."),
 */
  __pyx_tuple__46 = PyTuple_Pack(1, __pyx_n_s_ValueRemoved); if (unlikely(!__pyx_tuple__46)) __PYX_ERR(0, 171, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__46);
  __Pyx_GIVEREF(__pyx_tuple__46);
  __pyx_tuple__47 = PyTuple_Pack(1, __pyx_kp_s_A_node_value_has_been_removed_fr); if (unlikely(!__pyx_tuple__47)) __PYX_ERR(0, 171, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__47);
  __Pyx_GIVEREF(__pyx_tuple__47);

  /* "libopenzwave.pyx":172
 *     EnumWithDoc('ValueAdded').setDoc("A new node value has been added to OpenZWave's set. These notifications occur after a node has been discovered, and details of its command classes have been received.  Each command class may generate one or more values depending on the complexity of the item being represented."),
 *     EnumWithDoc('ValueRemoved').setDoc("A node value has been removed from OpenZWave's set.  This only occurs when a node is removed."),
 *     EnumWithDoc('ValueChanged').setDoc("A node value has been updated from the Z-Wave network and it is different from the previous value."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ValueRefreshed').setDoc("A node value has been updated from the Z-Wave network."),
 *     EnumWithDoc('Group').setDoc("The associations for the node have changed. The application should rebuild any group information it holds about the node."),
 */
  __pyx_tuple__48 = PyTuple_Pack(1, __pyx_n_s_ValueChanged); if (unlikely(!__pyx_tuple__48)) __PYX_ERR(0, 172, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__48);
  __Pyx_GIVEREF(__pyx_tuple__48);
  __pyx_tuple__49 = PyTuple_Pack(1, __pyx_kp_s_A_node_value_has_been_updated_fr); if (unlikely(!__pyx_tuple__49)) __PYX_ERR(0, 172, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__49);
  __Pyx_GIVEREF(__pyx_tuple__49);

  /* "libopenzwave.pyx":173
 *     EnumWithDoc('ValueRemoved').setDoc("A node value has been removed from OpenZWave's set.  This only occurs when a node is removed."),
 *     EnumWithDoc('ValueChanged').setDoc("A node value has been updated from the Z-Wave network and it is different from the previous value."),
 *     EnumWithDoc('ValueRefreshed').setDoc("A node value has been updated from the Z-Wave network."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Group').setDoc("The associations for the node have changed. The application should rebuild any group information it holds about the node."),
 *     EnumWithDoc('NodeNew').setDoc("A new node has been found (not already stored in zwcfg*.xml file)."),
 */
  __pyx_tuple__50 = PyTuple_Pack(1, __pyx_n_s_ValueRefreshed); if (unlikely(!__pyx_tuple__50)) __PYX_ERR(0, 173, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__50);
  __Pyx_GIVEREF(__pyx_tuple__50);
  __pyx_tuple__51 = PyTuple_Pack(1, __pyx_kp_s_A_node_value_has_been_updated_fr_2); if (unlikely(!__pyx_tuple__51)) __PYX_ERR(0, 173, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__51);
  __Pyx_GIVEREF(__pyx_tuple__51);

  /* "libopenzwave.pyx":174
 *     EnumWithDoc('ValueChanged').setDoc("A node value has been updated from the Z-Wave network and it is different from the previous value."),
 *     EnumWithDoc('ValueRefreshed').setDoc("A node value has been updated from the Z-Wave network."),
 *     EnumWithDoc('Group').setDoc("The associations for the node have changed. The application should rebuild any group information it holds about the node."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeNew').setDoc("A new node has been found (not already stored in zwcfg*.xml file)."),
 *     EnumWithDoc('NodeAdded').setDoc("A new node has been added to OpenZWave's set.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself."),
 */
  __pyx_tuple__52 = PyTuple_Pack(1, __pyx_n_s_Group); if (unlikely(!__pyx_tuple__52)) __PYX_ERR(0, 174, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__52);
  __Pyx_GIVEREF(__pyx_tuple__52);
  __pyx_tuple__53 = PyTuple_Pack(1, __pyx_kp_s_The_associations_for_the_node_ha); if (unlikely(!__pyx_tuple__53)) __PYX_ERR(0, 174, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__53);
  __Pyx_GIVEREF(__pyx_tuple__53);

  /* "libopenzwave.pyx":175
 *     EnumWithDoc('ValueRefreshed').setDoc("A node value has been updated from the Z-Wave network."),
 *     EnumWithDoc('Group').setDoc("The associations for the node have changed. The application should rebuild any group information it holds about the node."),
 *     EnumWithDoc('NodeNew').setDoc("A new node has been found (not already stored in zwcfg*.xml file)."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeAdded').setDoc("A new node has been added to OpenZWave's set.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself."),
 *     EnumWithDoc('NodeRemoved').setDoc("A node has been removed from OpenZWave's set.  This may be due to a device being removed from the Z-Wave network, or because the application is closing."),
 */
  __pyx_tuple__54 = PyTuple_Pack(1, __pyx_n_s_NodeNew); if (unlikely(!__pyx_tuple__54)) __PYX_ERR(0, 175, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__54);
  __Pyx_GIVEREF(__pyx_tuple__54);
  __pyx_tuple__55 = PyTuple_Pack(1, __pyx_kp_s_A_new_node_has_been_found_not_al); if (unlikely(!__pyx_tuple__55)) __PYX_ERR(0, 175, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__55);
  __Pyx_GIVEREF(__pyx_tuple__55);

  /* "libopenzwave.pyx":176
 *     EnumWithDoc('Group').setDoc("The associations for the node have changed. The application should rebuild any group information it holds about the node."),
 *     EnumWithDoc('NodeNew').setDoc("A new node has been found (not already stored in zwcfg*.xml file)."),
 *     EnumWithDoc('NodeAdded').setDoc("A new node has been added to OpenZWave's set.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeRemoved').setDoc("A node has been removed from OpenZWave's set.  This may be due to a device being removed from the Z-Wave network, or because the application is closing."),
 *     EnumWithDoc('NodeProtocolInfo').setDoc("Basic node information has been receievd, such as whether the node is a setening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description."),
 */
  __pyx_tuple__56 = PyTuple_Pack(1, __pyx_n_s_NodeAdded); if (unlikely(!__pyx_tuple__56)) __PYX_ERR(0, 176, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__56);
  __Pyx_GIVEREF(__pyx_tuple__56);
  __pyx_tuple__57 = PyTuple_Pack(1, __pyx_kp_s_A_new_node_has_been_added_to_Ope); if (unlikely(!__pyx_tuple__57)) __PYX_ERR(0, 176, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__57);
  __Pyx_GIVEREF(__pyx_tuple__57);

  /* "libopenzwave.pyx":177
 *     EnumWithDoc('NodeNew').setDoc("A new node has been found (not already stored in zwcfg*.xml file)."),
 *     EnumWithDoc('NodeAdded').setDoc("A new node has been added to OpenZWave's set.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself."),
 *     EnumWithDoc('NodeRemoved').setDoc("A node has been removed from OpenZWave's set.  This may be due to a device being removed from the Z-Wave network, or because the application is closing."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeProtocolInfo').setDoc("Basic node information has been receievd, such as whether the node is a setening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description."),
 *     EnumWithDoc('NodeNaming').setDoc("One of the node names has changed (name, manufacturer, product)."),
 */
  __pyx_tuple__58 = PyTuple_Pack(1, __pyx_n_s_NodeRemoved); if (unlikely(!__pyx_tuple__58)) __PYX_ERR(0, 177, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__58);
  __Pyx_GIVEREF(__pyx_tuple__58);
  __pyx_tuple__59 = PyTuple_Pack(1, __pyx_kp_s_A_node_has_been_removed_from_Ope); if (unlikely(!__pyx_tuple__59)) __PYX_ERR(0, 177, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__59);
  __Pyx_GIVEREF(__pyx_tuple__59);

  /* "libopenzwave.pyx":178
 *     EnumWithDoc('NodeAdded').setDoc("A new node has been added to OpenZWave's set.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself."),
 *     EnumWithDoc('NodeRemoved').setDoc("A node has been removed from OpenZWave's set.  This may be due to a device being removed from the Z-Wave network, or because the application is closing."),
 *     EnumWithDoc('NodeProtocolInfo').setDoc("Basic node information has been receievd, such as whether the node is a setening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeNaming').setDoc("One of the node names has changed (name, manufacturer, product)."),
 *     EnumWithDoc('NodeEvent').setDoc("A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification."),
 */
  __pyx_tuple__60 = PyTuple_Pack(1, __pyx_n_s_NodeProtocolInfo); if (unlikely(!__pyx_tuple__60)) __PYX_ERR(0, 178, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__60);
  __Pyx_GIVEREF(__pyx_tuple__60);
  __pyx_tuple__61 = PyTuple_Pack(1, __pyx_kp_s_Basic_node_information_has_been); if (unlikely(!__pyx_tuple__61)) __PYX_ERR(0, 178, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__61);
  __Pyx_GIVEREF(__pyx_tuple__61);

  /* "libopenzwave.pyx":179
 *     EnumWithDoc('NodeRemoved').setDoc("A node has been removed from OpenZWave's set.  This may be due to a device being removed from the Z-Wave network, or because the application is closing."),
 *     EnumWithDoc('NodeProtocolInfo').setDoc("Basic node information has been receievd, such as whether the node is a setening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description."),
 *     EnumWithDoc('NodeNaming').setDoc("One of the node names has changed (name, manufacturer, product)."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeEvent').setDoc("A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification."),
 *     EnumWithDoc('PollingDisabled').setDoc("Polling of a node has been successfully turned off by a call to Manager::DisablePoll."),
 */
  __pyx_tuple__62 = PyTuple_Pack(1, __pyx_n_s_NodeNaming); if (unlikely(!__pyx_tuple__62)) __PYX_ERR(0, 179, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__62);
  __Pyx_GIVEREF(__pyx_tuple__62);
  __pyx_tuple__63 = PyTuple_Pack(1, __pyx_kp_s_One_of_the_node_names_has_change); if (unlikely(!__pyx_tuple__63)) __PYX_ERR(0, 179, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__63);
  __Pyx_GIVEREF(__pyx_tuple__63);

  /* "libopenzwave.pyx":180
 *     EnumWithDoc('NodeProtocolInfo').setDoc("Basic node information has been receievd, such as whether the node is a setening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description."),
 *     EnumWithDoc('NodeNaming').setDoc("One of the node names has changed (name, manufacturer, product)."),
 *     EnumWithDoc('NodeEvent').setDoc("A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('PollingDisabled').setDoc("Polling of a node has been successfully turned off by a call to Manager::DisablePoll."),
 *     EnumWithDoc('PollingEnabled').setDoc("Polling of a node has been successfully turned on by a call to Manager::EnablePoll."),
 */
  __pyx_tuple__64 = PyTuple_Pack(1, __pyx_n_s_NodeEvent); if (unlikely(!__pyx_tuple__64)) __PYX_ERR(0, 180, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__64);
  __Pyx_GIVEREF(__pyx_tuple__64);
  __pyx_tuple__65 = PyTuple_Pack(1, __pyx_kp_s_A_node_has_triggered_an_event_Th); if (unlikely(!__pyx_tuple__65)) __PYX_ERR(0, 180, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__65);
  __Pyx_GIVEREF(__pyx_tuple__65);

  /* "libopenzwave.pyx":181
 *     EnumWithDoc('NodeNaming').setDoc("One of the node names has changed (name, manufacturer, product)."),
 *     EnumWithDoc('NodeEvent').setDoc("A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification."),
 *     EnumWithDoc('PollingDisabled').setDoc("Polling of a node has been successfully turned off by a call to Manager::DisablePoll."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('PollingEnabled').setDoc("Polling of a node has been successfully turned on by a call to Manager::EnablePoll."),
 *     EnumWithDoc('SceneEvent').setDoc("Scene Activation Set received."),
 */
  __pyx_tuple__66 = PyTuple_Pack(1, __pyx_n_s_PollingDisabled); if (unlikely(!__pyx_tuple__66)) __PYX_ERR(0, 181, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__66);
  __Pyx_GIVEREF(__pyx_tuple__66);
  __pyx_tuple__67 = PyTuple_Pack(1, __pyx_kp_s_Polling_of_a_node_has_been_succe); if (unlikely(!__pyx_tuple__67)) __PYX_ERR(0, 181, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__67);
  __Pyx_GIVEREF(__pyx_tuple__67);

  /* "libopenzwave.pyx":182
 *     EnumWithDoc('NodeEvent').setDoc("A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification."),
 *     EnumWithDoc('PollingDisabled').setDoc("Polling of a node has been successfully turned off by a call to Manager::DisablePoll."),
 *     EnumWithDoc('PollingEnabled').setDoc("Polling of a node has been successfully turned on by a call to Manager::EnablePoll."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('SceneEvent').setDoc("Scene Activation Set received."),
 *     EnumWithDoc('CreateButton').setDoc("Handheld controller button event created."),
 */
  __pyx_tuple__68 = PyTuple_Pack(1, __pyx_n_s_PollingEnabled); if (unlikely(!__pyx_tuple__68)) __PYX_ERR(0, 182, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__68);
  __Pyx_GIVEREF(__pyx_tuple__68);
  __pyx_tuple__69 = PyTuple_Pack(1, __pyx_kp_s_Polling_of_a_node_has_been_succe_2); if (unlikely(!__pyx_tuple__69)) __PYX_ERR(0, 182, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__69);
  __Pyx_GIVEREF(__pyx_tuple__69);

  /* "libopenzwave.pyx":183
 *     EnumWithDoc('PollingDisabled').setDoc("Polling of a node has been successfully turned off by a call to Manager::DisablePoll."),
 *     EnumWithDoc('PollingEnabled').setDoc("Polling of a node has been successfully turned on by a call to Manager::EnablePoll."),
 *     EnumWithDoc('SceneEvent').setDoc("Scene Activation Set received."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('CreateButton').setDoc("Handheld controller button event created."),
 *     EnumWithDoc('DeleteButton').setDoc("Handheld controller button event deleted."),
 */
  __pyx_tuple__70 = PyTuple_Pack(1, __pyx_n_s_SceneEvent); if (unlikely(!__pyx_tuple__70)) __PYX_ERR(0, 183, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__70);
  __Pyx_GIVEREF(__pyx_tuple__70);
  __pyx_tuple__71 = PyTuple_Pack(1, __pyx_kp_s_Scene_Activation_Set_received); if (unlikely(!__pyx_tuple__71)) __PYX_ERR(0, 183, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__71);
  __Pyx_GIVEREF(__pyx_tuple__71);

  /* "libopenzwave.pyx":184
 *     EnumWithDoc('PollingEnabled').setDoc("Polling of a node has been successfully turned on by a call to Manager::EnablePoll."),
 *     EnumWithDoc('SceneEvent').setDoc("Scene Activation Set received."),
 *     EnumWithDoc('CreateButton').setDoc("Handheld controller button event created."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('DeleteButton').setDoc("Handheld controller button event deleted."),
 *     EnumWithDoc('ButtonOn').setDoc("Handheld controller button on pressed event."),
 */
  __pyx_tuple__72 = PyTuple_Pack(1, __pyx_n_s_CreateButton); if (unlikely(!__pyx_tuple__72)) __PYX_ERR(0, 184, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__72);
  __Pyx_GIVEREF(__pyx_tuple__72);
  __pyx_tuple__73 = PyTuple_Pack(1, __pyx_kp_s_Handheld_controller_button_event); if (unlikely(!__pyx_tuple__73)) __PYX_ERR(0, 184, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__73);
  __Pyx_GIVEREF(__pyx_tuple__73);

  /* "libopenzwave.pyx":185
 *     EnumWithDoc('SceneEvent').setDoc("Scene Activation Set received."),
 *     EnumWithDoc('CreateButton').setDoc("Handheld controller button event created."),
 *     EnumWithDoc('DeleteButton').setDoc("Handheld controller button event deleted."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ButtonOn').setDoc("Handheld controller button on pressed event."),
 *     EnumWithDoc('ButtonOff').setDoc("Handheld controller button off pressed event."),
 */
  __pyx_tuple__74 = PyTuple_Pack(1, __pyx_n_s_DeleteButton); if (unlikely(!__pyx_tuple__74)) __PYX_ERR(0, 185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__74);
  __Pyx_GIVEREF(__pyx_tuple__74);
  __pyx_tuple__75 = PyTuple_Pack(1, __pyx_kp_s_Handheld_controller_button_event_2); if (unlikely(!__pyx_tuple__75)) __PYX_ERR(0, 185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__75);
  __Pyx_GIVEREF(__pyx_tuple__75);

  /* "libopenzwave.pyx":186
 *     EnumWithDoc('CreateButton').setDoc("Handheld controller button event created."),
 *     EnumWithDoc('DeleteButton').setDoc("Handheld controller button event deleted."),
 *     EnumWithDoc('ButtonOn').setDoc("Handheld controller button on pressed event."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ButtonOff').setDoc("Handheld controller button off pressed event."),
 *     EnumWithDoc('DriverReady').setDoc("A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods."),
 */
  __pyx_tuple__76 = PyTuple_Pack(1, __pyx_n_s_ButtonOn); if (unlikely(!__pyx_tuple__76)) __PYX_ERR(0, 186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__76);
  __Pyx_GIVEREF(__pyx_tuple__76);
  __pyx_tuple__77 = PyTuple_Pack(1, __pyx_kp_s_Handheld_controller_button_on_pr); if (unlikely(!__pyx_tuple__77)) __PYX_ERR(0, 186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__77);
  __Pyx_GIVEREF(__pyx_tuple__77);

  /* "libopenzwave.pyx":187
 *     EnumWithDoc('DeleteButton').setDoc("Handheld controller button event deleted."),
 *     EnumWithDoc('ButtonOn').setDoc("Handheld controller button on pressed event."),
 *     EnumWithDoc('ButtonOff').setDoc("Handheld controller button off pressed event."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('DriverReady').setDoc("A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods."),
 *     EnumWithDoc('DriverFailed').setDoc("Driver failed to load."),
 */
  __pyx_tuple__78 = PyTuple_Pack(1, __pyx_n_s_ButtonOff); if (unlikely(!__pyx_tuple__78)) __PYX_ERR(0, 187, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__78);
  __Pyx_GIVEREF(__pyx_tuple__78);
  __pyx_tuple__79 = PyTuple_Pack(1, __pyx_kp_s_Handheld_controller_button_off_p); if (unlikely(!__pyx_tuple__79)) __PYX_ERR(0, 187, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__79);
  __Pyx_GIVEREF(__pyx_tuple__79);

  /* "libopenzwave.pyx":188
 *     EnumWithDoc('ButtonOn').setDoc("Handheld controller button on pressed event."),
 *     EnumWithDoc('ButtonOff').setDoc("Handheld controller button off pressed event."),
 *     EnumWithDoc('DriverReady').setDoc("A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('DriverFailed').setDoc("Driver failed to load."),
 *     EnumWithDoc('DriverReset').setDoc("All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications."),
 */
  __pyx_tuple__80 = PyTuple_Pack(1, __pyx_n_s_DriverReady); if (unlikely(!__pyx_tuple__80)) __PYX_ERR(0, 188, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__80);
  __Pyx_GIVEREF(__pyx_tuple__80);
  __pyx_tuple__81 = PyTuple_Pack(1, __pyx_kp_s_A_driver_for_a_PC_Z_Wave_control); if (unlikely(!__pyx_tuple__81)) __PYX_ERR(0, 188, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__81);
  __Pyx_GIVEREF(__pyx_tuple__81);

  /* "libopenzwave.pyx":189
 *     EnumWithDoc('ButtonOff').setDoc("Handheld controller button off pressed event."),
 *     EnumWithDoc('DriverReady').setDoc("A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods."),
 *     EnumWithDoc('DriverFailed').setDoc("Driver failed to load."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('DriverReset').setDoc("All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications."),
 *     EnumWithDoc('EssentialNodeQueriesComplete').setDoc("The queries on a node that are essential to its operation have been completed. The node can now handle incoming messages."),
 */
  __pyx_tuple__82 = PyTuple_Pack(1, __pyx_n_s_DriverFailed); if (unlikely(!__pyx_tuple__82)) __PYX_ERR(0, 189, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__82);
  __Pyx_GIVEREF(__pyx_tuple__82);
  __pyx_tuple__83 = PyTuple_Pack(1, __pyx_kp_s_Driver_failed_to_load); if (unlikely(!__pyx_tuple__83)) __PYX_ERR(0, 189, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__83);
  __Pyx_GIVEREF(__pyx_tuple__83);

  /* "libopenzwave.pyx":190
 *     EnumWithDoc('DriverReady').setDoc("A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods."),
 *     EnumWithDoc('DriverFailed').setDoc("Driver failed to load."),
 *     EnumWithDoc('DriverReset').setDoc("All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('EssentialNodeQueriesComplete').setDoc("The queries on a node that are essential to its operation have been completed. The node can now handle incoming messages."),
 *     EnumWithDoc('NodeQueriesComplete').setDoc("All the initialisation queries on a node have been completed."),
 */
  __pyx_tuple__84 = PyTuple_Pack(1, __pyx_n_s_DriverReset); if (unlikely(!__pyx_tuple__84)) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__84);
  __Pyx_GIVEREF(__pyx_tuple__84);
  __pyx_tuple__85 = PyTuple_Pack(1, __pyx_kp_s_All_nodes_and_values_for_this_dr); if (unlikely(!__pyx_tuple__85)) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__85);
  __Pyx_GIVEREF(__pyx_tuple__85);

  /* "libopenzwave.pyx":191
 *     EnumWithDoc('DriverFailed').setDoc("Driver failed to load."),
 *     EnumWithDoc('DriverReset').setDoc("All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications."),
 *     EnumWithDoc('EssentialNodeQueriesComplete').setDoc("The queries on a node that are essential to its operation have been completed. The node can now handle incoming messages."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeQueriesComplete').setDoc("All the initialisation queries on a node have been completed."),
 *     EnumWithDoc('AwakeNodesQueried').setDoc("All awake nodes have been queried, so client application can expected complete data for these nodes."),
 */
  __pyx_tuple__86 = PyTuple_Pack(1, __pyx_n_s_EssentialNodeQueriesComplete); if (unlikely(!__pyx_tuple__86)) __PYX_ERR(0, 191, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__86);
  __Pyx_GIVEREF(__pyx_tuple__86);
  __pyx_tuple__87 = PyTuple_Pack(1, __pyx_kp_s_The_queries_on_a_node_that_are_e); if (unlikely(!__pyx_tuple__87)) __PYX_ERR(0, 191, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__87);
  __Pyx_GIVEREF(__pyx_tuple__87);

  /* "libopenzwave.pyx":192
 *     EnumWithDoc('DriverReset').setDoc("All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications."),
 *     EnumWithDoc('EssentialNodeQueriesComplete').setDoc("The queries on a node that are essential to its operation have been completed. The node can now handle incoming messages."),
 *     EnumWithDoc('NodeQueriesComplete').setDoc("All the initialisation queries on a node have been completed."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('AwakeNodesQueried').setDoc("All awake nodes have been queried, so client application can expected complete data for these nodes."),
 *     EnumWithDoc('AllNodesQueriedSomeDead').setDoc("All nodes have been queried but some dead nodes found."),
 */
  __pyx_tuple__88 = PyTuple_Pack(1, __pyx_n_s_NodeQueriesComplete); if (unlikely(!__pyx_tuple__88)) __PYX_ERR(0, 192, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__88);
  __Pyx_GIVEREF(__pyx_tuple__88);
  __pyx_tuple__89 = PyTuple_Pack(1, __pyx_kp_s_All_the_initialisation_queries_o); if (unlikely(!__pyx_tuple__89)) __PYX_ERR(0, 192, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__89);
  __Pyx_GIVEREF(__pyx_tuple__89);

  /* "libopenzwave.pyx":193
 *     EnumWithDoc('EssentialNodeQueriesComplete').setDoc("The queries on a node that are essential to its operation have been completed. The node can now handle incoming messages."),
 *     EnumWithDoc('NodeQueriesComplete').setDoc("All the initialisation queries on a node have been completed."),
 *     EnumWithDoc('AwakeNodesQueried').setDoc("All awake nodes have been queried, so client application can expected complete data for these nodes."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('AllNodesQueriedSomeDead').setDoc("All nodes have been queried but some dead nodes found."),
 *     EnumWithDoc('AllNodesQueried').setDoc("All nodes have been queried, so client application can expected complete data."),
 */
  __pyx_tuple__90 = PyTuple_Pack(1, __pyx_n_s_AwakeNodesQueried); if (unlikely(!__pyx_tuple__90)) __PYX_ERR(0, 193, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__90);
  __Pyx_GIVEREF(__pyx_tuple__90);
  __pyx_tuple__91 = PyTuple_Pack(1, __pyx_kp_s_All_awake_nodes_have_been_querie); if (unlikely(!__pyx_tuple__91)) __PYX_ERR(0, 193, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__91);
  __Pyx_GIVEREF(__pyx_tuple__91);

  /* "libopenzwave.pyx":194
 *     EnumWithDoc('NodeQueriesComplete').setDoc("All the initialisation queries on a node have been completed."),
 *     EnumWithDoc('AwakeNodesQueried').setDoc("All awake nodes have been queried, so client application can expected complete data for these nodes."),
 *     EnumWithDoc('AllNodesQueriedSomeDead').setDoc("All nodes have been queried but some dead nodes found."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('AllNodesQueried').setDoc("All nodes have been queried, so client application can expected complete data."),
 *     EnumWithDoc('Notification').setDoc("A manager notification report."),
 */
  __pyx_tuple__92 = PyTuple_Pack(1, __pyx_n_s_AllNodesQueriedSomeDead); if (unlikely(!__pyx_tuple__92)) __PYX_ERR(0, 194, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__92);
  __Pyx_GIVEREF(__pyx_tuple__92);
  __pyx_tuple__93 = PyTuple_Pack(1, __pyx_kp_s_All_nodes_have_been_queried_but); if (unlikely(!__pyx_tuple__93)) __PYX_ERR(0, 194, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__93);
  __Pyx_GIVEREF(__pyx_tuple__93);

  /* "libopenzwave.pyx":195
 *     EnumWithDoc('AwakeNodesQueried').setDoc("All awake nodes have been queried, so client application can expected complete data for these nodes."),
 *     EnumWithDoc('AllNodesQueriedSomeDead').setDoc("All nodes have been queried but some dead nodes found."),
 *     EnumWithDoc('AllNodesQueried').setDoc("All nodes have been queried, so client application can expected complete data."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Notification').setDoc("A manager notification report."),
 *     EnumWithDoc('DriverRemoved').setDoc("The Driver is being removed."),
 */
  __pyx_tuple__94 = PyTuple_Pack(1, __pyx_n_s_AllNodesQueried); if (unlikely(!__pyx_tuple__94)) __PYX_ERR(0, 195, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__94);
  __Pyx_GIVEREF(__pyx_tuple__94);
  __pyx_tuple__95 = PyTuple_Pack(1, __pyx_kp_s_All_nodes_have_been_queried_so_c); if (unlikely(!__pyx_tuple__95)) __PYX_ERR(0, 195, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__95);
  __Pyx_GIVEREF(__pyx_tuple__95);

  /* "libopenzwave.pyx":196
 *     EnumWithDoc('AllNodesQueriedSomeDead').setDoc("All nodes have been queried but some dead nodes found."),
 *     EnumWithDoc('AllNodesQueried').setDoc("All nodes have been queried, so client application can expected complete data."),
 *     EnumWithDoc('Notification').setDoc("A manager notification report."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('DriverRemoved').setDoc("The Driver is being removed."),
 *     EnumWithDoc('ControllerCommand').setDoc("When Controller Commands are executed, Notifications of Success/Failure etc are communicated via this Notification."),
 */
  __pyx_tuple__96 = PyTuple_Pack(1, __pyx_n_s_Notification); if (unlikely(!__pyx_tuple__96)) __PYX_ERR(0, 196, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__96);
  __Pyx_GIVEREF(__pyx_tuple__96);
  __pyx_tuple__97 = PyTuple_Pack(1, __pyx_kp_s_A_manager_notification_report); if (unlikely(!__pyx_tuple__97)) __PYX_ERR(0, 196, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__97);
  __Pyx_GIVEREF(__pyx_tuple__97);

  /* "libopenzwave.pyx":197
 *     EnumWithDoc('AllNodesQueried').setDoc("All nodes have been queried, so client application can expected complete data."),
 *     EnumWithDoc('Notification').setDoc("A manager notification report."),
 *     EnumWithDoc('DriverRemoved').setDoc("The Driver is being removed."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ControllerCommand').setDoc("When Controller Commands are executed, Notifications of Success/Failure etc are communicated via this Notification."),
 *     EnumWithDoc('NodeReset').setDoc("A node has been reset from OpenZWave's set.  The Device has been reset and thus removed from the NodeList in OZW."),
 */
  __pyx_tuple__98 = PyTuple_Pack(1, __pyx_n_s_DriverRemoved); if (unlikely(!__pyx_tuple__98)) __PYX_ERR(0, 197, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__98);
  __Pyx_GIVEREF(__pyx_tuple__98);
  __pyx_tuple__99 = PyTuple_Pack(1, __pyx_kp_s_The_Driver_is_being_removed); if (unlikely(!__pyx_tuple__99)) __PYX_ERR(0, 197, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__99);
  __Pyx_GIVEREF(__pyx_tuple__99);

  /* "libopenzwave.pyx":198
 *     EnumWithDoc('Notification').setDoc("A manager notification report."),
 *     EnumWithDoc('DriverRemoved').setDoc("The Driver is being removed."),
 *     EnumWithDoc('ControllerCommand').setDoc("When Controller Commands are executed, Notifications of Success/Failure etc are communicated via this Notification."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeReset').setDoc("A node has been reset from OpenZWave's set.  The Device has been reset and thus removed from the NodeList in OZW."),
 *     ]
 */
  __pyx_tuple__100 = PyTuple_Pack(1, __pyx_n_s_ControllerCommand); if (unlikely(!__pyx_tuple__100)) __PYX_ERR(0, 198, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__100);
  __Pyx_GIVEREF(__pyx_tuple__100);
  __pyx_tuple__101 = PyTuple_Pack(1, __pyx_kp_s_When_Controller_Commands_are_exe); if (unlikely(!__pyx_tuple__101)) __PYX_ERR(0, 198, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__101);
  __Pyx_GIVEREF(__pyx_tuple__101);

  /* "libopenzwave.pyx":199
 *     EnumWithDoc('DriverRemoved').setDoc("The Driver is being removed."),
 *     EnumWithDoc('ControllerCommand').setDoc("When Controller Commands are executed, Notifications of Success/Failure etc are communicated via this Notification."),
 *     EnumWithDoc('NodeReset').setDoc("A node has been reset from OpenZWave's set.  The Device has been reset and thus removed from the NodeList in OZW."),             # <<<<<<<<<<<<<<
 *     ]
 * 
 */
  __pyx_tuple__102 = PyTuple_Pack(1, __pyx_n_s_NodeReset); if (unlikely(!__pyx_tuple__102)) __PYX_ERR(0, 199, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__102);
  __Pyx_GIVEREF(__pyx_tuple__102);
  __pyx_tuple__103 = PyTuple_Pack(1, __pyx_kp_s_A_node_has_been_reset_from_OpenZ); if (unlikely(!__pyx_tuple__103)) __PYX_ERR(0, 199, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__103);
  __Pyx_GIVEREF(__pyx_tuple__103);

  /* "libopenzwave.pyx":203
 * 
 * PyNotificationCodes = [
 *     EnumWithDoc('MsgComplete').setDoc("Completed messages."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Timeout').setDoc("Messages that timeout will send a Notification with this code."),
 *     EnumWithDoc('NoOperation').setDoc("Report on NoOperation message sent completion."),
 */
  __pyx_tuple__104 = PyTuple_Pack(1, __pyx_n_s_MsgComplete); if (unlikely(!__pyx_tuple__104)) __PYX_ERR(0, 203, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__104);
  __Pyx_GIVEREF(__pyx_tuple__104);
  __pyx_tuple__105 = PyTuple_Pack(1, __pyx_kp_s_Completed_messages); if (unlikely(!__pyx_tuple__105)) __PYX_ERR(0, 203, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__105);
  __Pyx_GIVEREF(__pyx_tuple__105);

  /* "libopenzwave.pyx":204
 * PyNotificationCodes = [
 *     EnumWithDoc('MsgComplete').setDoc("Completed messages."),
 *     EnumWithDoc('Timeout').setDoc("Messages that timeout will send a Notification with this code."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NoOperation').setDoc("Report on NoOperation message sent completion."),
 *     EnumWithDoc('Awake').setDoc("Report when a sleeping node wakes."),
 */
  __pyx_tuple__106 = PyTuple_Pack(1, __pyx_n_s_Timeout); if (unlikely(!__pyx_tuple__106)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__106);
  __Pyx_GIVEREF(__pyx_tuple__106);
  __pyx_tuple__107 = PyTuple_Pack(1, __pyx_kp_s_Messages_that_timeout_will_send); if (unlikely(!__pyx_tuple__107)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__107);
  __Pyx_GIVEREF(__pyx_tuple__107);

  /* "libopenzwave.pyx":205
 *     EnumWithDoc('MsgComplete').setDoc("Completed messages."),
 *     EnumWithDoc('Timeout').setDoc("Messages that timeout will send a Notification with this code."),
 *     EnumWithDoc('NoOperation').setDoc("Report on NoOperation message sent completion."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Awake').setDoc("Report when a sleeping node wakes."),
 *     EnumWithDoc('Sleep').setDoc("Report when a node goes to sleep."),
 */
  __pyx_tuple__108 = PyTuple_Pack(1, __pyx_n_s_NoOperation); if (unlikely(!__pyx_tuple__108)) __PYX_ERR(0, 205, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__108);
  __Pyx_GIVEREF(__pyx_tuple__108);
  __pyx_tuple__109 = PyTuple_Pack(1, __pyx_kp_s_Report_on_NoOperation_message_se); if (unlikely(!__pyx_tuple__109)) __PYX_ERR(0, 205, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__109);
  __Pyx_GIVEREF(__pyx_tuple__109);

  /* "libopenzwave.pyx":206
 *     EnumWithDoc('Timeout').setDoc("Messages that timeout will send a Notification with this code."),
 *     EnumWithDoc('NoOperation').setDoc("Report on NoOperation message sent completion."),
 *     EnumWithDoc('Awake').setDoc("Report when a sleeping node wakes."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Sleep').setDoc("Report when a node goes to sleep."),
 *     EnumWithDoc('Dead').setDoc("Report when a node is presumed dead."),
 */
  __pyx_tuple__110 = PyTuple_Pack(1, __pyx_n_s_Awake); if (unlikely(!__pyx_tuple__110)) __PYX_ERR(0, 206, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__110);
  __Pyx_GIVEREF(__pyx_tuple__110);
  __pyx_tuple__111 = PyTuple_Pack(1, __pyx_kp_s_Report_when_a_sleeping_node_wake); if (unlikely(!__pyx_tuple__111)) __PYX_ERR(0, 206, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__111);
  __Pyx_GIVEREF(__pyx_tuple__111);

  /* "libopenzwave.pyx":207
 *     EnumWithDoc('NoOperation').setDoc("Report on NoOperation message sent completion."),
 *     EnumWithDoc('Awake').setDoc("Report when a sleeping node wakes."),
 *     EnumWithDoc('Sleep').setDoc("Report when a node goes to sleep."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Dead').setDoc("Report when a node is presumed dead."),
 *     EnumWithDoc('Alive').setDoc("Report when a node is revived."),
 */
  __pyx_tuple__112 = PyTuple_Pack(1, __pyx_n_s_Sleep); if (unlikely(!__pyx_tuple__112)) __PYX_ERR(0, 207, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__112);
  __Pyx_GIVEREF(__pyx_tuple__112);
  __pyx_tuple__113 = PyTuple_Pack(1, __pyx_kp_s_Report_when_a_node_goes_to_sleep); if (unlikely(!__pyx_tuple__113)) __PYX_ERR(0, 207, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__113);
  __Pyx_GIVEREF(__pyx_tuple__113);

  /* "libopenzwave.pyx":208
 *     EnumWithDoc('Awake').setDoc("Report when a sleeping node wakes."),
 *     EnumWithDoc('Sleep').setDoc("Report when a node goes to sleep."),
 *     EnumWithDoc('Dead').setDoc("Report when a node is presumed dead."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Alive').setDoc("Report when a node is revived."),
 *     ]
 */
  __pyx_tuple__114 = PyTuple_Pack(1, __pyx_n_s_Dead); if (unlikely(!__pyx_tuple__114)) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__114);
  __Pyx_GIVEREF(__pyx_tuple__114);
  __pyx_tuple__115 = PyTuple_Pack(1, __pyx_kp_s_Report_when_a_node_is_presumed_d); if (unlikely(!__pyx_tuple__115)) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__115);
  __Pyx_GIVEREF(__pyx_tuple__115);

  /* "libopenzwave.pyx":209
 *     EnumWithDoc('Sleep').setDoc("Report when a node goes to sleep."),
 *     EnumWithDoc('Dead').setDoc("Report when a node is presumed dead."),
 *     EnumWithDoc('Alive').setDoc("Report when a node is revived."),             # <<<<<<<<<<<<<<
 *     ]
 * 
 */
  __pyx_tuple__116 = PyTuple_Pack(1, __pyx_n_s_Alive); if (unlikely(!__pyx_tuple__116)) __PYX_ERR(0, 209, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__116);
  __Pyx_GIVEREF(__pyx_tuple__116);
  __pyx_tuple__117 = PyTuple_Pack(1, __pyx_kp_s_Report_when_a_node_is_revived); if (unlikely(!__pyx_tuple__117)) __PYX_ERR(0, 209, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__117);
  __Pyx_GIVEREF(__pyx_tuple__117);

  /* "libopenzwave.pyx":213
 * 
 * PyGenres = [
 *     EnumWithDoc('Basic').setDoc("The 'level' as controlled by basic commands.  Usually duplicated by another command class."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('User').setDoc("Basic values an ordinary user would be interested in."),
 *     EnumWithDoc('Config').setDoc("Device-specific configuration parameters.  These cannot be automatically discovered via Z-Wave, and are usually described in the user manual instead."),
 */
  __pyx_tuple__118 = PyTuple_Pack(1, __pyx_n_s_Basic); if (unlikely(!__pyx_tuple__118)) __PYX_ERR(0, 213, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__118);
  __Pyx_GIVEREF(__pyx_tuple__118);
  __pyx_tuple__119 = PyTuple_Pack(1, __pyx_kp_s_The_level_as_controlled_by_basic); if (unlikely(!__pyx_tuple__119)) __PYX_ERR(0, 213, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__119);
  __Pyx_GIVEREF(__pyx_tuple__119);

  /* "libopenzwave.pyx":214
 * PyGenres = [
 *     EnumWithDoc('Basic').setDoc("The 'level' as controlled by basic commands.  Usually duplicated by another command class."),
 *     EnumWithDoc('User').setDoc("Basic values an ordinary user would be interested in."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Config').setDoc("Device-specific configuration parameters.  These cannot be automatically discovered via Z-Wave, and are usually described in the user manual instead."),
 *     EnumWithDoc('System').setDoc("Values of significance only to users who understand the Z-Wave protocol"),
 */
  __pyx_tuple__120 = PyTuple_Pack(1, __pyx_n_s_User); if (unlikely(!__pyx_tuple__120)) __PYX_ERR(0, 214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__120);
  __Pyx_GIVEREF(__pyx_tuple__120);
  __pyx_tuple__121 = PyTuple_Pack(1, __pyx_kp_s_Basic_values_an_ordinary_user_wo); if (unlikely(!__pyx_tuple__121)) __PYX_ERR(0, 214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__121);
  __Pyx_GIVEREF(__pyx_tuple__121);

  /* "libopenzwave.pyx":215
 *     EnumWithDoc('Basic').setDoc("The 'level' as controlled by basic commands.  Usually duplicated by another command class."),
 *     EnumWithDoc('User').setDoc("Basic values an ordinary user would be interested in."),
 *     EnumWithDoc('Config').setDoc("Device-specific configuration parameters.  These cannot be automatically discovered via Z-Wave, and are usually described in the user manual instead."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('System').setDoc("Values of significance only to users who understand the Z-Wave protocol"),
 *     ]
 */
  __pyx_tuple__122 = PyTuple_Pack(1, __pyx_n_s_Config); if (unlikely(!__pyx_tuple__122)) __PYX_ERR(0, 215, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__122);
  __Pyx_GIVEREF(__pyx_tuple__122);
  __pyx_tuple__123 = PyTuple_Pack(1, __pyx_kp_s_Device_specific_configuration_pa); if (unlikely(!__pyx_tuple__123)) __PYX_ERR(0, 215, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__123);
  __Pyx_GIVEREF(__pyx_tuple__123);

  /* "libopenzwave.pyx":216
 *     EnumWithDoc('User').setDoc("Basic values an ordinary user would be interested in."),
 *     EnumWithDoc('Config').setDoc("Device-specific configuration parameters.  These cannot be automatically discovered via Z-Wave, and are usually described in the user manual instead."),
 *     EnumWithDoc('System').setDoc("Values of significance only to users who understand the Z-Wave protocol"),             # <<<<<<<<<<<<<<
 *     ]
 * 
 */
  __pyx_tuple__124 = PyTuple_Pack(1, __pyx_n_s_System); if (unlikely(!__pyx_tuple__124)) __PYX_ERR(0, 216, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__124);
  __Pyx_GIVEREF(__pyx_tuple__124);
  __pyx_tuple__125 = PyTuple_Pack(1, __pyx_kp_s_Values_of_significance_only_to_u); if (unlikely(!__pyx_tuple__125)) __PYX_ERR(0, 216, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__125);
  __Pyx_GIVEREF(__pyx_tuple__125);

  /* "libopenzwave.pyx":220
 * 
 * PyValueTypes = [
 *     EnumWithDoc('Bool').setDoc("Boolean, true or false"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Byte').setDoc("8-bit unsigned value"),
 *     EnumWithDoc('Decimal').setDoc("Represents a non-integer value as a string, to avoid floating point accuracy issues."),
 */
  __pyx_tuple__126 = PyTuple_Pack(1, __pyx_n_s_Bool); if (unlikely(!__pyx_tuple__126)) __PYX_ERR(0, 220, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__126);
  __Pyx_GIVEREF(__pyx_tuple__126);
  __pyx_tuple__127 = PyTuple_Pack(1, __pyx_kp_s_Boolean_true_or_false); if (unlikely(!__pyx_tuple__127)) __PYX_ERR(0, 220, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__127);
  __Pyx_GIVEREF(__pyx_tuple__127);

  /* "libopenzwave.pyx":221
 * PyValueTypes = [
 *     EnumWithDoc('Bool').setDoc("Boolean, true or false"),
 *     EnumWithDoc('Byte').setDoc("8-bit unsigned value"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Decimal').setDoc("Represents a non-integer value as a string, to avoid floating point accuracy issues."),
 *     EnumWithDoc('Int').setDoc("32-bit signed value"),
 */
  __pyx_tuple__128 = PyTuple_Pack(1, __pyx_n_s_Byte); if (unlikely(!__pyx_tuple__128)) __PYX_ERR(0, 221, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__128);
  __Pyx_GIVEREF(__pyx_tuple__128);
  __pyx_tuple__129 = PyTuple_Pack(1, __pyx_kp_s_8_bit_unsigned_value); if (unlikely(!__pyx_tuple__129)) __PYX_ERR(0, 221, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__129);
  __Pyx_GIVEREF(__pyx_tuple__129);

  /* "libopenzwave.pyx":222
 *     EnumWithDoc('Bool').setDoc("Boolean, true or false"),
 *     EnumWithDoc('Byte').setDoc("8-bit unsigned value"),
 *     EnumWithDoc('Decimal').setDoc("Represents a non-integer value as a string, to avoid floating point accuracy issues."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Int').setDoc("32-bit signed value"),
 *     EnumWithDoc('List').setDoc("List from which one item can be selected"),
 */
  __pyx_tuple__130 = PyTuple_Pack(1, __pyx_n_s_Decimal); if (unlikely(!__pyx_tuple__130)) __PYX_ERR(0, 222, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__130);
  __Pyx_GIVEREF(__pyx_tuple__130);
  __pyx_tuple__131 = PyTuple_Pack(1, __pyx_kp_s_Represents_a_non_integer_value_a); if (unlikely(!__pyx_tuple__131)) __PYX_ERR(0, 222, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__131);
  __Pyx_GIVEREF(__pyx_tuple__131);

  /* "libopenzwave.pyx":223
 *     EnumWithDoc('Byte').setDoc("8-bit unsigned value"),
 *     EnumWithDoc('Decimal').setDoc("Represents a non-integer value as a string, to avoid floating point accuracy issues."),
 *     EnumWithDoc('Int').setDoc("32-bit signed value"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('List').setDoc("List from which one item can be selected"),
 *     EnumWithDoc('Schedule').setDoc("Complex type used with the Climate Control Schedule command class"),
 */
  __pyx_tuple__132 = PyTuple_Pack(1, __pyx_n_s_Int); if (unlikely(!__pyx_tuple__132)) __PYX_ERR(0, 223, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__132);
  __Pyx_GIVEREF(__pyx_tuple__132);
  __pyx_tuple__133 = PyTuple_Pack(1, __pyx_kp_s_32_bit_signed_value); if (unlikely(!__pyx_tuple__133)) __PYX_ERR(0, 223, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__133);
  __Pyx_GIVEREF(__pyx_tuple__133);

  /* "libopenzwave.pyx":224
 *     EnumWithDoc('Decimal').setDoc("Represents a non-integer value as a string, to avoid floating point accuracy issues."),
 *     EnumWithDoc('Int').setDoc("32-bit signed value"),
 *     EnumWithDoc('List').setDoc("List from which one item can be selected"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Schedule').setDoc("Complex type used with the Climate Control Schedule command class"),
 *     EnumWithDoc('Short').setDoc("16-bit signed value"),
 */
  __pyx_tuple__134 = PyTuple_Pack(1, __pyx_n_s_List); if (unlikely(!__pyx_tuple__134)) __PYX_ERR(0, 224, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__134);
  __Pyx_GIVEREF(__pyx_tuple__134);
  __pyx_tuple__135 = PyTuple_Pack(1, __pyx_kp_s_List_from_which_one_item_can_be); if (unlikely(!__pyx_tuple__135)) __PYX_ERR(0, 224, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__135);
  __Pyx_GIVEREF(__pyx_tuple__135);

  /* "libopenzwave.pyx":225
 *     EnumWithDoc('Int').setDoc("32-bit signed value"),
 *     EnumWithDoc('List').setDoc("List from which one item can be selected"),
 *     EnumWithDoc('Schedule').setDoc("Complex type used with the Climate Control Schedule command class"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Short').setDoc("16-bit signed value"),
 *     EnumWithDoc('String').setDoc("Text string"),
 */
  __pyx_tuple__136 = PyTuple_Pack(1, __pyx_n_s_Schedule); if (unlikely(!__pyx_tuple__136)) __PYX_ERR(0, 225, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__136);
  __Pyx_GIVEREF(__pyx_tuple__136);
  __pyx_tuple__137 = PyTuple_Pack(1, __pyx_kp_s_Complex_type_used_with_the_Clima); if (unlikely(!__pyx_tuple__137)) __PYX_ERR(0, 225, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__137);
  __Pyx_GIVEREF(__pyx_tuple__137);

  /* "libopenzwave.pyx":226
 *     EnumWithDoc('List').setDoc("List from which one item can be selected"),
 *     EnumWithDoc('Schedule').setDoc("Complex type used with the Climate Control Schedule command class"),
 *     EnumWithDoc('Short').setDoc("16-bit signed value"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('String').setDoc("Text string"),
 *     EnumWithDoc('Button').setDoc("A write-only value that is the equivalent of pressing a button to send a command to a device"),
 */
  __pyx_tuple__138 = PyTuple_Pack(1, __pyx_n_s_Short); if (unlikely(!__pyx_tuple__138)) __PYX_ERR(0, 226, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__138);
  __Pyx_GIVEREF(__pyx_tuple__138);
  __pyx_tuple__139 = PyTuple_Pack(1, __pyx_kp_s_16_bit_signed_value); if (unlikely(!__pyx_tuple__139)) __PYX_ERR(0, 226, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__139);
  __Pyx_GIVEREF(__pyx_tuple__139);

  /* "libopenzwave.pyx":227
 *     EnumWithDoc('Schedule').setDoc("Complex type used with the Climate Control Schedule command class"),
 *     EnumWithDoc('Short').setDoc("16-bit signed value"),
 *     EnumWithDoc('String').setDoc("Text string"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Button').setDoc("A write-only value that is the equivalent of pressing a button to send a command to a device"),
 *     EnumWithDoc('Raw').setDoc("Raw byte values"),
 */
  __pyx_tuple__140 = PyTuple_Pack(1, __pyx_n_s_String); if (unlikely(!__pyx_tuple__140)) __PYX_ERR(0, 227, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__140);
  __Pyx_GIVEREF(__pyx_tuple__140);
  __pyx_tuple__141 = PyTuple_Pack(1, __pyx_kp_s_Text_string); if (unlikely(!__pyx_tuple__141)) __PYX_ERR(0, 227, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__141);
  __Pyx_GIVEREF(__pyx_tuple__141);

  /* "libopenzwave.pyx":228
 *     EnumWithDoc('Short').setDoc("16-bit signed value"),
 *     EnumWithDoc('String').setDoc("Text string"),
 *     EnumWithDoc('Button').setDoc("A write-only value that is the equivalent of pressing a button to send a command to a device"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Raw').setDoc("Raw byte values"),
 *     ]
 */
  __pyx_tuple__142 = PyTuple_Pack(1, __pyx_n_s_Button); if (unlikely(!__pyx_tuple__142)) __PYX_ERR(0, 228, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__142);
  __Pyx_GIVEREF(__pyx_tuple__142);
  __pyx_tuple__143 = PyTuple_Pack(1, __pyx_kp_s_A_write_only_value_that_is_the_e); if (unlikely(!__pyx_tuple__143)) __PYX_ERR(0, 228, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__143);
  __Pyx_GIVEREF(__pyx_tuple__143);

  /* "libopenzwave.pyx":229
 *     EnumWithDoc('String').setDoc("Text string"),
 *     EnumWithDoc('Button').setDoc("A write-only value that is the equivalent of pressing a button to send a command to a device"),
 *     EnumWithDoc('Raw').setDoc("Raw byte values"),             # <<<<<<<<<<<<<<
 *     ]
 * 
 */
  __pyx_tuple__144 = PyTuple_Pack(1, __pyx_n_s_Raw); if (unlikely(!__pyx_tuple__144)) __PYX_ERR(0, 229, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__144);
  __Pyx_GIVEREF(__pyx_tuple__144);
  __pyx_tuple__145 = PyTuple_Pack(1, __pyx_kp_s_Raw_byte_values); if (unlikely(!__pyx_tuple__145)) __PYX_ERR(0, 229, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__145);
  __Pyx_GIVEREF(__pyx_tuple__145);

  /* "libopenzwave.pyx":233
 * 
 * PyControllerState = [
 *     EnumWithDoc('Normal').setDoc("No command in progress."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Starting').setDoc("The command is starting."),
 *     EnumWithDoc('Cancel').setDoc("The command was cancelled."),
 */
  __pyx_tuple__146 = PyTuple_Pack(1, __pyx_n_s_Normal); if (unlikely(!__pyx_tuple__146)) __PYX_ERR(0, 233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__146);
  __Pyx_GIVEREF(__pyx_tuple__146);
  __pyx_tuple__147 = PyTuple_Pack(1, __pyx_kp_s_No_command_in_progress); if (unlikely(!__pyx_tuple__147)) __PYX_ERR(0, 233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__147);
  __Pyx_GIVEREF(__pyx_tuple__147);

  /* "libopenzwave.pyx":234
 * PyControllerState = [
 *     EnumWithDoc('Normal').setDoc("No command in progress."),
 *     EnumWithDoc('Starting').setDoc("The command is starting."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Cancel').setDoc("The command was cancelled."),
 *     EnumWithDoc('Error').setDoc("Command invocation had error(s) and was aborted."),
 */
  __pyx_tuple__148 = PyTuple_Pack(1, __pyx_n_s_Starting); if (unlikely(!__pyx_tuple__148)) __PYX_ERR(0, 234, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__148);
  __Pyx_GIVEREF(__pyx_tuple__148);
  __pyx_tuple__149 = PyTuple_Pack(1, __pyx_kp_s_The_command_is_starting); if (unlikely(!__pyx_tuple__149)) __PYX_ERR(0, 234, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__149);
  __Pyx_GIVEREF(__pyx_tuple__149);

  /* "libopenzwave.pyx":235
 *     EnumWithDoc('Normal').setDoc("No command in progress."),
 *     EnumWithDoc('Starting').setDoc("The command is starting."),
 *     EnumWithDoc('Cancel').setDoc("The command was cancelled."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Error').setDoc("Command invocation had error(s) and was aborted."),
 *     EnumWithDoc('Waiting').setDoc("Controller is waiting for a user action."),
 */
  __pyx_tuple__150 = PyTuple_Pack(1, __pyx_n_s_Cancel); if (unlikely(!__pyx_tuple__150)) __PYX_ERR(0, 235, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__150);
  __Pyx_GIVEREF(__pyx_tuple__150);
  __pyx_tuple__151 = PyTuple_Pack(1, __pyx_kp_s_The_command_was_cancelled); if (unlikely(!__pyx_tuple__151)) __PYX_ERR(0, 235, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__151);
  __Pyx_GIVEREF(__pyx_tuple__151);

  /* "libopenzwave.pyx":236
 *     EnumWithDoc('Starting').setDoc("The command is starting."),
 *     EnumWithDoc('Cancel').setDoc("The command was cancelled."),
 *     EnumWithDoc('Error').setDoc("Command invocation had error(s) and was aborted."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Waiting').setDoc("Controller is waiting for a user action."),
 *     EnumWithDoc('Sleeping').setDoc("Controller command is on a sleep queue wait for device."),
 */
  __pyx_tuple__152 = PyTuple_Pack(1, __pyx_n_s_Error); if (unlikely(!__pyx_tuple__152)) __PYX_ERR(0, 236, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__152);
  __Pyx_GIVEREF(__pyx_tuple__152);
  __pyx_tuple__153 = PyTuple_Pack(1, __pyx_kp_s_Command_invocation_had_error_s_a); if (unlikely(!__pyx_tuple__153)) __PYX_ERR(0, 236, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__153);
  __Pyx_GIVEREF(__pyx_tuple__153);

  /* "libopenzwave.pyx":237
 *     EnumWithDoc('Cancel').setDoc("The command was cancelled."),
 *     EnumWithDoc('Error').setDoc("Command invocation had error(s) and was aborted."),
 *     EnumWithDoc('Waiting').setDoc("Controller is waiting for a user action."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Sleeping').setDoc("Controller command is on a sleep queue wait for device."),
 *     EnumWithDoc('InProgress').setDoc("The controller is communicating with the other device to carry out the command."),
 */
  __pyx_tuple__154 = PyTuple_Pack(1, __pyx_n_s_Waiting); if (unlikely(!__pyx_tuple__154)) __PYX_ERR(0, 237, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__154);
  __Pyx_GIVEREF(__pyx_tuple__154);
  __pyx_tuple__155 = PyTuple_Pack(1, __pyx_kp_s_Controller_is_waiting_for_a_user); if (unlikely(!__pyx_tuple__155)) __PYX_ERR(0, 237, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__155);
  __Pyx_GIVEREF(__pyx_tuple__155);

  /* "libopenzwave.pyx":238
 *     EnumWithDoc('Error').setDoc("Command invocation had error(s) and was aborted."),
 *     EnumWithDoc('Waiting').setDoc("Controller is waiting for a user action."),
 *     EnumWithDoc('Sleeping').setDoc("Controller command is on a sleep queue wait for device."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('InProgress').setDoc("The controller is communicating with the other device to carry out the command."),
 *     EnumWithDoc('Completed').setDoc("The command has completed successfully."),
 */
  __pyx_tuple__156 = PyTuple_Pack(1, __pyx_n_s_Sleeping); if (unlikely(!__pyx_tuple__156)) __PYX_ERR(0, 238, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__156);
  __Pyx_GIVEREF(__pyx_tuple__156);
  __pyx_tuple__157 = PyTuple_Pack(1, __pyx_kp_s_Controller_command_is_on_a_sleep); if (unlikely(!__pyx_tuple__157)) __PYX_ERR(0, 238, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__157);
  __Pyx_GIVEREF(__pyx_tuple__157);

  /* "libopenzwave.pyx":239
 *     EnumWithDoc('Waiting').setDoc("Controller is waiting for a user action."),
 *     EnumWithDoc('Sleeping').setDoc("Controller command is on a sleep queue wait for device."),
 *     EnumWithDoc('InProgress').setDoc("The controller is communicating with the other device to carry out the command."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Completed').setDoc("The command has completed successfully."),
 *     EnumWithDoc('Failed').setDoc("The command has failed."),
 */
  __pyx_tuple__158 = PyTuple_Pack(1, __pyx_n_s_InProgress); if (unlikely(!__pyx_tuple__158)) __PYX_ERR(0, 239, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__158);
  __Pyx_GIVEREF(__pyx_tuple__158);
  __pyx_tuple__159 = PyTuple_Pack(1, __pyx_kp_s_The_controller_is_communicating); if (unlikely(!__pyx_tuple__159)) __PYX_ERR(0, 239, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__159);
  __Pyx_GIVEREF(__pyx_tuple__159);

  /* "libopenzwave.pyx":240
 *     EnumWithDoc('Sleeping').setDoc("Controller command is on a sleep queue wait for device."),
 *     EnumWithDoc('InProgress').setDoc("The controller is communicating with the other device to carry out the command."),
 *     EnumWithDoc('Completed').setDoc("The command has completed successfully."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Failed').setDoc("The command has failed."),
 *     EnumWithDoc('NodeOK').setDoc("Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node is OK."),
 */
  __pyx_tuple__160 = PyTuple_Pack(1, __pyx_n_s_Completed); if (unlikely(!__pyx_tuple__160)) __PYX_ERR(0, 240, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__160);
  __Pyx_GIVEREF(__pyx_tuple__160);
  __pyx_tuple__161 = PyTuple_Pack(1, __pyx_kp_s_The_command_has_completed_succes); if (unlikely(!__pyx_tuple__161)) __PYX_ERR(0, 240, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__161);
  __Pyx_GIVEREF(__pyx_tuple__161);

  /* "libopenzwave.pyx":241
 *     EnumWithDoc('InProgress').setDoc("The controller is communicating with the other device to carry out the command."),
 *     EnumWithDoc('Completed').setDoc("The command has completed successfully."),
 *     EnumWithDoc('Failed').setDoc("The command has failed."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeOK').setDoc("Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node is OK."),
 *     EnumWithDoc('NodeFailed').setDoc("Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node has failed."),
 */
  __pyx_tuple__162 = PyTuple_Pack(1, __pyx_n_s_Failed); if (unlikely(!__pyx_tuple__162)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__162);
  __Pyx_GIVEREF(__pyx_tuple__162);
  __pyx_tuple__163 = PyTuple_Pack(1, __pyx_kp_s_The_command_has_failed); if (unlikely(!__pyx_tuple__163)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__163);
  __Pyx_GIVEREF(__pyx_tuple__163);

  /* "libopenzwave.pyx":242
 *     EnumWithDoc('Completed').setDoc("The command has completed successfully."),
 *     EnumWithDoc('Failed').setDoc("The command has failed."),
 *     EnumWithDoc('NodeOK').setDoc("Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node is OK."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeFailed').setDoc("Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node has failed."),
 *     ]
 */
  __pyx_tuple__164 = PyTuple_Pack(1, __pyx_n_s_NodeOK); if (unlikely(!__pyx_tuple__164)) __PYX_ERR(0, 242, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__164);
  __Pyx_GIVEREF(__pyx_tuple__164);
  __pyx_tuple__165 = PyTuple_Pack(1, __pyx_kp_s_Used_only_with_ControllerCommand); if (unlikely(!__pyx_tuple__165)) __PYX_ERR(0, 242, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__165);
  __Pyx_GIVEREF(__pyx_tuple__165);

  /* "libopenzwave.pyx":243
 *     EnumWithDoc('Failed').setDoc("The command has failed."),
 *     EnumWithDoc('NodeOK').setDoc("Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node is OK."),
 *     EnumWithDoc('NodeFailed').setDoc("Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node has failed."),             # <<<<<<<<<<<<<<
 *     ]
 * 
 */
  __pyx_tuple__166 = PyTuple_Pack(1, __pyx_n_s_NodeFailed); if (unlikely(!__pyx_tuple__166)) __PYX_ERR(0, 243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__166);
  __Pyx_GIVEREF(__pyx_tuple__166);
  __pyx_tuple__167 = PyTuple_Pack(1, __pyx_kp_s_Used_only_with_ControllerCommand_2); if (unlikely(!__pyx_tuple__167)) __PYX_ERR(0, 243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__167);
  __Pyx_GIVEREF(__pyx_tuple__167);

  /* "libopenzwave.pyx":247
 * 
 * PyControllerCommand = [
 *     EnumWithDoc('None').setDoc("No command."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('AddDevice').setDoc("Add a new device (but not a controller) to the Z-Wave network."),
 *     EnumWithDoc('CreateNewPrimary').setDoc("Add a new controller to the Z-Wave network.  The new controller will be the primary, and the current primary will become a secondary controller."),
 */
  __pyx_tuple__168 = PyTuple_Pack(1, __pyx_n_s_None); if (unlikely(!__pyx_tuple__168)) __PYX_ERR(0, 247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__168);
  __Pyx_GIVEREF(__pyx_tuple__168);
  __pyx_tuple__169 = PyTuple_Pack(1, __pyx_kp_s_No_command); if (unlikely(!__pyx_tuple__169)) __PYX_ERR(0, 247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__169);
  __Pyx_GIVEREF(__pyx_tuple__169);

  /* "libopenzwave.pyx":248
 * PyControllerCommand = [
 *     EnumWithDoc('None').setDoc("No command."),
 *     EnumWithDoc('AddDevice').setDoc("Add a new device (but not a controller) to the Z-Wave network."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('CreateNewPrimary').setDoc("Add a new controller to the Z-Wave network.  The new controller will be the primary, and the current primary will become a secondary controller."),
 *     EnumWithDoc('ReceiveConfiguration').setDoc("Receive Z-Wave network configuration information from another controller."),
 */
  __pyx_tuple__170 = PyTuple_Pack(1, __pyx_n_s_AddDevice); if (unlikely(!__pyx_tuple__170)) __PYX_ERR(0, 248, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__170);
  __Pyx_GIVEREF(__pyx_tuple__170);
  __pyx_tuple__171 = PyTuple_Pack(1, __pyx_kp_s_Add_a_new_device_but_not_a_contr); if (unlikely(!__pyx_tuple__171)) __PYX_ERR(0, 248, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__171);
  __Pyx_GIVEREF(__pyx_tuple__171);

  /* "libopenzwave.pyx":249
 *     EnumWithDoc('None').setDoc("No command."),
 *     EnumWithDoc('AddDevice').setDoc("Add a new device (but not a controller) to the Z-Wave network."),
 *     EnumWithDoc('CreateNewPrimary').setDoc("Add a new controller to the Z-Wave network.  The new controller will be the primary, and the current primary will become a secondary controller."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ReceiveConfiguration').setDoc("Receive Z-Wave network configuration information from another controller."),
 *     EnumWithDoc('RemoveDevice').setDoc("Remove a new device (but not a controller) from the Z-Wave network."),
 */
  __pyx_tuple__172 = PyTuple_Pack(1, __pyx_n_s_CreateNewPrimary); if (unlikely(!__pyx_tuple__172)) __PYX_ERR(0, 249, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__172);
  __Pyx_GIVEREF(__pyx_tuple__172);
  __pyx_tuple__173 = PyTuple_Pack(1, __pyx_kp_s_Add_a_new_controller_to_the_Z_Wa); if (unlikely(!__pyx_tuple__173)) __PYX_ERR(0, 249, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__173);
  __Pyx_GIVEREF(__pyx_tuple__173);

  /* "libopenzwave.pyx":250
 *     EnumWithDoc('AddDevice').setDoc("Add a new device (but not a controller) to the Z-Wave network."),
 *     EnumWithDoc('CreateNewPrimary').setDoc("Add a new controller to the Z-Wave network.  The new controller will be the primary, and the current primary will become a secondary controller."),
 *     EnumWithDoc('ReceiveConfiguration').setDoc("Receive Z-Wave network configuration information from another controller."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('RemoveDevice').setDoc("Remove a new device (but not a controller) from the Z-Wave network."),
 *     EnumWithDoc('RemoveFailedNode').setDoc("Move a node to the controller's failed nodes list. This command will only work if the node cannot respond."),
 */
  __pyx_tuple__174 = PyTuple_Pack(1, __pyx_n_s_ReceiveConfiguration); if (unlikely(!__pyx_tuple__174)) __PYX_ERR(0, 250, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__174);
  __Pyx_GIVEREF(__pyx_tuple__174);
  __pyx_tuple__175 = PyTuple_Pack(1, __pyx_kp_s_Receive_Z_Wave_network_configura); if (unlikely(!__pyx_tuple__175)) __PYX_ERR(0, 250, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__175);
  __Pyx_GIVEREF(__pyx_tuple__175);

  /* "libopenzwave.pyx":251
 *     EnumWithDoc('CreateNewPrimary').setDoc("Add a new controller to the Z-Wave network.  The new controller will be the primary, and the current primary will become a secondary controller."),
 *     EnumWithDoc('ReceiveConfiguration').setDoc("Receive Z-Wave network configuration information from another controller."),
 *     EnumWithDoc('RemoveDevice').setDoc("Remove a new device (but not a controller) from the Z-Wave network."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('RemoveFailedNode').setDoc("Move a node to the controller's failed nodes list. This command will only work if the node cannot respond."),
 *     EnumWithDoc('HasNodeFailed').setDoc("Check whether a node is in the controller's failed nodes list."),
 */
  __pyx_tuple__176 = PyTuple_Pack(1, __pyx_n_s_RemoveDevice); if (unlikely(!__pyx_tuple__176)) __PYX_ERR(0, 251, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__176);
  __Pyx_GIVEREF(__pyx_tuple__176);
  __pyx_tuple__177 = PyTuple_Pack(1, __pyx_kp_s_Remove_a_new_device_but_not_a_co); if (unlikely(!__pyx_tuple__177)) __PYX_ERR(0, 251, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__177);
  __Pyx_GIVEREF(__pyx_tuple__177);

  /* "libopenzwave.pyx":252
 *     EnumWithDoc('ReceiveConfiguration').setDoc("Receive Z-Wave network configuration information from another controller."),
 *     EnumWithDoc('RemoveDevice').setDoc("Remove a new device (but not a controller) from the Z-Wave network."),
 *     EnumWithDoc('RemoveFailedNode').setDoc("Move a node to the controller's failed nodes list. This command will only work if the node cannot respond."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('HasNodeFailed').setDoc("Check whether a node is in the controller's failed nodes list."),
 *     EnumWithDoc('ReplaceFailedNode').setDoc("Replace a non-responding node with another. The node must be in the controller's list of failed nodes for this command to succeed."),
 */
  __pyx_tuple__178 = PyTuple_Pack(1, __pyx_n_s_RemoveFailedNode); if (unlikely(!__pyx_tuple__178)) __PYX_ERR(0, 252, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__178);
  __Pyx_GIVEREF(__pyx_tuple__178);
  __pyx_tuple__179 = PyTuple_Pack(1, __pyx_kp_s_Move_a_node_to_the_controller_s); if (unlikely(!__pyx_tuple__179)) __PYX_ERR(0, 252, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__179);
  __Pyx_GIVEREF(__pyx_tuple__179);

  /* "libopenzwave.pyx":253
 *     EnumWithDoc('RemoveDevice').setDoc("Remove a new device (but not a controller) from the Z-Wave network."),
 *     EnumWithDoc('RemoveFailedNode').setDoc("Move a node to the controller's failed nodes list. This command will only work if the node cannot respond."),
 *     EnumWithDoc('HasNodeFailed').setDoc("Check whether a node is in the controller's failed nodes list."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ReplaceFailedNode').setDoc("Replace a non-responding node with another. The node must be in the controller's list of failed nodes for this command to succeed."),
 *     EnumWithDoc('TransferPrimaryRole').setDoc("Make a different controller the primary."),
 */
  __pyx_tuple__180 = PyTuple_Pack(1, __pyx_n_s_HasNodeFailed); if (unlikely(!__pyx_tuple__180)) __PYX_ERR(0, 253, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__180);
  __Pyx_GIVEREF(__pyx_tuple__180);
  __pyx_tuple__181 = PyTuple_Pack(1, __pyx_kp_s_Check_whether_a_node_is_in_the_c); if (unlikely(!__pyx_tuple__181)) __PYX_ERR(0, 253, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__181);
  __Pyx_GIVEREF(__pyx_tuple__181);

  /* "libopenzwave.pyx":254
 *     EnumWithDoc('RemoveFailedNode').setDoc("Move a node to the controller's failed nodes list. This command will only work if the node cannot respond."),
 *     EnumWithDoc('HasNodeFailed').setDoc("Check whether a node is in the controller's failed nodes list."),
 *     EnumWithDoc('ReplaceFailedNode').setDoc("Replace a non-responding node with another. The node must be in the controller's list of failed nodes for this command to succeed."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('TransferPrimaryRole').setDoc("Make a different controller the primary."),
 *     EnumWithDoc('RequestNetworkUpdate').setDoc("Request network information from the SUC/SIS."),
 */
  __pyx_tuple__182 = PyTuple_Pack(1, __pyx_n_s_ReplaceFailedNode); if (unlikely(!__pyx_tuple__182)) __PYX_ERR(0, 254, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__182);
  __Pyx_GIVEREF(__pyx_tuple__182);
  __pyx_tuple__183 = PyTuple_Pack(1, __pyx_kp_s_Replace_a_non_responding_node_wi); if (unlikely(!__pyx_tuple__183)) __PYX_ERR(0, 254, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__183);
  __Pyx_GIVEREF(__pyx_tuple__183);

  /* "libopenzwave.pyx":255
 *     EnumWithDoc('HasNodeFailed').setDoc("Check whether a node is in the controller's failed nodes list."),
 *     EnumWithDoc('ReplaceFailedNode').setDoc("Replace a non-responding node with another. The node must be in the controller's list of failed nodes for this command to succeed."),
 *     EnumWithDoc('TransferPrimaryRole').setDoc("Make a different controller the primary."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('RequestNetworkUpdate').setDoc("Request network information from the SUC/SIS."),
 *     EnumWithDoc('RequestNodeNeighborUpdate').setDoc("Get a node to rebuild its neighbour list.  This method also does ControllerCommand_RequestNodeNeighbors."),
 */
  __pyx_tuple__184 = PyTuple_Pack(1, __pyx_n_s_TransferPrimaryRole); if (unlikely(!__pyx_tuple__184)) __PYX_ERR(0, 255, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__184);
  __Pyx_GIVEREF(__pyx_tuple__184);
  __pyx_tuple__185 = PyTuple_Pack(1, __pyx_kp_s_Make_a_different_controller_the); if (unlikely(!__pyx_tuple__185)) __PYX_ERR(0, 255, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__185);
  __Pyx_GIVEREF(__pyx_tuple__185);

  /* "libopenzwave.pyx":256
 *     EnumWithDoc('ReplaceFailedNode').setDoc("Replace a non-responding node with another. The node must be in the controller's list of failed nodes for this command to succeed."),
 *     EnumWithDoc('TransferPrimaryRole').setDoc("Make a different controller the primary."),
 *     EnumWithDoc('RequestNetworkUpdate').setDoc("Request network information from the SUC/SIS."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('RequestNodeNeighborUpdate').setDoc("Get a node to rebuild its neighbour list.  This method also does ControllerCommand_RequestNodeNeighbors."),
 *     EnumWithDoc('AssignReturnRoute').setDoc("Assign a network return routes to a device."),
 */
  __pyx_tuple__186 = PyTuple_Pack(1, __pyx_n_s_RequestNetworkUpdate); if (unlikely(!__pyx_tuple__186)) __PYX_ERR(0, 256, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__186);
  __Pyx_GIVEREF(__pyx_tuple__186);
  __pyx_tuple__187 = PyTuple_Pack(1, __pyx_kp_s_Request_network_information_from); if (unlikely(!__pyx_tuple__187)) __PYX_ERR(0, 256, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__187);
  __Pyx_GIVEREF(__pyx_tuple__187);

  /* "libopenzwave.pyx":257
 *     EnumWithDoc('TransferPrimaryRole').setDoc("Make a different controller the primary."),
 *     EnumWithDoc('RequestNetworkUpdate').setDoc("Request network information from the SUC/SIS."),
 *     EnumWithDoc('RequestNodeNeighborUpdate').setDoc("Get a node to rebuild its neighbour list.  This method also does ControllerCommand_RequestNodeNeighbors."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('AssignReturnRoute').setDoc("Assign a network return routes to a device."),
 *     EnumWithDoc('DeleteAllReturnRoutes').setDoc("Delete all return routes from a device."),
 */
  __pyx_tuple__188 = PyTuple_Pack(1, __pyx_n_s_RequestNodeNeighborUpdate); if (unlikely(!__pyx_tuple__188)) __PYX_ERR(0, 257, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__188);
  __Pyx_GIVEREF(__pyx_tuple__188);
  __pyx_tuple__189 = PyTuple_Pack(1, __pyx_kp_s_Get_a_node_to_rebuild_its_neighb); if (unlikely(!__pyx_tuple__189)) __PYX_ERR(0, 257, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__189);
  __Pyx_GIVEREF(__pyx_tuple__189);

  /* "libopenzwave.pyx":258
 *     EnumWithDoc('RequestNetworkUpdate').setDoc("Request network information from the SUC/SIS."),
 *     EnumWithDoc('RequestNodeNeighborUpdate').setDoc("Get a node to rebuild its neighbour list.  This method also does ControllerCommand_RequestNodeNeighbors."),
 *     EnumWithDoc('AssignReturnRoute').setDoc("Assign a network return routes to a device."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('DeleteAllReturnRoutes').setDoc("Delete all return routes from a device."),
 *     EnumWithDoc('SendNodeInformation').setDoc("Send a node information frame."),
 */
  __pyx_tuple__190 = PyTuple_Pack(1, __pyx_n_s_AssignReturnRoute); if (unlikely(!__pyx_tuple__190)) __PYX_ERR(0, 258, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__190);
  __Pyx_GIVEREF(__pyx_tuple__190);
  __pyx_tuple__191 = PyTuple_Pack(1, __pyx_kp_s_Assign_a_network_return_routes_t); if (unlikely(!__pyx_tuple__191)) __PYX_ERR(0, 258, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__191);
  __Pyx_GIVEREF(__pyx_tuple__191);

  /* "libopenzwave.pyx":259
 *     EnumWithDoc('RequestNodeNeighborUpdate').setDoc("Get a node to rebuild its neighbour list.  This method also does ControllerCommand_RequestNodeNeighbors."),
 *     EnumWithDoc('AssignReturnRoute').setDoc("Assign a network return routes to a device."),
 *     EnumWithDoc('DeleteAllReturnRoutes').setDoc("Delete all return routes from a device."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('SendNodeInformation').setDoc("Send a node information frame."),
 *     EnumWithDoc('ReplicationSend').setDoc("Send information from primary to secondary."),
 */
  __pyx_tuple__192 = PyTuple_Pack(1, __pyx_n_s_DeleteAllReturnRoutes); if (unlikely(!__pyx_tuple__192)) __PYX_ERR(0, 259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__192);
  __Pyx_GIVEREF(__pyx_tuple__192);
  __pyx_tuple__193 = PyTuple_Pack(1, __pyx_kp_s_Delete_all_return_routes_from_a); if (unlikely(!__pyx_tuple__193)) __PYX_ERR(0, 259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__193);
  __Pyx_GIVEREF(__pyx_tuple__193);

  /* "libopenzwave.pyx":260
 *     EnumWithDoc('AssignReturnRoute').setDoc("Assign a network return routes to a device."),
 *     EnumWithDoc('DeleteAllReturnRoutes').setDoc("Delete all return routes from a device."),
 *     EnumWithDoc('SendNodeInformation').setDoc("Send a node information frame."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ReplicationSend').setDoc("Send information from primary to secondary."),
 *     EnumWithDoc('CreateButton').setDoc("Create an id that tracks handheld button presses."),
 */
  __pyx_tuple__194 = PyTuple_Pack(1, __pyx_n_s_SendNodeInformation); if (unlikely(!__pyx_tuple__194)) __PYX_ERR(0, 260, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__194);
  __Pyx_GIVEREF(__pyx_tuple__194);
  __pyx_tuple__195 = PyTuple_Pack(1, __pyx_kp_s_Send_a_node_information_frame); if (unlikely(!__pyx_tuple__195)) __PYX_ERR(0, 260, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__195);
  __Pyx_GIVEREF(__pyx_tuple__195);

  /* "libopenzwave.pyx":261
 *     EnumWithDoc('DeleteAllReturnRoutes').setDoc("Delete all return routes from a device."),
 *     EnumWithDoc('SendNodeInformation').setDoc("Send a node information frame."),
 *     EnumWithDoc('ReplicationSend').setDoc("Send information from primary to secondary."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('CreateButton').setDoc("Create an id that tracks handheld button presses."),
 *     EnumWithDoc('DeleteButton').setDoc("Delete id that tracks handheld button presses."),
 */
  __pyx_tuple__196 = PyTuple_Pack(1, __pyx_n_s_ReplicationSend); if (unlikely(!__pyx_tuple__196)) __PYX_ERR(0, 261, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__196);
  __Pyx_GIVEREF(__pyx_tuple__196);
  __pyx_tuple__197 = PyTuple_Pack(1, __pyx_kp_s_Send_information_from_primary_to); if (unlikely(!__pyx_tuple__197)) __PYX_ERR(0, 261, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__197);
  __Pyx_GIVEREF(__pyx_tuple__197);

  /* "libopenzwave.pyx":262
 *     EnumWithDoc('SendNodeInformation').setDoc("Send a node information frame."),
 *     EnumWithDoc('ReplicationSend').setDoc("Send information from primary to secondary."),
 *     EnumWithDoc('CreateButton').setDoc("Create an id that tracks handheld button presses."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('DeleteButton').setDoc("Delete id that tracks handheld button presses."),
 *     ]
 */
  __pyx_tuple__198 = PyTuple_Pack(1, __pyx_n_s_CreateButton); if (unlikely(!__pyx_tuple__198)) __PYX_ERR(0, 262, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__198);
  __Pyx_GIVEREF(__pyx_tuple__198);
  __pyx_tuple__199 = PyTuple_Pack(1, __pyx_kp_s_Create_an_id_that_tracks_handhel); if (unlikely(!__pyx_tuple__199)) __PYX_ERR(0, 262, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__199);
  __Pyx_GIVEREF(__pyx_tuple__199);

  /* "libopenzwave.pyx":263
 *     EnumWithDoc('ReplicationSend').setDoc("Send information from primary to secondary."),
 *     EnumWithDoc('CreateButton').setDoc("Create an id that tracks handheld button presses."),
 *     EnumWithDoc('DeleteButton').setDoc("Delete id that tracks handheld button presses."),             # <<<<<<<<<<<<<<
 *     ]
 * 
 */
  __pyx_tuple__200 = PyTuple_Pack(1, __pyx_n_s_DeleteButton); if (unlikely(!__pyx_tuple__200)) __PYX_ERR(0, 263, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__200);
  __Pyx_GIVEREF(__pyx_tuple__200);
  __pyx_tuple__201 = PyTuple_Pack(1, __pyx_kp_s_Delete_id_that_tracks_handheld_b); if (unlikely(!__pyx_tuple__201)) __PYX_ERR(0, 263, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__201);
  __Pyx_GIVEREF(__pyx_tuple__201);

  /* "libopenzwave.pyx":267
 * 
 * PyControllerError = [
 *     EnumWithDoc('None').setDoc("None."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ButtonNotFound').setDoc("Button."),
 *     EnumWithDoc('NodeNotFound').setDoc("Button."),
 */
  __pyx_tuple__202 = PyTuple_Pack(1, __pyx_n_s_None); if (unlikely(!__pyx_tuple__202)) __PYX_ERR(0, 267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__202);
  __Pyx_GIVEREF(__pyx_tuple__202);
  __pyx_tuple__203 = PyTuple_Pack(1, __pyx_kp_s_None_2); if (unlikely(!__pyx_tuple__203)) __PYX_ERR(0, 267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__203);
  __Pyx_GIVEREF(__pyx_tuple__203);

  /* "libopenzwave.pyx":268
 * PyControllerError = [
 *     EnumWithDoc('None').setDoc("None."),
 *     EnumWithDoc('ButtonNotFound').setDoc("Button."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeNotFound').setDoc("Button."),
 *     EnumWithDoc('NotBridge').setDoc("Button."),
 */
  __pyx_tuple__204 = PyTuple_Pack(1, __pyx_n_s_ButtonNotFound); if (unlikely(!__pyx_tuple__204)) __PYX_ERR(0, 268, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__204);
  __Pyx_GIVEREF(__pyx_tuple__204);
  __pyx_tuple__205 = PyTuple_Pack(1, __pyx_kp_s_Button_2); if (unlikely(!__pyx_tuple__205)) __PYX_ERR(0, 268, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__205);
  __Pyx_GIVEREF(__pyx_tuple__205);

  /* "libopenzwave.pyx":269
 *     EnumWithDoc('None').setDoc("None."),
 *     EnumWithDoc('ButtonNotFound').setDoc("Button."),
 *     EnumWithDoc('NodeNotFound').setDoc("Button."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NotBridge').setDoc("Button."),
 *     EnumWithDoc('NotSUC').setDoc("CreateNewPrimary."),
 */
  __pyx_tuple__206 = PyTuple_Pack(1, __pyx_n_s_NodeNotFound); if (unlikely(!__pyx_tuple__206)) __PYX_ERR(0, 269, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__206);
  __Pyx_GIVEREF(__pyx_tuple__206);
  __pyx_tuple__207 = PyTuple_Pack(1, __pyx_kp_s_Button_2); if (unlikely(!__pyx_tuple__207)) __PYX_ERR(0, 269, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__207);
  __Pyx_GIVEREF(__pyx_tuple__207);

  /* "libopenzwave.pyx":270
 *     EnumWithDoc('ButtonNotFound').setDoc("Button."),
 *     EnumWithDoc('NodeNotFound').setDoc("Button."),
 *     EnumWithDoc('NotBridge').setDoc("Button."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NotSUC').setDoc("CreateNewPrimary."),
 *     EnumWithDoc('NotSecondary').setDoc("CreateNewPrimary."),
 */
  __pyx_tuple__208 = PyTuple_Pack(1, __pyx_n_s_NotBridge); if (unlikely(!__pyx_tuple__208)) __PYX_ERR(0, 270, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__208);
  __Pyx_GIVEREF(__pyx_tuple__208);
  __pyx_tuple__209 = PyTuple_Pack(1, __pyx_kp_s_Button_2); if (unlikely(!__pyx_tuple__209)) __PYX_ERR(0, 270, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__209);
  __Pyx_GIVEREF(__pyx_tuple__209);

  /* "libopenzwave.pyx":271
 *     EnumWithDoc('NodeNotFound').setDoc("Button."),
 *     EnumWithDoc('NotBridge').setDoc("Button."),
 *     EnumWithDoc('NotSUC').setDoc("CreateNewPrimary."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NotSecondary').setDoc("CreateNewPrimary."),
 *     EnumWithDoc('NotPrimary').setDoc("RemoveFailedNode, AddNodeToNetwork."),
 */
  __pyx_tuple__210 = PyTuple_Pack(1, __pyx_n_s_NotSUC); if (unlikely(!__pyx_tuple__210)) __PYX_ERR(0, 271, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__210);
  __Pyx_GIVEREF(__pyx_tuple__210);
  __pyx_tuple__211 = PyTuple_Pack(1, __pyx_kp_s_CreateNewPrimary_2); if (unlikely(!__pyx_tuple__211)) __PYX_ERR(0, 271, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__211);
  __Pyx_GIVEREF(__pyx_tuple__211);

  /* "libopenzwave.pyx":272
 *     EnumWithDoc('NotBridge').setDoc("Button."),
 *     EnumWithDoc('NotSUC').setDoc("CreateNewPrimary."),
 *     EnumWithDoc('NotSecondary').setDoc("CreateNewPrimary."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NotPrimary').setDoc("RemoveFailedNode, AddNodeToNetwork."),
 *     EnumWithDoc('IsPrimary').setDoc("ReceiveConfiguration."),
 */
  __pyx_tuple__212 = PyTuple_Pack(1, __pyx_n_s_NotSecondary); if (unlikely(!__pyx_tuple__212)) __PYX_ERR(0, 272, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__212);
  __Pyx_GIVEREF(__pyx_tuple__212);
  __pyx_tuple__213 = PyTuple_Pack(1, __pyx_kp_s_CreateNewPrimary_2); if (unlikely(!__pyx_tuple__213)) __PYX_ERR(0, 272, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__213);
  __Pyx_GIVEREF(__pyx_tuple__213);

  /* "libopenzwave.pyx":273
 *     EnumWithDoc('NotSUC').setDoc("CreateNewPrimary."),
 *     EnumWithDoc('NotSecondary').setDoc("CreateNewPrimary."),
 *     EnumWithDoc('NotPrimary').setDoc("RemoveFailedNode, AddNodeToNetwork."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('IsPrimary').setDoc("ReceiveConfiguration."),
 *     EnumWithDoc('NotFound').setDoc("RemoveFailedNode."),
 */
  __pyx_tuple__214 = PyTuple_Pack(1, __pyx_n_s_NotPrimary); if (unlikely(!__pyx_tuple__214)) __PYX_ERR(0, 273, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__214);
  __Pyx_GIVEREF(__pyx_tuple__214);
  __pyx_tuple__215 = PyTuple_Pack(1, __pyx_kp_s_RemoveFailedNode_AddNodeToNetwor); if (unlikely(!__pyx_tuple__215)) __PYX_ERR(0, 273, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__215);
  __Pyx_GIVEREF(__pyx_tuple__215);

  /* "libopenzwave.pyx":274
 *     EnumWithDoc('NotSecondary').setDoc("CreateNewPrimary."),
 *     EnumWithDoc('NotPrimary').setDoc("RemoveFailedNode, AddNodeToNetwork."),
 *     EnumWithDoc('IsPrimary').setDoc("ReceiveConfiguration."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NotFound').setDoc("RemoveFailedNode."),
 *     EnumWithDoc('Busy').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 */
  __pyx_tuple__216 = PyTuple_Pack(1, __pyx_n_s_IsPrimary); if (unlikely(!__pyx_tuple__216)) __PYX_ERR(0, 274, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__216);
  __Pyx_GIVEREF(__pyx_tuple__216);
  __pyx_tuple__217 = PyTuple_Pack(1, __pyx_kp_s_ReceiveConfiguration_2); if (unlikely(!__pyx_tuple__217)) __PYX_ERR(0, 274, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__217);
  __Pyx_GIVEREF(__pyx_tuple__217);

  /* "libopenzwave.pyx":275
 *     EnumWithDoc('NotPrimary').setDoc("RemoveFailedNode, AddNodeToNetwork."),
 *     EnumWithDoc('IsPrimary').setDoc("ReceiveConfiguration."),
 *     EnumWithDoc('NotFound').setDoc("RemoveFailedNode."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Busy').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 *     EnumWithDoc('Failed').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 */
  __pyx_tuple__218 = PyTuple_Pack(1, __pyx_n_s_NotFound); if (unlikely(!__pyx_tuple__218)) __PYX_ERR(0, 275, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__218);
  __Pyx_GIVEREF(__pyx_tuple__218);
  __pyx_tuple__219 = PyTuple_Pack(1, __pyx_kp_s_RemoveFailedNode_2); if (unlikely(!__pyx_tuple__219)) __PYX_ERR(0, 275, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__219);
  __Pyx_GIVEREF(__pyx_tuple__219);

  /* "libopenzwave.pyx":276
 *     EnumWithDoc('IsPrimary').setDoc("ReceiveConfiguration."),
 *     EnumWithDoc('NotFound').setDoc("RemoveFailedNode."),
 *     EnumWithDoc('Busy').setDoc("RemoveFailedNode, RequestNetworkUpdate."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Failed').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 *     EnumWithDoc('Disabled').setDoc("RequestNetworkUpdate error."),
 */
  __pyx_tuple__220 = PyTuple_Pack(1, __pyx_n_s_Busy); if (unlikely(!__pyx_tuple__220)) __PYX_ERR(0, 276, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__220);
  __Pyx_GIVEREF(__pyx_tuple__220);
  __pyx_tuple__221 = PyTuple_Pack(1, __pyx_kp_s_RemoveFailedNode_RequestNetworkU); if (unlikely(!__pyx_tuple__221)) __PYX_ERR(0, 276, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__221);
  __Pyx_GIVEREF(__pyx_tuple__221);

  /* "libopenzwave.pyx":277
 *     EnumWithDoc('NotFound').setDoc("RemoveFailedNode."),
 *     EnumWithDoc('Busy').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 *     EnumWithDoc('Failed').setDoc("RemoveFailedNode, RequestNetworkUpdate."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Disabled').setDoc("RequestNetworkUpdate error."),
 *     EnumWithDoc('Overflow').setDoc("RequestNetworkUpdate error."),
 */
  __pyx_tuple__222 = PyTuple_Pack(1, __pyx_n_s_Failed); if (unlikely(!__pyx_tuple__222)) __PYX_ERR(0, 277, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__222);
  __Pyx_GIVEREF(__pyx_tuple__222);
  __pyx_tuple__223 = PyTuple_Pack(1, __pyx_kp_s_RemoveFailedNode_RequestNetworkU); if (unlikely(!__pyx_tuple__223)) __PYX_ERR(0, 277, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__223);
  __Pyx_GIVEREF(__pyx_tuple__223);

  /* "libopenzwave.pyx":278
 *     EnumWithDoc('Busy').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 *     EnumWithDoc('Failed').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 *     EnumWithDoc('Disabled').setDoc("RequestNetworkUpdate error."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Overflow').setDoc("RequestNetworkUpdate error."),
 *     ]
 */
  __pyx_tuple__224 = PyTuple_Pack(1, __pyx_n_s_Disabled); if (unlikely(!__pyx_tuple__224)) __PYX_ERR(0, 278, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__224);
  __Pyx_GIVEREF(__pyx_tuple__224);
  __pyx_tuple__225 = PyTuple_Pack(1, __pyx_kp_s_RequestNetworkUpdate_error); if (unlikely(!__pyx_tuple__225)) __PYX_ERR(0, 278, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__225);
  __Pyx_GIVEREF(__pyx_tuple__225);

  /* "libopenzwave.pyx":279
 *     EnumWithDoc('Failed').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 *     EnumWithDoc('Disabled').setDoc("RequestNetworkUpdate error."),
 *     EnumWithDoc('Overflow').setDoc("RequestNetworkUpdate error."),             # <<<<<<<<<<<<<<
 *     ]
 * 
 */
  __pyx_tuple__226 = PyTuple_Pack(1, __pyx_n_s_Overflow); if (unlikely(!__pyx_tuple__226)) __PYX_ERR(0, 279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__226);
  __Pyx_GIVEREF(__pyx_tuple__226);
  __pyx_tuple__227 = PyTuple_Pack(1, __pyx_kp_s_RequestNetworkUpdate_error); if (unlikely(!__pyx_tuple__227)) __PYX_ERR(0, 279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__227);
  __Pyx_GIVEREF(__pyx_tuple__227);

  /* "libopenzwave.pyx":283
 * 
 * PyControllerInterface = [
 *     EnumWithDoc('Unknown').setDoc("Controller interface use unknown protocol."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Serial').setDoc("Controller interface use serial protocol."),
 *     EnumWithDoc('Hid').setDoc("Controller interface use human interface device protocol."),
 */
  __pyx_tuple__228 = PyTuple_Pack(1, __pyx_n_s_Unknown); if (unlikely(!__pyx_tuple__228)) __PYX_ERR(0, 283, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__228);
  __Pyx_GIVEREF(__pyx_tuple__228);
  __pyx_tuple__229 = PyTuple_Pack(1, __pyx_kp_s_Controller_interface_use_unknown); if (unlikely(!__pyx_tuple__229)) __PYX_ERR(0, 283, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__229);
  __Pyx_GIVEREF(__pyx_tuple__229);

  /* "libopenzwave.pyx":284
 * PyControllerInterface = [
 *     EnumWithDoc('Unknown').setDoc("Controller interface use unknown protocol."),
 *     EnumWithDoc('Serial').setDoc("Controller interface use serial protocol."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Hid').setDoc("Controller interface use human interface device protocol."),
 * ]
 */
  __pyx_tuple__230 = PyTuple_Pack(1, __pyx_n_s_Serial); if (unlikely(!__pyx_tuple__230)) __PYX_ERR(0, 284, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__230);
  __Pyx_GIVEREF(__pyx_tuple__230);
  __pyx_tuple__231 = PyTuple_Pack(1, __pyx_kp_s_Controller_interface_use_serial); if (unlikely(!__pyx_tuple__231)) __PYX_ERR(0, 284, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__231);
  __Pyx_GIVEREF(__pyx_tuple__231);

  /* "libopenzwave.pyx":285
 *     EnumWithDoc('Unknown').setDoc("Controller interface use unknown protocol."),
 *     EnumWithDoc('Serial').setDoc("Controller interface use serial protocol."),
 *     EnumWithDoc('Hid').setDoc("Controller interface use human interface device protocol."),             # <<<<<<<<<<<<<<
 * ]
 * 
 */
  __pyx_tuple__232 = PyTuple_Pack(1, __pyx_n_s_Hid); if (unlikely(!__pyx_tuple__232)) __PYX_ERR(0, 285, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__232);
  __Pyx_GIVEREF(__pyx_tuple__232);
  __pyx_tuple__233 = PyTuple_Pack(1, __pyx_kp_s_Controller_interface_use_human_i); if (unlikely(!__pyx_tuple__233)) __PYX_ERR(0, 285, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__233);
  __Pyx_GIVEREF(__pyx_tuple__233);

  /* "libopenzwave.pyx":289
 * 
 * PyOptionType = [
 *     EnumWithDoc('Invalid').setDoc("Invalid type."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Bool').setDoc("Boolean."),
 *     EnumWithDoc('Int').setDoc("Integer."),
 */
  __pyx_tuple__234 = PyTuple_Pack(1, __pyx_n_s_Invalid); if (unlikely(!__pyx_tuple__234)) __PYX_ERR(0, 289, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__234);
  __Pyx_GIVEREF(__pyx_tuple__234);
  __pyx_tuple__235 = PyTuple_Pack(1, __pyx_kp_s_Invalid_type); if (unlikely(!__pyx_tuple__235)) __PYX_ERR(0, 289, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__235);
  __Pyx_GIVEREF(__pyx_tuple__235);

  /* "libopenzwave.pyx":290
 * PyOptionType = [
 *     EnumWithDoc('Invalid').setDoc("Invalid type."),
 *     EnumWithDoc('Bool').setDoc("Boolean."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Int').setDoc("Integer."),
 *     EnumWithDoc('String').setDoc("String."),
 */
  __pyx_tuple__236 = PyTuple_Pack(1, __pyx_n_s_Bool); if (unlikely(!__pyx_tuple__236)) __PYX_ERR(0, 290, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__236);
  __Pyx_GIVEREF(__pyx_tuple__236);
  __pyx_tuple__237 = PyTuple_Pack(1, __pyx_kp_s_Boolean); if (unlikely(!__pyx_tuple__237)) __PYX_ERR(0, 290, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__237);
  __Pyx_GIVEREF(__pyx_tuple__237);

  /* "libopenzwave.pyx":291
 *     EnumWithDoc('Invalid').setDoc("Invalid type."),
 *     EnumWithDoc('Bool').setDoc("Boolean."),
 *     EnumWithDoc('Int').setDoc("Integer."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('String').setDoc("String."),
 * ]
 */
  __pyx_tuple__238 = PyTuple_Pack(1, __pyx_n_s_Int); if (unlikely(!__pyx_tuple__238)) __PYX_ERR(0, 291, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__238);
  __Pyx_GIVEREF(__pyx_tuple__238);
  __pyx_tuple__239 = PyTuple_Pack(1, __pyx_kp_s_Integer); if (unlikely(!__pyx_tuple__239)) __PYX_ERR(0, 291, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__239);
  __Pyx_GIVEREF(__pyx_tuple__239);

  /* "libopenzwave.pyx":292
 *     EnumWithDoc('Bool').setDoc("Boolean."),
 *     EnumWithDoc('Int').setDoc("Integer."),
 *     EnumWithDoc('String').setDoc("String."),             # <<<<<<<<<<<<<<
 * ]
 * 
 */
  __pyx_tuple__240 = PyTuple_Pack(1, __pyx_n_s_String); if (unlikely(!__pyx_tuple__240)) __PYX_ERR(0, 292, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__240);
  __Pyx_GIVEREF(__pyx_tuple__240);
  __pyx_tuple__241 = PyTuple_Pack(1, __pyx_kp_s_String_2); if (unlikely(!__pyx_tuple__241)) __PYX_ERR(0, 292, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__241);
  __Pyx_GIVEREF(__pyx_tuple__241);

  /* "libopenzwave.pyx":297
 * class EnumWithDocType(str):
 *     """Enum helper"""
 *     def setDocType(self, doc, stype):             # <<<<<<<<<<<<<<
 *         self.doc = doc
 *         self.type = stype
 */
  __pyx_tuple__242 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_doc, __pyx_n_s_stype); if (unlikely(!__pyx_tuple__242)) __PYX_ERR(0, 297, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__242);
  __Pyx_GIVEREF(__pyx_tuple__242);
  __pyx_codeobj__243 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__242, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_sebastien_devel_python_ope, __pyx_n_s_setDocType, 297, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__243)) __PYX_ERR(0, 297, __pyx_L1_error)

  /* "libopenzwave.pyx":598
 *     cdef DriverData data
 * 
 * def configPath():             # <<<<<<<<<<<<<<
 *     '''
 *     Retrieve the config path. This directory hold the xml files.
 */
  __pyx_tuple__244 = PyTuple_Pack(2, __pyx_n_s_dirn, __pyx_n_s_resource_filename); if (unlikely(!__pyx_tuple__244)) __PYX_ERR(0, 598, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__244);
  __Pyx_GIVEREF(__pyx_tuple__244);
  __pyx_codeobj__245 = (PyObject*)__Pyx_PyCode_New(0, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__244, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_sebastien_devel_python_ope, __pyx_n_s_configPath, 598, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__245)) __PYX_ERR(0, 598, __pyx_L1_error)

  /* "libopenzwave.pyx":1123
 *     '''
 * 
 *     CALLBACK_DESC = ('value added','value removed','value changed','groups changed','new node','node added',             # <<<<<<<<<<<<<<
 *                      'node removed','node protocol info','node naming','node event','polling disabled',
 *                      'polling enabled','driver ready','driver reset','message complete','node queries complete',
 */
  __pyx_tuple__246 = PyTuple_Pack(18, __pyx_kp_s_value_added, __pyx_kp_s_value_removed, __pyx_kp_s_value_changed, __pyx_kp_s_groups_changed, __pyx_kp_s_new_node, __pyx_kp_s_node_added, __pyx_kp_s_node_removed, __pyx_kp_s_node_protocol_info, __pyx_kp_s_node_naming, __pyx_kp_s_node_event, __pyx_kp_s_polling_disabled, __pyx_kp_s_polling_enabled, __pyx_kp_s_driver_ready, __pyx_kp_s_driver_reset, __pyx_kp_s_message_complete, __pyx_kp_s_node_queries_complete, __pyx_kp_s_awake_nodes_queried, __pyx_kp_s_all_nodes_queried); if (unlikely(!__pyx_tuple__246)) __PYX_ERR(0, 1123, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__246);
  __Pyx_GIVEREF(__pyx_tuple__246);
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_3 = PyInt_FromLong(3); if (unlikely(!__pyx_int_3)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_4 = PyInt_FromLong(4); if (unlikely(!__pyx_int_4)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_5 = PyInt_FromLong(5); if (unlikely(!__pyx_int_5)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_6 = PyInt_FromLong(6); if (unlikely(!__pyx_int_6)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_7 = PyInt_FromLong(7); if (unlikely(!__pyx_int_7)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_8 = PyInt_FromLong(8); if (unlikely(!__pyx_int_8)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_9 = PyInt_FromLong(9); if (unlikely(!__pyx_int_9)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_10 = PyInt_FromLong(10); if (unlikely(!__pyx_int_10)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_11 = PyInt_FromLong(11); if (unlikely(!__pyx_int_11)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_12 = PyInt_FromLong(12); if (unlikely(!__pyx_int_12)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_13 = PyInt_FromLong(13); if (unlikely(!__pyx_int_13)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_14 = PyInt_FromLong(14); if (unlikely(!__pyx_int_14)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_15 = PyInt_FromLong(15); if (unlikely(!__pyx_int_15)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_16 = PyInt_FromLong(16); if (unlikely(!__pyx_int_16)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_32 = PyInt_FromLong(32); if (unlikely(!__pyx_int_32)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_33 = PyInt_FromLong(33); if (unlikely(!__pyx_int_33)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_34 = PyInt_FromLong(34); if (unlikely(!__pyx_int_34)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_35 = PyInt_FromLong(35); if (unlikely(!__pyx_int_35)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_36 = PyInt_FromLong(36); if (unlikely(!__pyx_int_36)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_37 = PyInt_FromLong(37); if (unlikely(!__pyx_int_37)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_38 = PyInt_FromLong(38); if (unlikely(!__pyx_int_38)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_39 = PyInt_FromLong(39); if (unlikely(!__pyx_int_39)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_40 = PyInt_FromLong(40); if (unlikely(!__pyx_int_40)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_41 = PyInt_FromLong(41); if (unlikely(!__pyx_int_41)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_42 = PyInt_FromLong(42); if (unlikely(!__pyx_int_42)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_43 = PyInt_FromLong(43); if (unlikely(!__pyx_int_43)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_44 = PyInt_FromLong(44); if (unlikely(!__pyx_int_44)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_45 = PyInt_FromLong(45); if (unlikely(!__pyx_int_45)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_46 = PyInt_FromLong(46); if (unlikely(!__pyx_int_46)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_47 = PyInt_FromLong(47); if (unlikely(!__pyx_int_47)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_48 = PyInt_FromLong(48); if (unlikely(!__pyx_int_48)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_49 = PyInt_FromLong(49); if (unlikely(!__pyx_int_49)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_50 = PyInt_FromLong(50); if (unlikely(!__pyx_int_50)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_51 = PyInt_FromLong(51); if (unlikely(!__pyx_int_51)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_52 = PyInt_FromLong(52); if (unlikely(!__pyx_int_52)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_53 = PyInt_FromLong(53); if (unlikely(!__pyx_int_53)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_56 = PyInt_FromLong(56); if (unlikely(!__pyx_int_56)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_60 = PyInt_FromLong(60); if (unlikely(!__pyx_int_60)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_61 = PyInt_FromLong(61); if (unlikely(!__pyx_int_61)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_62 = PyInt_FromLong(62); if (unlikely(!__pyx_int_62)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_64 = PyInt_FromLong(64); if (unlikely(!__pyx_int_64)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_66 = PyInt_FromLong(66); if (unlikely(!__pyx_int_66)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_67 = PyInt_FromLong(67); if (unlikely(!__pyx_int_67)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_68 = PyInt_FromLong(68); if (unlikely(!__pyx_int_68)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_69 = PyInt_FromLong(69); if (unlikely(!__pyx_int_69)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_70 = PyInt_FromLong(70); if (unlikely(!__pyx_int_70)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_71 = PyInt_FromLong(71); if (unlikely(!__pyx_int_71)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_76 = PyInt_FromLong(76); if (unlikely(!__pyx_int_76)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_78 = PyInt_FromLong(78); if (unlikely(!__pyx_int_78)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_80 = PyInt_FromLong(80); if (unlikely(!__pyx_int_80)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_81 = PyInt_FromLong(81); if (unlikely(!__pyx_int_81)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_86 = PyInt_FromLong(86); if (unlikely(!__pyx_int_86)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_90 = PyInt_FromLong(90); if (unlikely(!__pyx_int_90)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_91 = PyInt_FromLong(91); if (unlikely(!__pyx_int_91)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_94 = PyInt_FromLong(94); if (unlikely(!__pyx_int_94)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_96 = PyInt_FromLong(96); if (unlikely(!__pyx_int_96)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_97 = PyInt_FromLong(97); if (unlikely(!__pyx_int_97)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_98 = PyInt_FromLong(98); if (unlikely(!__pyx_int_98)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_99 = PyInt_FromLong(99); if (unlikely(!__pyx_int_99)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_100 = PyInt_FromLong(100); if (unlikely(!__pyx_int_100)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_102 = PyInt_FromLong(102); if (unlikely(!__pyx_int_102)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_112 = PyInt_FromLong(112); if (unlikely(!__pyx_int_112)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_113 = PyInt_FromLong(113); if (unlikely(!__pyx_int_113)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_114 = PyInt_FromLong(114); if (unlikely(!__pyx_int_114)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_115 = PyInt_FromLong(115); if (unlikely(!__pyx_int_115)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_117 = PyInt_FromLong(117); if (unlikely(!__pyx_int_117)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_118 = PyInt_FromLong(118); if (unlikely(!__pyx_int_118)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_119 = PyInt_FromLong(119); if (unlikely(!__pyx_int_119)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_120 = PyInt_FromLong(120); if (unlikely(!__pyx_int_120)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_121 = PyInt_FromLong(121); if (unlikely(!__pyx_int_121)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_122 = PyInt_FromLong(122); if (unlikely(!__pyx_int_122)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_123 = PyInt_FromLong(123); if (unlikely(!__pyx_int_123)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_124 = PyInt_FromLong(124); if (unlikely(!__pyx_int_124)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_125 = PyInt_FromLong(125); if (unlikely(!__pyx_int_125)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_128 = PyInt_FromLong(128); if (unlikely(!__pyx_int_128)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_129 = PyInt_FromLong(129); if (unlikely(!__pyx_int_129)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_130 = PyInt_FromLong(130); if (unlikely(!__pyx_int_130)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_131 = PyInt_FromLong(131); if (unlikely(!__pyx_int_131)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_132 = PyInt_FromLong(132); if (unlikely(!__pyx_int_132)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_133 = PyInt_FromLong(133); if (unlikely(!__pyx_int_133)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_134 = PyInt_FromLong(134); if (unlikely(!__pyx_int_134)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_135 = PyInt_FromLong(135); if (unlikely(!__pyx_int_135)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_136 = PyInt_FromLong(136); if (unlikely(!__pyx_int_136)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_137 = PyInt_FromLong(137); if (unlikely(!__pyx_int_137)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_138 = PyInt_FromLong(138); if (unlikely(!__pyx_int_138)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_139 = PyInt_FromLong(139); if (unlikely(!__pyx_int_139)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_140 = PyInt_FromLong(140); if (unlikely(!__pyx_int_140)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_141 = PyInt_FromLong(141); if (unlikely(!__pyx_int_141)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_142 = PyInt_FromLong(142); if (unlikely(!__pyx_int_142)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_143 = PyInt_FromLong(143); if (unlikely(!__pyx_int_143)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_144 = PyInt_FromLong(144); if (unlikely(!__pyx_int_144)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_145 = PyInt_FromLong(145); if (unlikely(!__pyx_int_145)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_146 = PyInt_FromLong(146); if (unlikely(!__pyx_int_146)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_147 = PyInt_FromLong(147); if (unlikely(!__pyx_int_147)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_148 = PyInt_FromLong(148); if (unlikely(!__pyx_int_148)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_149 = PyInt_FromLong(149); if (unlikely(!__pyx_int_149)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_150 = PyInt_FromLong(150); if (unlikely(!__pyx_int_150)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_151 = PyInt_FromLong(151); if (unlikely(!__pyx_int_151)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_152 = PyInt_FromLong(152); if (unlikely(!__pyx_int_152)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_153 = PyInt_FromLong(153); if (unlikely(!__pyx_int_153)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_154 = PyInt_FromLong(154); if (unlikely(!__pyx_int_154)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_155 = PyInt_FromLong(155); if (unlikely(!__pyx_int_155)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_156 = PyInt_FromLong(156); if (unlikely(!__pyx_int_156)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_157 = PyInt_FromLong(157); if (unlikely(!__pyx_int_157)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_158 = PyInt_FromLong(158); if (unlikely(!__pyx_int_158)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_239 = PyInt_FromLong(239); if (unlikely(!__pyx_int_239)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_240 = PyInt_FromLong(240); if (unlikely(!__pyx_int_240)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_255 = PyInt_FromLong(255); if (unlikely(!__pyx_int_255)) __PYX_ERR(0, 1, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC initlibopenzwave(void); /*proto*/
PyMODINIT_FUNC initlibopenzwave(void)
#else
PyMODINIT_FUNC PyInit_libopenzwave(void); /*proto*/
PyMODINIT_FUNC PyInit_libopenzwave(void)
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  int __pyx_t_12;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  PyObject *__pyx_t_16 = NULL;
  PyObject *__pyx_t_17 = NULL;
  PyObject *__pyx_t_18 = NULL;
  PyObject *__pyx_t_19 = NULL;
  PyObject *__pyx_t_20 = NULL;
  PyObject *__pyx_t_21 = NULL;
  PyObject *__pyx_t_22 = NULL;
  PyObject *__pyx_t_23 = NULL;
  PyObject *__pyx_t_24 = NULL;
  PyObject *__pyx_t_25 = NULL;
  PyObject *__pyx_t_26 = NULL;
  PyObject *__pyx_t_27 = NULL;
  PyObject *__pyx_t_28 = NULL;
  PyObject *__pyx_t_29 = NULL;
  PyObject *__pyx_t_30 = NULL;
  PyObject *__pyx_t_31 = NULL;
  PyObject *__pyx_t_32 = NULL;
  PyObject *__pyx_t_33 = NULL;
  PyObject *__pyx_t_34 = NULL;
  PyObject *__pyx_t_35 = NULL;
  PyObject *__pyx_t_36 = NULL;
  __Pyx_RefNannyDeclarations
  #if CYTHON_REFNANNY
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  #endif
  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_libopenzwave(void)", 0);
  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pyx_CyFunction_USED
  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Coroutine_USED
  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_StopAsyncIteration_USED
  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("libopenzwave", __pyx_methods, __pyx_k_module_libopenzwave_This_file_i, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
  #if CYTHON_COMPILING_IN_PYPY
  Py_INCREF(__pyx_b);
  #endif
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  /*--- Initialize various global constants etc. ---*/
  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  if (__pyx_module_is_main_libopenzwave) {
    if (PyObject_SetAttrString(__pyx_m, "__name__", __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
    if (!PyDict_GetItemString(modules, "libopenzwave")) {
      if (unlikely(PyDict_SetItemString(modules, "libopenzwave", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Constants init code ---*/
  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Global init code ---*/
  /*--- Variable export code ---*/
  /*--- Function export code ---*/
  /*--- Type init code ---*/
  if (PyType_Ready(&__pyx_type_12libopenzwave_PyOptions) < 0) __PYX_ERR(0, 644, __pyx_L1_error)
  __pyx_type_12libopenzwave_PyOptions.tp_print = 0;
  #if CYTHON_COMPILING_IN_CPYTHON
  {
    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_12libopenzwave_PyOptions, "__init__"); if (unlikely(!wrapper)) __PYX_ERR(0, 644, __pyx_L1_error)
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_12libopenzwave_9PyOptions___init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_12libopenzwave_9PyOptions___init__.doc = __pyx_doc_12libopenzwave_9PyOptions___init__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_12libopenzwave_9PyOptions___init__;
    }
  }
  #endif
  if (PyObject_SetAttrString(__pyx_m, "PyOptions", (PyObject *)&__pyx_type_12libopenzwave_PyOptions) < 0) __PYX_ERR(0, 644, __pyx_L1_error)
  __pyx_ptype_12libopenzwave_PyOptions = &__pyx_type_12libopenzwave_PyOptions;
  if (PyType_Ready(&__pyx_type_12libopenzwave_RetAlloc) < 0) __PYX_ERR(0, 943, __pyx_L1_error)
  __pyx_type_12libopenzwave_RetAlloc.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "RetAlloc", (PyObject *)&__pyx_type_12libopenzwave_RetAlloc) < 0) __PYX_ERR(0, 943, __pyx_L1_error)
  __pyx_ptype_12libopenzwave_RetAlloc = &__pyx_type_12libopenzwave_RetAlloc;
  if (PyType_Ready(&__pyx_type_12libopenzwave_InstanceAssociationAlloc) < 0) __PYX_ERR(0, 960, __pyx_L1_error)
  __pyx_type_12libopenzwave_InstanceAssociationAlloc.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "InstanceAssociationAlloc", (PyObject *)&__pyx_type_12libopenzwave_InstanceAssociationAlloc) < 0) __PYX_ERR(0, 960, __pyx_L1_error)
  __pyx_ptype_12libopenzwave_InstanceAssociationAlloc = &__pyx_type_12libopenzwave_InstanceAssociationAlloc;
  if (PyType_Ready(&__pyx_type_12libopenzwave_PyManager) < 0) __PYX_ERR(0, 977, __pyx_L1_error)
  __pyx_type_12libopenzwave_PyManager.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "PyManager", (PyObject *)&__pyx_type_12libopenzwave_PyManager) < 0) __PYX_ERR(0, 977, __pyx_L1_error)
  __pyx_ptype_12libopenzwave_PyManager = &__pyx_type_12libopenzwave_PyManager;
  /*--- Type import code ---*/
  /*--- Variable import code ---*/
  /*--- Function import code ---*/
  /*--- Execution code ---*/
  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif

  /* "libopenzwave.pyx":57
 * from manager cimport struct_associations, int_associations
 * from log cimport LogLevel
 * import os             # <<<<<<<<<<<<<<
 * import sys
 * import warnings
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_os, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 57, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_os, __pyx_t_1) < 0) __PYX_ERR(0, 57, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":58
 * from log cimport LogLevel
 * import os
 * import sys             # <<<<<<<<<<<<<<
 * import warnings
 * import six
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_sys, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 58, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sys, __pyx_t_1) < 0) __PYX_ERR(0, 58, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":59
 * import os
 * import sys
 * import warnings             # <<<<<<<<<<<<<<
 * import six
 * from shutil import copyfile
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_warnings, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 59, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_warnings, __pyx_t_1) < 0) __PYX_ERR(0, 59, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":60
 * import sys
 * import warnings
 * import six             # <<<<<<<<<<<<<<
 * from shutil import copyfile
 * 
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_six, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 60, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_six, __pyx_t_1) < 0) __PYX_ERR(0, 60, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":61
 * import warnings
 * import six
 * from shutil import copyfile             # <<<<<<<<<<<<<<
 * 
 * # Set default logging handler to avoid "No handler found" warnings.
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 61, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_copyfile);
  __Pyx_GIVEREF(__pyx_n_s_copyfile);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_copyfile);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_shutil, __pyx_t_1, -1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 61, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_copyfile); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 61, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_copyfile, __pyx_t_1) < 0) __PYX_ERR(0, 61, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":64
 * 
 * # Set default logging handler to avoid "No handler found" warnings.
 * import logging             # <<<<<<<<<<<<<<
 * try:  # Python 2.7+
 *     from logging import NullHandler
 */
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_logging, 0, -1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 64, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_logging, __pyx_t_2) < 0) __PYX_ERR(0, 64, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":65
 * # Set default logging handler to avoid "No handler found" warnings.
 * import logging
 * try:  # Python 2.7+             # <<<<<<<<<<<<<<
 *     from logging import NullHandler
 * except ImportError:
 */
  {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_4, &__pyx_t_5);
    __Pyx_XGOTREF(__pyx_t_3);
    __Pyx_XGOTREF(__pyx_t_4);
    __Pyx_XGOTREF(__pyx_t_5);
    /*try:*/ {

      /* "libopenzwave.pyx":66
 * import logging
 * try:  # Python 2.7+
 *     from logging import NullHandler             # <<<<<<<<<<<<<<
 * except ImportError:
 *     class NullHandler(logging.Handler):
 */
      __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 66, __pyx_L2_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_INCREF(__pyx_n_s_NullHandler);
      __Pyx_GIVEREF(__pyx_n_s_NullHandler);
      PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_NullHandler);
      __pyx_t_1 = __Pyx_Import(__pyx_n_s_logging, __pyx_t_2, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 66, __pyx_L2_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_NullHandler); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 66, __pyx_L2_error)
      __Pyx_GOTREF(__pyx_t_2);
      if (PyDict_SetItem(__pyx_d, __pyx_n_s_NullHandler, __pyx_t_2) < 0) __PYX_ERR(0, 66, __pyx_L2_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "libopenzwave.pyx":65
 * # Set default logging handler to avoid "No handler found" warnings.
 * import logging
 * try:  # Python 2.7+             # <<<<<<<<<<<<<<
 *     from logging import NullHandler
 * except ImportError:
 */
    }
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    goto __pyx_L9_try_end;
    __pyx_L2_error:;
    __Pyx_PyThreadState_assign
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "libopenzwave.pyx":67
 * try:  # Python 2.7+
 *     from logging import NullHandler
 * except ImportError:             # <<<<<<<<<<<<<<
 *     class NullHandler(logging.Handler):
 *         """NullHandler logger for python 2.6"""
 */
    __pyx_t_6 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_ImportError);
    if (__pyx_t_6) {
      __Pyx_AddTraceback("libopenzwave", __pyx_clineno, __pyx_lineno, __pyx_filename);
      if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_2, &__pyx_t_7) < 0) __PYX_ERR(0, 67, __pyx_L4_except_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_GOTREF(__pyx_t_7);

      /* "libopenzwave.pyx":68
 *     from logging import NullHandler
 * except ImportError:
 *     class NullHandler(logging.Handler):             # <<<<<<<<<<<<<<
 *         """NullHandler logger for python 2.6"""
 *         def emit(self, record):
 */
      __pyx_t_8 = __Pyx_GetModuleGlobalName(__pyx_n_s_logging); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 68, __pyx_L4_except_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_Handler); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 68, __pyx_L4_except_error)
      __Pyx_GOTREF(__pyx_t_9);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 68, __pyx_L4_except_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_GIVEREF(__pyx_t_9);
      PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_9);
      __pyx_t_9 = 0;
      __pyx_t_9 = __Pyx_CalculateMetaclass(NULL, __pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 68, __pyx_L4_except_error)
      __Pyx_GOTREF(__pyx_t_9);
      __pyx_t_10 = __Pyx_Py3MetaclassPrepare(__pyx_t_9, __pyx_t_8, __pyx_n_s_NullHandler, __pyx_n_s_NullHandler, (PyObject *) NULL, __pyx_n_s_libopenzwave, __pyx_kp_s_NullHandler_logger_for_python_2); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 68, __pyx_L4_except_error)
      __Pyx_GOTREF(__pyx_t_10);

      /* "libopenzwave.pyx":70
 *     class NullHandler(logging.Handler):
 *         """NullHandler logger for python 2.6"""
 *         def emit(self, record):             # <<<<<<<<<<<<<<
 *             pass
 * logger = logging.getLogger('libopenzwave')
 */
      __pyx_t_11 = __Pyx_CyFunction_NewEx(&__pyx_mdef_12libopenzwave_11NullHandler_1emit, 0, __pyx_n_s_NullHandler_emit, NULL, __pyx_n_s_libopenzwave, __pyx_d, ((PyObject *)__pyx_codeobj__34)); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 70, __pyx_L4_except_error)
      __Pyx_GOTREF(__pyx_t_11);
      if (PyObject_SetItem(__pyx_t_10, __pyx_n_s_emit, __pyx_t_11) < 0) __PYX_ERR(0, 70, __pyx_L4_except_error)
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;

      /* "libopenzwave.pyx":68
 *     from logging import NullHandler
 * except ImportError:
 *     class NullHandler(logging.Handler):             # <<<<<<<<<<<<<<
 *         """NullHandler logger for python 2.6"""
 *         def emit(self, record):
 */
      __pyx_t_11 = __Pyx_Py3ClassCreate(__pyx_t_9, __pyx_n_s_NullHandler, __pyx_t_8, __pyx_t_10, NULL, 0, 1); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 68, __pyx_L4_except_error)
      __Pyx_GOTREF(__pyx_t_11);
      if (PyDict_SetItem(__pyx_d, __pyx_n_s_NullHandler, __pyx_t_11) < 0) __PYX_ERR(0, 68, __pyx_L4_except_error)
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      goto __pyx_L3_exception_handled;
    }
    goto __pyx_L4_except_error;
    __pyx_L4_except_error:;

    /* "libopenzwave.pyx":65
 * # Set default logging handler to avoid "No handler found" warnings.
 * import logging
 * try:  # Python 2.7+             # <<<<<<<<<<<<<<
 *     from logging import NullHandler
 * except ImportError:
 */
    __Pyx_PyThreadState_assign
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_XGIVEREF(__pyx_t_4);
    __Pyx_XGIVEREF(__pyx_t_5);
    __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
    goto __pyx_L1_error;
    __pyx_L3_exception_handled:;
    __Pyx_PyThreadState_assign
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_XGIVEREF(__pyx_t_4);
    __Pyx_XGIVEREF(__pyx_t_5);
    __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
    __pyx_L9_try_end:;
  }

  /* "libopenzwave.pyx":72
 *         def emit(self, record):
 *             pass
 * logger = logging.getLogger('libopenzwave')             # <<<<<<<<<<<<<<
 * logger.addHandler(NullHandler())
 * 
 */
  __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_logging); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 72, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_getLogger); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 72, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__35, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 72, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_logger, __pyx_t_7) < 0) __PYX_ERR(0, 72, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

  /* "libopenzwave.pyx":73
 *             pass
 * logger = logging.getLogger('libopenzwave')
 * logger.addHandler(NullHandler())             # <<<<<<<<<<<<<<
 * 
 * from pkg_resources import get_distribution, DistributionNotFound
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 73, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_addHandler); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 73, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_8 = __Pyx_GetModuleGlobalName(__pyx_n_s_NullHandler); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 73, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __pyx_t_9 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
    __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_8);
    if (likely(__pyx_t_9)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
      __Pyx_INCREF(__pyx_t_9);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_8, function);
    }
  }
  if (__pyx_t_9) {
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_9); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 73, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  } else {
    __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 73, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __pyx_t_8 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_8)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_8);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  if (!__pyx_t_8) {
    __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 73, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_7);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_1)) {
      PyObject *__pyx_temp[2] = {__pyx_t_8, __pyx_t_2};
      __pyx_t_7 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 73, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
      PyObject *__pyx_temp[2] = {__pyx_t_8, __pyx_t_2};
      __pyx_t_7 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 73, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    } else
    #endif
    {
      __pyx_t_9 = PyTuple_New(1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 73, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_8); __pyx_t_8 = NULL;
      __Pyx_GIVEREF(__pyx_t_2);
      PyTuple_SET_ITEM(__pyx_t_9, 0+1, __pyx_t_2);
      __pyx_t_2 = 0;
      __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_9, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 73, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

  /* "libopenzwave.pyx":75
 * logger.addHandler(NullHandler())
 * 
 * from pkg_resources import get_distribution, DistributionNotFound             # <<<<<<<<<<<<<<
 * 
 * cdef extern from 'pyversion.h':
 */
  __pyx_t_7 = PyList_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 75, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_INCREF(__pyx_n_s_get_distribution);
  __Pyx_GIVEREF(__pyx_n_s_get_distribution);
  PyList_SET_ITEM(__pyx_t_7, 0, __pyx_n_s_get_distribution);
  __Pyx_INCREF(__pyx_n_s_DistributionNotFound);
  __Pyx_GIVEREF(__pyx_n_s_DistributionNotFound);
  PyList_SET_ITEM(__pyx_t_7, 1, __pyx_n_s_DistributionNotFound);
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_pkg_resources, __pyx_t_7, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 75, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_7 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_get_distribution); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 75, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_distribution, __pyx_t_7) < 0) __PYX_ERR(0, 75, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_7 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_DistributionNotFound); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 75, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DistributionNotFound, __pyx_t_7) < 0) __PYX_ERR(0, 75, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":84
 *     string PY_LIB_TIME_STRING
 * 
 * __version__ = PY_LIB_VERSION_STRING             # <<<<<<<<<<<<<<
 * 
 * #For historical ways of working
 */
  __pyx_t_1 = __pyx_convert_PyUnicode_string_to_py_std__in_string(PY_LIB_VERSION_STRING); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 84, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_version, __pyx_t_1) < 0) __PYX_ERR(0, 84, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":87
 * 
 * #For historical ways of working
 * libopenzwave_location = 'not_installed'             # <<<<<<<<<<<<<<
 * libopenzwave_file = 'not_installed'
 * try:
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_libopenzwave_location, __pyx_n_s_not_installed) < 0) __PYX_ERR(0, 87, __pyx_L1_error)

  /* "libopenzwave.pyx":88
 * #For historical ways of working
 * libopenzwave_location = 'not_installed'
 * libopenzwave_file = 'not_installed'             # <<<<<<<<<<<<<<
 * try:
 *     _dist = get_distribution('libopenzwave')
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_libopenzwave_file, __pyx_n_s_not_installed) < 0) __PYX_ERR(0, 88, __pyx_L1_error)

  /* "libopenzwave.pyx":89
 * libopenzwave_location = 'not_installed'
 * libopenzwave_file = 'not_installed'
 * try:             # <<<<<<<<<<<<<<
 *     _dist = get_distribution('libopenzwave')
 * except DistributionNotFound:
 */
  {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ExceptionSave(&__pyx_t_5, &__pyx_t_4, &__pyx_t_3);
    __Pyx_XGOTREF(__pyx_t_5);
    __Pyx_XGOTREF(__pyx_t_4);
    __Pyx_XGOTREF(__pyx_t_3);
    /*try:*/ {

      /* "libopenzwave.pyx":90
 * libopenzwave_file = 'not_installed'
 * try:
 *     _dist = get_distribution('libopenzwave')             # <<<<<<<<<<<<<<
 * except DistributionNotFound:
 *     pass
 */
      __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_get_distribution); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 90, __pyx_L12_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__36, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 90, __pyx_L12_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (PyDict_SetItem(__pyx_d, __pyx_n_s_dist, __pyx_t_7) < 0) __PYX_ERR(0, 90, __pyx_L12_error)
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

      /* "libopenzwave.pyx":89
 * libopenzwave_location = 'not_installed'
 * libopenzwave_file = 'not_installed'
 * try:             # <<<<<<<<<<<<<<
 *     _dist = get_distribution('libopenzwave')
 * except DistributionNotFound:
 */
    }

    /* "libopenzwave.pyx":94
 *     pass
 * else:
 *     libopenzwave_location = _dist.location             # <<<<<<<<<<<<<<
 * if libopenzwave_location == 'not_installed' :
 *    try:
 */
    /*else:*/ {
      __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_dist); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 94, __pyx_L14_except_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_location); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 94, __pyx_L14_except_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (PyDict_SetItem(__pyx_d, __pyx_n_s_libopenzwave_location, __pyx_t_1) < 0) __PYX_ERR(0, 94, __pyx_L14_except_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    }
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L19_try_end;
    __pyx_L12_error:;
    __Pyx_PyThreadState_assign
    __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
    __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;

    /* "libopenzwave.pyx":91
 * try:
 *     _dist = get_distribution('libopenzwave')
 * except DistributionNotFound:             # <<<<<<<<<<<<<<
 *     pass
 * else:
 */
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_DistributionNotFound); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 91, __pyx_L14_except_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_6 = __Pyx_PyErr_ExceptionMatches(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (__pyx_t_6) {
      __Pyx_ErrRestore(0,0,0);
      goto __pyx_L13_exception_handled;
    }
    goto __pyx_L14_except_error;
    __pyx_L14_except_error:;

    /* "libopenzwave.pyx":89
 * libopenzwave_location = 'not_installed'
 * libopenzwave_file = 'not_installed'
 * try:             # <<<<<<<<<<<<<<
 *     _dist = get_distribution('libopenzwave')
 * except DistributionNotFound:
 */
    __Pyx_PyThreadState_assign
    __Pyx_XGIVEREF(__pyx_t_5);
    __Pyx_XGIVEREF(__pyx_t_4);
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_ExceptionReset(__pyx_t_5, __pyx_t_4, __pyx_t_3);
    goto __pyx_L1_error;
    __pyx_L13_exception_handled:;
    __Pyx_PyThreadState_assign
    __Pyx_XGIVEREF(__pyx_t_5);
    __Pyx_XGIVEREF(__pyx_t_4);
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_ExceptionReset(__pyx_t_5, __pyx_t_4, __pyx_t_3);
    __pyx_L19_try_end:;
  }

  /* "libopenzwave.pyx":95
 * else:
 *     libopenzwave_location = _dist.location
 * if libopenzwave_location == 'not_installed' :             # <<<<<<<<<<<<<<
 *    try:
 *         _dist = get_distribution('libopenzwave')
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_libopenzwave_location); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 95, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_12 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_not_installed, Py_EQ)); if (unlikely(__pyx_t_12 < 0)) __PYX_ERR(0, 95, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_12) {

    /* "libopenzwave.pyx":96
 *     libopenzwave_location = _dist.location
 * if libopenzwave_location == 'not_installed' :
 *    try:             # <<<<<<<<<<<<<<
 *         _dist = get_distribution('libopenzwave')
 *         libopenzwave_file = _dist.__file__
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_4, &__pyx_t_5);
      __Pyx_XGOTREF(__pyx_t_3);
      __Pyx_XGOTREF(__pyx_t_4);
      __Pyx_XGOTREF(__pyx_t_5);
      /*try:*/ {

        /* "libopenzwave.pyx":97
 * if libopenzwave_location == 'not_installed' :
 *    try:
 *         _dist = get_distribution('libopenzwave')             # <<<<<<<<<<<<<<
 *         libopenzwave_file = _dist.__file__
 *    except AttributeError:
 */
        __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_get_distribution); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 97, __pyx_L21_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__37, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 97, __pyx_L21_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        if (PyDict_SetItem(__pyx_d, __pyx_n_s_dist, __pyx_t_7) < 0) __PYX_ERR(0, 97, __pyx_L21_error)
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

        /* "libopenzwave.pyx":98
 *    try:
 *         _dist = get_distribution('libopenzwave')
 *         libopenzwave_file = _dist.__file__             # <<<<<<<<<<<<<<
 *    except AttributeError:
 *         libopenzwave_file = 'not_installed'
 */
        __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_dist); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 98, __pyx_L21_error)
        __Pyx_GOTREF(__pyx_t_7);
        __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_file); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 98, __pyx_L21_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        if (PyDict_SetItem(__pyx_d, __pyx_n_s_libopenzwave_file, __pyx_t_1) < 0) __PYX_ERR(0, 98, __pyx_L21_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "libopenzwave.pyx":96
 *     libopenzwave_location = _dist.location
 * if libopenzwave_location == 'not_installed' :
 *    try:             # <<<<<<<<<<<<<<
 *         _dist = get_distribution('libopenzwave')
 *         libopenzwave_file = _dist.__file__
 */
      }
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      goto __pyx_L28_try_end;
      __pyx_L21_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "libopenzwave.pyx":99
 *         _dist = get_distribution('libopenzwave')
 *         libopenzwave_file = _dist.__file__
 *    except AttributeError:             # <<<<<<<<<<<<<<
 *         libopenzwave_file = 'not_installed'
 *    except DistributionNotFound:
 */
      __pyx_t_6 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_AttributeError);
      if (__pyx_t_6) {
        __Pyx_AddTraceback("libopenzwave", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_7, &__pyx_t_9) < 0) __PYX_ERR(0, 99, __pyx_L23_except_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_GOTREF(__pyx_t_9);

        /* "libopenzwave.pyx":100
 *         libopenzwave_file = _dist.__file__
 *    except AttributeError:
 *         libopenzwave_file = 'not_installed'             # <<<<<<<<<<<<<<
 *    except DistributionNotFound:
 *         libopenzwave_file = 'not_installed'
 */
        if (PyDict_SetItem(__pyx_d, __pyx_n_s_libopenzwave_file, __pyx_n_s_not_installed) < 0) __PYX_ERR(0, 100, __pyx_L23_except_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        goto __pyx_L22_exception_handled;
      }

      /* "libopenzwave.pyx":101
 *    except AttributeError:
 *         libopenzwave_file = 'not_installed'
 *    except DistributionNotFound:             # <<<<<<<<<<<<<<
 *         libopenzwave_file = 'not_installed'
 * 
 */
      __pyx_t_9 = __Pyx_GetModuleGlobalName(__pyx_n_s_DistributionNotFound); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 101, __pyx_L23_except_error)
      __Pyx_GOTREF(__pyx_t_9);
      __pyx_t_6 = __Pyx_PyErr_ExceptionMatches(__pyx_t_9);
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      if (__pyx_t_6) {
        __Pyx_AddTraceback("libopenzwave", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_9, &__pyx_t_7, &__pyx_t_1) < 0) __PYX_ERR(0, 101, __pyx_L23_except_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_GOTREF(__pyx_t_1);

        /* "libopenzwave.pyx":102
 *         libopenzwave_file = 'not_installed'
 *    except DistributionNotFound:
 *         libopenzwave_file = 'not_installed'             # <<<<<<<<<<<<<<
 * 
 * cdef string str_to_cppstr(str s):
 */
        if (PyDict_SetItem(__pyx_d, __pyx_n_s_libopenzwave_file, __pyx_n_s_not_installed) < 0) __PYX_ERR(0, 102, __pyx_L23_except_error)
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L22_exception_handled;
      }
      goto __pyx_L23_except_error;
      __pyx_L23_except_error:;

      /* "libopenzwave.pyx":96
 *     libopenzwave_location = _dist.location
 * if libopenzwave_location == 'not_installed' :
 *    try:             # <<<<<<<<<<<<<<
 *         _dist = get_distribution('libopenzwave')
 *         libopenzwave_file = _dist.__file__
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_3);
      __Pyx_XGIVEREF(__pyx_t_4);
      __Pyx_XGIVEREF(__pyx_t_5);
      __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
      goto __pyx_L1_error;
      __pyx_L22_exception_handled:;
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_3);
      __Pyx_XGIVEREF(__pyx_t_4);
      __Pyx_XGIVEREF(__pyx_t_5);
      __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
      __pyx_L28_try_end:;
    }

    /* "libopenzwave.pyx":95
 * else:
 *     libopenzwave_location = _dist.location
 * if libopenzwave_location == 'not_installed' :             # <<<<<<<<<<<<<<
 *    try:
 *         _dist = get_distribution('libopenzwave')
 */
  }

  /* "libopenzwave.pyx":125
 *                 return s
 * 
 * class LibZWaveException(Exception):             # <<<<<<<<<<<<<<
 *     """
 *     Exception class for LibOpenZWave
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 125, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
  __Pyx_GIVEREF(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
  __pyx_t_7 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 125, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __pyx_t_9 = __Pyx_Py3MetaclassPrepare(__pyx_t_7, __pyx_t_1, __pyx_n_s_LibZWaveException, __pyx_n_s_LibZWaveException, (PyObject *) NULL, __pyx_n_s_libopenzwave, __pyx_kp_s_Exception_class_for_LibOpenZWav); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 125, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);

  /* "libopenzwave.pyx":129
 *     Exception class for LibOpenZWave
 *     """
 *     def __init__(self, value):             # <<<<<<<<<<<<<<
 *         Exception.__init__(self)
 *         self.msg = "LibOpenZwave Generic Exception"
 */
  __pyx_t_2 = __Pyx_CyFunction_NewEx(&__pyx_mdef_12libopenzwave_17LibZWaveException_1__init__, 0, __pyx_n_s_LibZWaveException___init, NULL, __pyx_n_s_libopenzwave, __pyx_d, ((PyObject *)__pyx_codeobj__39)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 129, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyObject_SetItem(__pyx_t_9, __pyx_n_s_init, __pyx_t_2) < 0) __PYX_ERR(0, 129, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":134
 *         self.value = value
 * 
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         return repr(self.msg+' : '+self.value)
 * 
 */
  __pyx_t_2 = __Pyx_CyFunction_NewEx(&__pyx_mdef_12libopenzwave_17LibZWaveException_3__str__, 0, __pyx_n_s_LibZWaveException___str, NULL, __pyx_n_s_libopenzwave, __pyx_d, ((PyObject *)__pyx_codeobj__41)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 134, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyObject_SetItem(__pyx_t_9, __pyx_n_s_str, __pyx_t_2) < 0) __PYX_ERR(0, 134, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":125
 *                 return s
 * 
 * class LibZWaveException(Exception):             # <<<<<<<<<<<<<<
 *     """
 *     Exception class for LibOpenZWave
 */
  __pyx_t_2 = __Pyx_Py3ClassCreate(__pyx_t_7, __pyx_n_s_LibZWaveException, __pyx_t_1, __pyx_t_9, NULL, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 125, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_LibZWaveException, __pyx_t_2) < 0) __PYX_ERR(0, 125, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":158
 * #~         logger.debug(data)
 * 
 * PYLIBRARY = __version__             # <<<<<<<<<<<<<<
 * PY_OZWAVE_CONFIG_DIRECTORY = "config"
 * OZWAVE_CONFIG_DIRECTORY = "share/openzwave/config"
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_version); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 158, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PYLIBRARY, __pyx_t_1) < 0) __PYX_ERR(0, 158, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":159
 * 
 * PYLIBRARY = __version__
 * PY_OZWAVE_CONFIG_DIRECTORY = "config"             # <<<<<<<<<<<<<<
 * OZWAVE_CONFIG_DIRECTORY = "share/openzwave/config"
 * CWD_CONFIG_DIRECTORY = "openzwave/config"
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PY_OZWAVE_CONFIG_DIRECTORY, __pyx_n_s_config) < 0) __PYX_ERR(0, 159, __pyx_L1_error)

  /* "libopenzwave.pyx":160
 * PYLIBRARY = __version__
 * PY_OZWAVE_CONFIG_DIRECTORY = "config"
 * OZWAVE_CONFIG_DIRECTORY = "share/openzwave/config"             # <<<<<<<<<<<<<<
 * CWD_CONFIG_DIRECTORY = "openzwave/config"
 * 
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OZWAVE_CONFIG_DIRECTORY, __pyx_kp_s_share_openzwave_config) < 0) __PYX_ERR(0, 160, __pyx_L1_error)

  /* "libopenzwave.pyx":161
 * PY_OZWAVE_CONFIG_DIRECTORY = "config"
 * OZWAVE_CONFIG_DIRECTORY = "share/openzwave/config"
 * CWD_CONFIG_DIRECTORY = "openzwave/config"             # <<<<<<<<<<<<<<
 * 
 * class EnumWithDoc(str):
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CWD_CONFIG_DIRECTORY, __pyx_kp_s_openzwave_config) < 0) __PYX_ERR(0, 161, __pyx_L1_error)

  /* "libopenzwave.pyx":163
 * CWD_CONFIG_DIRECTORY = "openzwave/config"
 * 
 * class EnumWithDoc(str):             # <<<<<<<<<<<<<<
 *     """Enum helper"""
 *     def setDoc(self, doc):
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 163, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(((PyObject *)(&PyString_Type)));
  __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyString_Type)));
  __pyx_t_7 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 163, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __pyx_t_9 = __Pyx_Py3MetaclassPrepare(__pyx_t_7, __pyx_t_1, __pyx_n_s_EnumWithDoc, __pyx_n_s_EnumWithDoc, (PyObject *) NULL, __pyx_n_s_libopenzwave, __pyx_kp_s_Enum_helper); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 163, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);

  /* "libopenzwave.pyx":165
 * class EnumWithDoc(str):
 *     """Enum helper"""
 *     def setDoc(self, doc):             # <<<<<<<<<<<<<<
 *         self.doc = doc
 *         return self
 */
  __pyx_t_2 = __Pyx_CyFunction_NewEx(&__pyx_mdef_12libopenzwave_11EnumWithDoc_1setDoc, 0, __pyx_n_s_EnumWithDoc_setDoc, NULL, __pyx_n_s_libopenzwave, __pyx_d, ((PyObject *)__pyx_codeobj__43)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 165, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyObject_SetItem(__pyx_t_9, __pyx_n_s_setDoc, __pyx_t_2) < 0) __PYX_ERR(0, 165, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "libopenzwave.pyx":163
 * CWD_CONFIG_DIRECTORY = "openzwave/config"
 * 
 * class EnumWithDoc(str):             # <<<<<<<<<<<<<<
 *     """Enum helper"""
 *     def setDoc(self, doc):
 */
  __pyx_t_2 = __Pyx_Py3ClassCreate(__pyx_t_7, __pyx_n_s_EnumWithDoc, __pyx_t_1, __pyx_t_9, NULL, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 163, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_EnumWithDoc, __pyx_t_2) < 0) __PYX_ERR(0, 163, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":170
 * 
 * PyNotifications = [
 *     EnumWithDoc('ValueAdded').setDoc("A new node value has been added to OpenZWave's set. These notifications occur after a node has been discovered, and details of its command classes have been received.  Each command class may generate one or more values depending on the complexity of the item being represented."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ValueRemoved').setDoc("A node value has been removed from OpenZWave's set.  This only occurs when a node is removed."),
 *     EnumWithDoc('ValueChanged').setDoc("A node value has been updated from the Z-Wave network and it is different from the previous value."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 170, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__44, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 170, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 170, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__45, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 170, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":171
 * PyNotifications = [
 *     EnumWithDoc('ValueAdded').setDoc("A new node value has been added to OpenZWave's set. These notifications occur after a node has been discovered, and details of its command classes have been received.  Each command class may generate one or more values depending on the complexity of the item being represented."),
 *     EnumWithDoc('ValueRemoved').setDoc("A node value has been removed from OpenZWave's set.  This only occurs when a node is removed."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ValueChanged').setDoc("A node value has been updated from the Z-Wave network and it is different from the previous value."),
 *     EnumWithDoc('ValueRefreshed').setDoc("A node value has been updated from the Z-Wave network."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 171, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__46, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 171, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_9, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 171, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__47, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 171, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":172
 *     EnumWithDoc('ValueAdded').setDoc("A new node value has been added to OpenZWave's set. These notifications occur after a node has been discovered, and details of its command classes have been received.  Each command class may generate one or more values depending on the complexity of the item being represented."),
 *     EnumWithDoc('ValueRemoved').setDoc("A node value has been removed from OpenZWave's set.  This only occurs when a node is removed."),
 *     EnumWithDoc('ValueChanged').setDoc("A node value has been updated from the Z-Wave network and it is different from the previous value."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ValueRefreshed').setDoc("A node value has been updated from the Z-Wave network."),
 *     EnumWithDoc('Group').setDoc("The associations for the node have changed. The application should rebuild any group information it holds about the node."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 172, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__48, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 172, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 172, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__49, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 172, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":173
 *     EnumWithDoc('ValueRemoved').setDoc("A node value has been removed from OpenZWave's set.  This only occurs when a node is removed."),
 *     EnumWithDoc('ValueChanged').setDoc("A node value has been updated from the Z-Wave network and it is different from the previous value."),
 *     EnumWithDoc('ValueRefreshed').setDoc("A node value has been updated from the Z-Wave network."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Group').setDoc("The associations for the node have changed. The application should rebuild any group information it holds about the node."),
 *     EnumWithDoc('NodeNew').setDoc("A new node has been found (not already stored in zwcfg*.xml file)."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 173, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__50, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 173, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 173, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__51, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 173, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":174
 *     EnumWithDoc('ValueChanged').setDoc("A node value has been updated from the Z-Wave network and it is different from the previous value."),
 *     EnumWithDoc('ValueRefreshed').setDoc("A node value has been updated from the Z-Wave network."),
 *     EnumWithDoc('Group').setDoc("The associations for the node have changed. The application should rebuild any group information it holds about the node."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeNew').setDoc("A new node has been found (not already stored in zwcfg*.xml file)."),
 *     EnumWithDoc('NodeAdded').setDoc("A new node has been added to OpenZWave's set.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 174, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_10 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__52, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 174, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_10);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_10, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 174, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
  __pyx_t_10 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__53, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 174, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_10);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":175
 *     EnumWithDoc('ValueRefreshed').setDoc("A node value has been updated from the Z-Wave network."),
 *     EnumWithDoc('Group').setDoc("The associations for the node have changed. The application should rebuild any group information it holds about the node."),
 *     EnumWithDoc('NodeNew').setDoc("A new node has been found (not already stored in zwcfg*.xml file)."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeAdded').setDoc("A new node has been added to OpenZWave's set.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself."),
 *     EnumWithDoc('NodeRemoved').setDoc("A node has been removed from OpenZWave's set.  This may be due to a device being removed from the Z-Wave network, or because the application is closing."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 175, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_11 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__54, NULL); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 175, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_11);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_11, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 175, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
  __pyx_t_11 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__55, NULL); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 175, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_11);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":176
 *     EnumWithDoc('Group').setDoc("The associations for the node have changed. The application should rebuild any group information it holds about the node."),
 *     EnumWithDoc('NodeNew').setDoc("A new node has been found (not already stored in zwcfg*.xml file)."),
 *     EnumWithDoc('NodeAdded').setDoc("A new node has been added to OpenZWave's set.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeRemoved').setDoc("A node has been removed from OpenZWave's set.  This may be due to a device being removed from the Z-Wave network, or because the application is closing."),
 *     EnumWithDoc('NodeProtocolInfo').setDoc("Basic node information has been receievd, such as whether the node is a setening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 176, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_13 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__56, NULL); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 176, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_13);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_13, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 176, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
  __pyx_t_13 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__57, NULL); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 176, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_13);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":177
 *     EnumWithDoc('NodeNew').setDoc("A new node has been found (not already stored in zwcfg*.xml file)."),
 *     EnumWithDoc('NodeAdded').setDoc("A new node has been added to OpenZWave's set.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself."),
 *     EnumWithDoc('NodeRemoved').setDoc("A node has been removed from OpenZWave's set.  This may be due to a device being removed from the Z-Wave network, or because the application is closing."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeProtocolInfo').setDoc("Basic node information has been receievd, such as whether the node is a setening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description."),
 *     EnumWithDoc('NodeNaming').setDoc("One of the node names has changed (name, manufacturer, product)."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 177, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_14 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__58, NULL); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 177, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_14);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_14, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 177, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
  __pyx_t_14 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__59, NULL); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 177, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_14);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":178
 *     EnumWithDoc('NodeAdded').setDoc("A new node has been added to OpenZWave's set.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself."),
 *     EnumWithDoc('NodeRemoved').setDoc("A node has been removed from OpenZWave's set.  This may be due to a device being removed from the Z-Wave network, or because the application is closing."),
 *     EnumWithDoc('NodeProtocolInfo').setDoc("Basic node information has been receievd, such as whether the node is a setening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeNaming').setDoc("One of the node names has changed (name, manufacturer, product)."),
 *     EnumWithDoc('NodeEvent').setDoc("A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 178, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_15 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__60, NULL); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 178, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_15);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_15, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 178, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
  __pyx_t_15 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__61, NULL); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 178, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_15);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":179
 *     EnumWithDoc('NodeRemoved').setDoc("A node has been removed from OpenZWave's set.  This may be due to a device being removed from the Z-Wave network, or because the application is closing."),
 *     EnumWithDoc('NodeProtocolInfo').setDoc("Basic node information has been receievd, such as whether the node is a setening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description."),
 *     EnumWithDoc('NodeNaming').setDoc("One of the node names has changed (name, manufacturer, product)."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeEvent').setDoc("A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification."),
 *     EnumWithDoc('PollingDisabled').setDoc("Polling of a node has been successfully turned off by a call to Manager::DisablePoll."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 179, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_16 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__62, NULL); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 179, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_16);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_16, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 179, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
  __pyx_t_16 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__63, NULL); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 179, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_16);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":180
 *     EnumWithDoc('NodeProtocolInfo').setDoc("Basic node information has been receievd, such as whether the node is a setening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description."),
 *     EnumWithDoc('NodeNaming').setDoc("One of the node names has changed (name, manufacturer, product)."),
 *     EnumWithDoc('NodeEvent').setDoc("A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('PollingDisabled').setDoc("Polling of a node has been successfully turned off by a call to Manager::DisablePoll."),
 *     EnumWithDoc('PollingEnabled').setDoc("Polling of a node has been successfully turned on by a call to Manager::EnablePoll."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 180, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_17 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__64, NULL); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 180, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_17);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_17, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 180, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
  __pyx_t_17 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__65, NULL); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 180, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_17);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":181
 *     EnumWithDoc('NodeNaming').setDoc("One of the node names has changed (name, manufacturer, product)."),
 *     EnumWithDoc('NodeEvent').setDoc("A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification."),
 *     EnumWithDoc('PollingDisabled').setDoc("Polling of a node has been successfully turned off by a call to Manager::DisablePoll."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('PollingEnabled').setDoc("Polling of a node has been successfully turned on by a call to Manager::EnablePoll."),
 *     EnumWithDoc('SceneEvent').setDoc("Scene Activation Set received."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 181, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_18 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__66, NULL); if (unlikely(!__pyx_t_18)) __PYX_ERR(0, 181, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_18);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_18, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 181, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_18); __pyx_t_18 = 0;
  __pyx_t_18 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__67, NULL); if (unlikely(!__pyx_t_18)) __PYX_ERR(0, 181, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_18);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":182
 *     EnumWithDoc('NodeEvent').setDoc("A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification."),
 *     EnumWithDoc('PollingDisabled').setDoc("Polling of a node has been successfully turned off by a call to Manager::DisablePoll."),
 *     EnumWithDoc('PollingEnabled').setDoc("Polling of a node has been successfully turned on by a call to Manager::EnablePoll."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('SceneEvent').setDoc("Scene Activation Set received."),
 *     EnumWithDoc('CreateButton').setDoc("Handheld controller button event created."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 182, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_19 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__68, NULL); if (unlikely(!__pyx_t_19)) __PYX_ERR(0, 182, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_19);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_19, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 182, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_19); __pyx_t_19 = 0;
  __pyx_t_19 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__69, NULL); if (unlikely(!__pyx_t_19)) __PYX_ERR(0, 182, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_19);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":183
 *     EnumWithDoc('PollingDisabled').setDoc("Polling of a node has been successfully turned off by a call to Manager::DisablePoll."),
 *     EnumWithDoc('PollingEnabled').setDoc("Polling of a node has been successfully turned on by a call to Manager::EnablePoll."),
 *     EnumWithDoc('SceneEvent').setDoc("Scene Activation Set received."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('CreateButton').setDoc("Handheld controller button event created."),
 *     EnumWithDoc('DeleteButton').setDoc("Handheld controller button event deleted."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 183, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_20 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__70, NULL); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 183, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_20);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_20, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 183, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
  __pyx_t_20 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__71, NULL); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 183, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_20);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":184
 *     EnumWithDoc('PollingEnabled').setDoc("Polling of a node has been successfully turned on by a call to Manager::EnablePoll."),
 *     EnumWithDoc('SceneEvent').setDoc("Scene Activation Set received."),
 *     EnumWithDoc('CreateButton').setDoc("Handheld controller button event created."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('DeleteButton').setDoc("Handheld controller button event deleted."),
 *     EnumWithDoc('ButtonOn').setDoc("Handheld controller button on pressed event."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 184, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_21 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__72, NULL); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 184, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_21);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_21, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 184, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
  __pyx_t_21 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__73, NULL); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 184, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_21);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":185
 *     EnumWithDoc('SceneEvent').setDoc("Scene Activation Set received."),
 *     EnumWithDoc('CreateButton').setDoc("Handheld controller button event created."),
 *     EnumWithDoc('DeleteButton').setDoc("Handheld controller button event deleted."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ButtonOn').setDoc("Handheld controller button on pressed event."),
 *     EnumWithDoc('ButtonOff').setDoc("Handheld controller button off pressed event."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_22 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__74, NULL); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_22);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_22, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
  __pyx_t_22 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__75, NULL); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_22);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":186
 *     EnumWithDoc('CreateButton').setDoc("Handheld controller button event created."),
 *     EnumWithDoc('DeleteButton').setDoc("Handheld controller button event deleted."),
 *     EnumWithDoc('ButtonOn').setDoc("Handheld controller button on pressed event."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ButtonOff').setDoc("Handheld controller button off pressed event."),
 *     EnumWithDoc('DriverReady').setDoc("A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_23 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__76, NULL); if (unlikely(!__pyx_t_23)) __PYX_ERR(0, 186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_23);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_23, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_23); __pyx_t_23 = 0;
  __pyx_t_23 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__77, NULL); if (unlikely(!__pyx_t_23)) __PYX_ERR(0, 186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_23);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":187
 *     EnumWithDoc('DeleteButton').setDoc("Handheld controller button event deleted."),
 *     EnumWithDoc('ButtonOn').setDoc("Handheld controller button on pressed event."),
 *     EnumWithDoc('ButtonOff').setDoc("Handheld controller button off pressed event."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('DriverReady').setDoc("A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods."),
 *     EnumWithDoc('DriverFailed').setDoc("Driver failed to load."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 187, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_24 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__78, NULL); if (unlikely(!__pyx_t_24)) __PYX_ERR(0, 187, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_24);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_24, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 187, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_24); __pyx_t_24 = 0;
  __pyx_t_24 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__79, NULL); if (unlikely(!__pyx_t_24)) __PYX_ERR(0, 187, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_24);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":188
 *     EnumWithDoc('ButtonOn').setDoc("Handheld controller button on pressed event."),
 *     EnumWithDoc('ButtonOff').setDoc("Handheld controller button off pressed event."),
 *     EnumWithDoc('DriverReady').setDoc("A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('DriverFailed').setDoc("Driver failed to load."),
 *     EnumWithDoc('DriverReset').setDoc("All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 188, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_25 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__80, NULL); if (unlikely(!__pyx_t_25)) __PYX_ERR(0, 188, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_25);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_25, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 188, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_25); __pyx_t_25 = 0;
  __pyx_t_25 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__81, NULL); if (unlikely(!__pyx_t_25)) __PYX_ERR(0, 188, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_25);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":189
 *     EnumWithDoc('ButtonOff').setDoc("Handheld controller button off pressed event."),
 *     EnumWithDoc('DriverReady').setDoc("A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods."),
 *     EnumWithDoc('DriverFailed').setDoc("Driver failed to load."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('DriverReset').setDoc("All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications."),
 *     EnumWithDoc('EssentialNodeQueriesComplete').setDoc("The queries on a node that are essential to its operation have been completed. The node can now handle incoming messages."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 189, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_26 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__82, NULL); if (unlikely(!__pyx_t_26)) __PYX_ERR(0, 189, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_26);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_26, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 189, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_26); __pyx_t_26 = 0;
  __pyx_t_26 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__83, NULL); if (unlikely(!__pyx_t_26)) __PYX_ERR(0, 189, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_26);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":190
 *     EnumWithDoc('DriverReady').setDoc("A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods."),
 *     EnumWithDoc('DriverFailed').setDoc("Driver failed to load."),
 *     EnumWithDoc('DriverReset').setDoc("All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('EssentialNodeQueriesComplete').setDoc("The queries on a node that are essential to its operation have been completed. The node can now handle incoming messages."),
 *     EnumWithDoc('NodeQueriesComplete').setDoc("All the initialisation queries on a node have been completed."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_27 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__84, NULL); if (unlikely(!__pyx_t_27)) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_27);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_27, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_27); __pyx_t_27 = 0;
  __pyx_t_27 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__85, NULL); if (unlikely(!__pyx_t_27)) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_27);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":191
 *     EnumWithDoc('DriverFailed').setDoc("Driver failed to load."),
 *     EnumWithDoc('DriverReset').setDoc("All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications."),
 *     EnumWithDoc('EssentialNodeQueriesComplete').setDoc("The queries on a node that are essential to its operation have been completed. The node can now handle incoming messages."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeQueriesComplete').setDoc("All the initialisation queries on a node have been completed."),
 *     EnumWithDoc('AwakeNodesQueried').setDoc("All awake nodes have been queried, so client application can expected complete data for these nodes."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 191, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_28 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__86, NULL); if (unlikely(!__pyx_t_28)) __PYX_ERR(0, 191, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_28);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_28, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 191, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_28); __pyx_t_28 = 0;
  __pyx_t_28 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__87, NULL); if (unlikely(!__pyx_t_28)) __PYX_ERR(0, 191, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_28);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":192
 *     EnumWithDoc('DriverReset').setDoc("All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications."),
 *     EnumWithDoc('EssentialNodeQueriesComplete').setDoc("The queries on a node that are essential to its operation have been completed. The node can now handle incoming messages."),
 *     EnumWithDoc('NodeQueriesComplete').setDoc("All the initialisation queries on a node have been completed."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('AwakeNodesQueried').setDoc("All awake nodes have been queried, so client application can expected complete data for these nodes."),
 *     EnumWithDoc('AllNodesQueriedSomeDead').setDoc("All nodes have been queried but some dead nodes found."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_29 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__88, NULL); if (unlikely(!__pyx_t_29)) __PYX_ERR(0, 192, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_29);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_29, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_29); __pyx_t_29 = 0;
  __pyx_t_29 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__89, NULL); if (unlikely(!__pyx_t_29)) __PYX_ERR(0, 192, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_29);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":193
 *     EnumWithDoc('EssentialNodeQueriesComplete').setDoc("The queries on a node that are essential to its operation have been completed. The node can now handle incoming messages."),
 *     EnumWithDoc('NodeQueriesComplete').setDoc("All the initialisation queries on a node have been completed."),
 *     EnumWithDoc('AwakeNodesQueried').setDoc("All awake nodes have been queried, so client application can expected complete data for these nodes."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('AllNodesQueriedSomeDead').setDoc("All nodes have been queried but some dead nodes found."),
 *     EnumWithDoc('AllNodesQueried').setDoc("All nodes have been queried, so client application can expected complete data."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 193, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__90, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 193, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_30, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 193, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_30); __pyx_t_30 = 0;
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__91, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 193, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":194
 *     EnumWithDoc('NodeQueriesComplete').setDoc("All the initialisation queries on a node have been completed."),
 *     EnumWithDoc('AwakeNodesQueried').setDoc("All awake nodes have been queried, so client application can expected complete data for these nodes."),
 *     EnumWithDoc('AllNodesQueriedSomeDead').setDoc("All nodes have been queried but some dead nodes found."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('AllNodesQueried').setDoc("All nodes have been queried, so client application can expected complete data."),
 *     EnumWithDoc('Notification').setDoc("A manager notification report."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 194, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_31 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__92, NULL); if (unlikely(!__pyx_t_31)) __PYX_ERR(0, 194, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_31);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_31, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 194, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_31); __pyx_t_31 = 0;
  __pyx_t_31 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__93, NULL); if (unlikely(!__pyx_t_31)) __PYX_ERR(0, 194, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_31);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":195
 *     EnumWithDoc('AwakeNodesQueried').setDoc("All awake nodes have been queried, so client application can expected complete data for these nodes."),
 *     EnumWithDoc('AllNodesQueriedSomeDead').setDoc("All nodes have been queried but some dead nodes found."),
 *     EnumWithDoc('AllNodesQueried').setDoc("All nodes have been queried, so client application can expected complete data."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Notification').setDoc("A manager notification report."),
 *     EnumWithDoc('DriverRemoved').setDoc("The Driver is being removed."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_32 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__94, NULL); if (unlikely(!__pyx_t_32)) __PYX_ERR(0, 195, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_32);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_32, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_32); __pyx_t_32 = 0;
  __pyx_t_32 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__95, NULL); if (unlikely(!__pyx_t_32)) __PYX_ERR(0, 195, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_32);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":196
 *     EnumWithDoc('AllNodesQueriedSomeDead').setDoc("All nodes have been queried but some dead nodes found."),
 *     EnumWithDoc('AllNodesQueried').setDoc("All nodes have been queried, so client application can expected complete data."),
 *     EnumWithDoc('Notification').setDoc("A manager notification report."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('DriverRemoved').setDoc("The Driver is being removed."),
 *     EnumWithDoc('ControllerCommand').setDoc("When Controller Commands are executed, Notifications of Success/Failure etc are communicated via this Notification."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 196, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_33 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__96, NULL); if (unlikely(!__pyx_t_33)) __PYX_ERR(0, 196, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_33);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_33, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 196, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_33); __pyx_t_33 = 0;
  __pyx_t_33 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__97, NULL); if (unlikely(!__pyx_t_33)) __PYX_ERR(0, 196, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_33);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":197
 *     EnumWithDoc('AllNodesQueried').setDoc("All nodes have been queried, so client application can expected complete data."),
 *     EnumWithDoc('Notification').setDoc("A manager notification report."),
 *     EnumWithDoc('DriverRemoved').setDoc("The Driver is being removed."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ControllerCommand').setDoc("When Controller Commands are executed, Notifications of Success/Failure etc are communicated via this Notification."),
 *     EnumWithDoc('NodeReset').setDoc("A node has been reset from OpenZWave's set.  The Device has been reset and thus removed from the NodeList in OZW."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 197, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__98, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 197, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_34, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 197, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_34); __pyx_t_34 = 0;
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__99, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 197, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":198
 *     EnumWithDoc('Notification').setDoc("A manager notification report."),
 *     EnumWithDoc('DriverRemoved').setDoc("The Driver is being removed."),
 *     EnumWithDoc('ControllerCommand').setDoc("When Controller Commands are executed, Notifications of Success/Failure etc are communicated via this Notification."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeReset').setDoc("A node has been reset from OpenZWave's set.  The Device has been reset and thus removed from the NodeList in OZW."),
 *     ]
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 198, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__100, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 198, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_35, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 198, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_35); __pyx_t_35 = 0;
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__101, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 198, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":199
 *     EnumWithDoc('DriverRemoved').setDoc("The Driver is being removed."),
 *     EnumWithDoc('ControllerCommand').setDoc("When Controller Commands are executed, Notifications of Success/Failure etc are communicated via this Notification."),
 *     EnumWithDoc('NodeReset').setDoc("A node has been reset from OpenZWave's set.  The Device has been reset and thus removed from the NodeList in OZW."),             # <<<<<<<<<<<<<<
 *     ]
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 199, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_36 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__102, NULL); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 199, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_36, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 199, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;
  __pyx_t_36 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__103, NULL); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 199, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":169
 *         return self
 * 
 * PyNotifications = [             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ValueAdded').setDoc("A new node value has been added to OpenZWave's set. These notifications occur after a node has been discovered, and details of its command classes have been received.  Each command class may generate one or more values depending on the complexity of the item being represented."),
 *     EnumWithDoc('ValueRemoved').setDoc("A node value has been removed from OpenZWave's set.  This only occurs when a node is removed."),
 */
  __pyx_t_1 = PyList_New(30); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 169, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_7);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_t_7);
  __Pyx_GIVEREF(__pyx_t_9);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_t_9);
  __Pyx_GIVEREF(__pyx_t_2);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_8);
  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_t_8);
  __Pyx_GIVEREF(__pyx_t_10);
  PyList_SET_ITEM(__pyx_t_1, 4, __pyx_t_10);
  __Pyx_GIVEREF(__pyx_t_11);
  PyList_SET_ITEM(__pyx_t_1, 5, __pyx_t_11);
  __Pyx_GIVEREF(__pyx_t_13);
  PyList_SET_ITEM(__pyx_t_1, 6, __pyx_t_13);
  __Pyx_GIVEREF(__pyx_t_14);
  PyList_SET_ITEM(__pyx_t_1, 7, __pyx_t_14);
  __Pyx_GIVEREF(__pyx_t_15);
  PyList_SET_ITEM(__pyx_t_1, 8, __pyx_t_15);
  __Pyx_GIVEREF(__pyx_t_16);
  PyList_SET_ITEM(__pyx_t_1, 9, __pyx_t_16);
  __Pyx_GIVEREF(__pyx_t_17);
  PyList_SET_ITEM(__pyx_t_1, 10, __pyx_t_17);
  __Pyx_GIVEREF(__pyx_t_18);
  PyList_SET_ITEM(__pyx_t_1, 11, __pyx_t_18);
  __Pyx_GIVEREF(__pyx_t_19);
  PyList_SET_ITEM(__pyx_t_1, 12, __pyx_t_19);
  __Pyx_GIVEREF(__pyx_t_20);
  PyList_SET_ITEM(__pyx_t_1, 13, __pyx_t_20);
  __Pyx_GIVEREF(__pyx_t_21);
  PyList_SET_ITEM(__pyx_t_1, 14, __pyx_t_21);
  __Pyx_GIVEREF(__pyx_t_22);
  PyList_SET_ITEM(__pyx_t_1, 15, __pyx_t_22);
  __Pyx_GIVEREF(__pyx_t_23);
  PyList_SET_ITEM(__pyx_t_1, 16, __pyx_t_23);
  __Pyx_GIVEREF(__pyx_t_24);
  PyList_SET_ITEM(__pyx_t_1, 17, __pyx_t_24);
  __Pyx_GIVEREF(__pyx_t_25);
  PyList_SET_ITEM(__pyx_t_1, 18, __pyx_t_25);
  __Pyx_GIVEREF(__pyx_t_26);
  PyList_SET_ITEM(__pyx_t_1, 19, __pyx_t_26);
  __Pyx_GIVEREF(__pyx_t_27);
  PyList_SET_ITEM(__pyx_t_1, 20, __pyx_t_27);
  __Pyx_GIVEREF(__pyx_t_28);
  PyList_SET_ITEM(__pyx_t_1, 21, __pyx_t_28);
  __Pyx_GIVEREF(__pyx_t_29);
  PyList_SET_ITEM(__pyx_t_1, 22, __pyx_t_29);
  __Pyx_GIVEREF(__pyx_t_30);
  PyList_SET_ITEM(__pyx_t_1, 23, __pyx_t_30);
  __Pyx_GIVEREF(__pyx_t_31);
  PyList_SET_ITEM(__pyx_t_1, 24, __pyx_t_31);
  __Pyx_GIVEREF(__pyx_t_32);
  PyList_SET_ITEM(__pyx_t_1, 25, __pyx_t_32);
  __Pyx_GIVEREF(__pyx_t_33);
  PyList_SET_ITEM(__pyx_t_1, 26, __pyx_t_33);
  __Pyx_GIVEREF(__pyx_t_34);
  PyList_SET_ITEM(__pyx_t_1, 27, __pyx_t_34);
  __Pyx_GIVEREF(__pyx_t_35);
  PyList_SET_ITEM(__pyx_t_1, 28, __pyx_t_35);
  __Pyx_GIVEREF(__pyx_t_36);
  PyList_SET_ITEM(__pyx_t_1, 29, __pyx_t_36);
  __pyx_t_7 = 0;
  __pyx_t_9 = 0;
  __pyx_t_2 = 0;
  __pyx_t_8 = 0;
  __pyx_t_10 = 0;
  __pyx_t_11 = 0;
  __pyx_t_13 = 0;
  __pyx_t_14 = 0;
  __pyx_t_15 = 0;
  __pyx_t_16 = 0;
  __pyx_t_17 = 0;
  __pyx_t_18 = 0;
  __pyx_t_19 = 0;
  __pyx_t_20 = 0;
  __pyx_t_21 = 0;
  __pyx_t_22 = 0;
  __pyx_t_23 = 0;
  __pyx_t_24 = 0;
  __pyx_t_25 = 0;
  __pyx_t_26 = 0;
  __pyx_t_27 = 0;
  __pyx_t_28 = 0;
  __pyx_t_29 = 0;
  __pyx_t_30 = 0;
  __pyx_t_31 = 0;
  __pyx_t_32 = 0;
  __pyx_t_33 = 0;
  __pyx_t_34 = 0;
  __pyx_t_35 = 0;
  __pyx_t_36 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PyNotifications, __pyx_t_1) < 0) __PYX_ERR(0, 169, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":203
 * 
 * PyNotificationCodes = [
 *     EnumWithDoc('MsgComplete').setDoc("Completed messages."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Timeout').setDoc("Messages that timeout will send a Notification with this code."),
 *     EnumWithDoc('NoOperation').setDoc("Report on NoOperation message sent completion."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 203, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_36 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__104, NULL); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 203, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_36, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 203, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;
  __pyx_t_36 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__105, NULL); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 203, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":204
 * PyNotificationCodes = [
 *     EnumWithDoc('MsgComplete').setDoc("Completed messages."),
 *     EnumWithDoc('Timeout').setDoc("Messages that timeout will send a Notification with this code."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NoOperation').setDoc("Report on NoOperation message sent completion."),
 *     EnumWithDoc('Awake').setDoc("Report when a sleeping node wakes."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__106, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_35, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_35); __pyx_t_35 = 0;
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__107, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":205
 *     EnumWithDoc('MsgComplete').setDoc("Completed messages."),
 *     EnumWithDoc('Timeout').setDoc("Messages that timeout will send a Notification with this code."),
 *     EnumWithDoc('NoOperation').setDoc("Report on NoOperation message sent completion."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Awake').setDoc("Report when a sleeping node wakes."),
 *     EnumWithDoc('Sleep').setDoc("Report when a node goes to sleep."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 205, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__108, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 205, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_34, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 205, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_34); __pyx_t_34 = 0;
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__109, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 205, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":206
 *     EnumWithDoc('Timeout').setDoc("Messages that timeout will send a Notification with this code."),
 *     EnumWithDoc('NoOperation').setDoc("Report on NoOperation message sent completion."),
 *     EnumWithDoc('Awake').setDoc("Report when a sleeping node wakes."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Sleep').setDoc("Report when a node goes to sleep."),
 *     EnumWithDoc('Dead').setDoc("Report when a node is presumed dead."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 206, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_33 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__110, NULL); if (unlikely(!__pyx_t_33)) __PYX_ERR(0, 206, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_33);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_33, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 206, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_33); __pyx_t_33 = 0;
  __pyx_t_33 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__111, NULL); if (unlikely(!__pyx_t_33)) __PYX_ERR(0, 206, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_33);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":207
 *     EnumWithDoc('NoOperation').setDoc("Report on NoOperation message sent completion."),
 *     EnumWithDoc('Awake').setDoc("Report when a sleeping node wakes."),
 *     EnumWithDoc('Sleep').setDoc("Report when a node goes to sleep."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Dead').setDoc("Report when a node is presumed dead."),
 *     EnumWithDoc('Alive').setDoc("Report when a node is revived."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 207, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_32 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__112, NULL); if (unlikely(!__pyx_t_32)) __PYX_ERR(0, 207, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_32);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_32, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 207, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_32); __pyx_t_32 = 0;
  __pyx_t_32 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__113, NULL); if (unlikely(!__pyx_t_32)) __PYX_ERR(0, 207, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_32);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":208
 *     EnumWithDoc('Awake').setDoc("Report when a sleeping node wakes."),
 *     EnumWithDoc('Sleep').setDoc("Report when a node goes to sleep."),
 *     EnumWithDoc('Dead').setDoc("Report when a node is presumed dead."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Alive').setDoc("Report when a node is revived."),
 *     ]
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_31 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__114, NULL); if (unlikely(!__pyx_t_31)) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_31);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_31, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_31); __pyx_t_31 = 0;
  __pyx_t_31 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__115, NULL); if (unlikely(!__pyx_t_31)) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_31);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":209
 *     EnumWithDoc('Sleep').setDoc("Report when a node goes to sleep."),
 *     EnumWithDoc('Dead').setDoc("Report when a node is presumed dead."),
 *     EnumWithDoc('Alive').setDoc("Report when a node is revived."),             # <<<<<<<<<<<<<<
 *     ]
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 209, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__116, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 209, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_30, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 209, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_30); __pyx_t_30 = 0;
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__117, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 209, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":202
 *     ]
 * 
 * PyNotificationCodes = [             # <<<<<<<<<<<<<<
 *     EnumWithDoc('MsgComplete').setDoc("Completed messages."),
 *     EnumWithDoc('Timeout').setDoc("Messages that timeout will send a Notification with this code."),
 */
  __pyx_t_1 = PyList_New(7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 202, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_36);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_t_36);
  __Pyx_GIVEREF(__pyx_t_35);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_t_35);
  __Pyx_GIVEREF(__pyx_t_34);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_t_34);
  __Pyx_GIVEREF(__pyx_t_33);
  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_t_33);
  __Pyx_GIVEREF(__pyx_t_32);
  PyList_SET_ITEM(__pyx_t_1, 4, __pyx_t_32);
  __Pyx_GIVEREF(__pyx_t_31);
  PyList_SET_ITEM(__pyx_t_1, 5, __pyx_t_31);
  __Pyx_GIVEREF(__pyx_t_30);
  PyList_SET_ITEM(__pyx_t_1, 6, __pyx_t_30);
  __pyx_t_36 = 0;
  __pyx_t_35 = 0;
  __pyx_t_34 = 0;
  __pyx_t_33 = 0;
  __pyx_t_32 = 0;
  __pyx_t_31 = 0;
  __pyx_t_30 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PyNotificationCodes, __pyx_t_1) < 0) __PYX_ERR(0, 202, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":213
 * 
 * PyGenres = [
 *     EnumWithDoc('Basic').setDoc("The 'level' as controlled by basic commands.  Usually duplicated by another command class."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('User').setDoc("Basic values an ordinary user would be interested in."),
 *     EnumWithDoc('Config').setDoc("Device-specific configuration parameters.  These cannot be automatically discovered via Z-Wave, and are usually described in the user manual instead."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 213, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__118, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 213, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_30, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 213, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_30); __pyx_t_30 = 0;
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__119, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 213, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":214
 * PyGenres = [
 *     EnumWithDoc('Basic').setDoc("The 'level' as controlled by basic commands.  Usually duplicated by another command class."),
 *     EnumWithDoc('User').setDoc("Basic values an ordinary user would be interested in."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Config').setDoc("Device-specific configuration parameters.  These cannot be automatically discovered via Z-Wave, and are usually described in the user manual instead."),
 *     EnumWithDoc('System').setDoc("Values of significance only to users who understand the Z-Wave protocol"),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_31 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__120, NULL); if (unlikely(!__pyx_t_31)) __PYX_ERR(0, 214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_31);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_31, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_31); __pyx_t_31 = 0;
  __pyx_t_31 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__121, NULL); if (unlikely(!__pyx_t_31)) __PYX_ERR(0, 214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_31);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":215
 *     EnumWithDoc('Basic').setDoc("The 'level' as controlled by basic commands.  Usually duplicated by another command class."),
 *     EnumWithDoc('User').setDoc("Basic values an ordinary user would be interested in."),
 *     EnumWithDoc('Config').setDoc("Device-specific configuration parameters.  These cannot be automatically discovered via Z-Wave, and are usually described in the user manual instead."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('System').setDoc("Values of significance only to users who understand the Z-Wave protocol"),
 *     ]
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 215, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_32 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__122, NULL); if (unlikely(!__pyx_t_32)) __PYX_ERR(0, 215, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_32);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_32, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 215, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_32); __pyx_t_32 = 0;
  __pyx_t_32 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__123, NULL); if (unlikely(!__pyx_t_32)) __PYX_ERR(0, 215, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_32);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":216
 *     EnumWithDoc('User').setDoc("Basic values an ordinary user would be interested in."),
 *     EnumWithDoc('Config').setDoc("Device-specific configuration parameters.  These cannot be automatically discovered via Z-Wave, and are usually described in the user manual instead."),
 *     EnumWithDoc('System').setDoc("Values of significance only to users who understand the Z-Wave protocol"),             # <<<<<<<<<<<<<<
 *     ]
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 216, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_33 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__124, NULL); if (unlikely(!__pyx_t_33)) __PYX_ERR(0, 216, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_33);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_33, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 216, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_33); __pyx_t_33 = 0;
  __pyx_t_33 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__125, NULL); if (unlikely(!__pyx_t_33)) __PYX_ERR(0, 216, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_33);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":212
 *     ]
 * 
 * PyGenres = [             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Basic').setDoc("The 'level' as controlled by basic commands.  Usually duplicated by another command class."),
 *     EnumWithDoc('User').setDoc("Basic values an ordinary user would be interested in."),
 */
  __pyx_t_1 = PyList_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 212, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_30);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_t_30);
  __Pyx_GIVEREF(__pyx_t_31);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_t_31);
  __Pyx_GIVEREF(__pyx_t_32);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_t_32);
  __Pyx_GIVEREF(__pyx_t_33);
  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_t_33);
  __pyx_t_30 = 0;
  __pyx_t_31 = 0;
  __pyx_t_32 = 0;
  __pyx_t_33 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PyGenres, __pyx_t_1) < 0) __PYX_ERR(0, 212, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":220
 * 
 * PyValueTypes = [
 *     EnumWithDoc('Bool').setDoc("Boolean, true or false"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Byte').setDoc("8-bit unsigned value"),
 *     EnumWithDoc('Decimal').setDoc("Represents a non-integer value as a string, to avoid floating point accuracy issues."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 220, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_33 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__126, NULL); if (unlikely(!__pyx_t_33)) __PYX_ERR(0, 220, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_33);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_33, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 220, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_33); __pyx_t_33 = 0;
  __pyx_t_33 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__127, NULL); if (unlikely(!__pyx_t_33)) __PYX_ERR(0, 220, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_33);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":221
 * PyValueTypes = [
 *     EnumWithDoc('Bool').setDoc("Boolean, true or false"),
 *     EnumWithDoc('Byte').setDoc("8-bit unsigned value"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Decimal').setDoc("Represents a non-integer value as a string, to avoid floating point accuracy issues."),
 *     EnumWithDoc('Int').setDoc("32-bit signed value"),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 221, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_32 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__128, NULL); if (unlikely(!__pyx_t_32)) __PYX_ERR(0, 221, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_32);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_32, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 221, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_32); __pyx_t_32 = 0;
  __pyx_t_32 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__129, NULL); if (unlikely(!__pyx_t_32)) __PYX_ERR(0, 221, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_32);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":222
 *     EnumWithDoc('Bool').setDoc("Boolean, true or false"),
 *     EnumWithDoc('Byte').setDoc("8-bit unsigned value"),
 *     EnumWithDoc('Decimal').setDoc("Represents a non-integer value as a string, to avoid floating point accuracy issues."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Int').setDoc("32-bit signed value"),
 *     EnumWithDoc('List').setDoc("List from which one item can be selected"),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 222, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_31 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__130, NULL); if (unlikely(!__pyx_t_31)) __PYX_ERR(0, 222, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_31);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_31, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 222, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_31); __pyx_t_31 = 0;
  __pyx_t_31 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__131, NULL); if (unlikely(!__pyx_t_31)) __PYX_ERR(0, 222, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_31);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":223
 *     EnumWithDoc('Byte').setDoc("8-bit unsigned value"),
 *     EnumWithDoc('Decimal').setDoc("Represents a non-integer value as a string, to avoid floating point accuracy issues."),
 *     EnumWithDoc('Int').setDoc("32-bit signed value"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('List').setDoc("List from which one item can be selected"),
 *     EnumWithDoc('Schedule').setDoc("Complex type used with the Climate Control Schedule command class"),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 223, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__132, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 223, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_30, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 223, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_30); __pyx_t_30 = 0;
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__133, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 223, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":224
 *     EnumWithDoc('Decimal').setDoc("Represents a non-integer value as a string, to avoid floating point accuracy issues."),
 *     EnumWithDoc('Int').setDoc("32-bit signed value"),
 *     EnumWithDoc('List').setDoc("List from which one item can be selected"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Schedule').setDoc("Complex type used with the Climate Control Schedule command class"),
 *     EnumWithDoc('Short').setDoc("16-bit signed value"),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 224, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__134, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 224, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_34, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 224, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_34); __pyx_t_34 = 0;
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__135, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 224, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":225
 *     EnumWithDoc('Int').setDoc("32-bit signed value"),
 *     EnumWithDoc('List').setDoc("List from which one item can be selected"),
 *     EnumWithDoc('Schedule').setDoc("Complex type used with the Climate Control Schedule command class"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Short').setDoc("16-bit signed value"),
 *     EnumWithDoc('String').setDoc("Text string"),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 225, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__136, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 225, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_35, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 225, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_35); __pyx_t_35 = 0;
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__137, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 225, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":226
 *     EnumWithDoc('List').setDoc("List from which one item can be selected"),
 *     EnumWithDoc('Schedule').setDoc("Complex type used with the Climate Control Schedule command class"),
 *     EnumWithDoc('Short').setDoc("16-bit signed value"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('String').setDoc("Text string"),
 *     EnumWithDoc('Button').setDoc("A write-only value that is the equivalent of pressing a button to send a command to a device"),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 226, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_36 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__138, NULL); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 226, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_36, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 226, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;
  __pyx_t_36 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__139, NULL); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 226, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":227
 *     EnumWithDoc('Schedule').setDoc("Complex type used with the Climate Control Schedule command class"),
 *     EnumWithDoc('Short').setDoc("16-bit signed value"),
 *     EnumWithDoc('String').setDoc("Text string"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Button').setDoc("A write-only value that is the equivalent of pressing a button to send a command to a device"),
 *     EnumWithDoc('Raw').setDoc("Raw byte values"),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 227, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_29 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__140, NULL); if (unlikely(!__pyx_t_29)) __PYX_ERR(0, 227, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_29);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_29, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 227, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_29); __pyx_t_29 = 0;
  __pyx_t_29 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__141, NULL); if (unlikely(!__pyx_t_29)) __PYX_ERR(0, 227, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_29);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":228
 *     EnumWithDoc('Short').setDoc("16-bit signed value"),
 *     EnumWithDoc('String').setDoc("Text string"),
 *     EnumWithDoc('Button').setDoc("A write-only value that is the equivalent of pressing a button to send a command to a device"),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Raw').setDoc("Raw byte values"),
 *     ]
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 228, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_28 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__142, NULL); if (unlikely(!__pyx_t_28)) __PYX_ERR(0, 228, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_28);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_28, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 228, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_28); __pyx_t_28 = 0;
  __pyx_t_28 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__143, NULL); if (unlikely(!__pyx_t_28)) __PYX_ERR(0, 228, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_28);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":229
 *     EnumWithDoc('String').setDoc("Text string"),
 *     EnumWithDoc('Button').setDoc("A write-only value that is the equivalent of pressing a button to send a command to a device"),
 *     EnumWithDoc('Raw').setDoc("Raw byte values"),             # <<<<<<<<<<<<<<
 *     ]
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 229, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_27 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__144, NULL); if (unlikely(!__pyx_t_27)) __PYX_ERR(0, 229, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_27);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_27, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 229, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_27); __pyx_t_27 = 0;
  __pyx_t_27 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__145, NULL); if (unlikely(!__pyx_t_27)) __PYX_ERR(0, 229, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_27);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":219
 *     ]
 * 
 * PyValueTypes = [             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Bool').setDoc("Boolean, true or false"),
 *     EnumWithDoc('Byte').setDoc("8-bit unsigned value"),
 */
  __pyx_t_1 = PyList_New(10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 219, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_33);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_t_33);
  __Pyx_GIVEREF(__pyx_t_32);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_t_32);
  __Pyx_GIVEREF(__pyx_t_31);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_t_31);
  __Pyx_GIVEREF(__pyx_t_30);
  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_t_30);
  __Pyx_GIVEREF(__pyx_t_34);
  PyList_SET_ITEM(__pyx_t_1, 4, __pyx_t_34);
  __Pyx_GIVEREF(__pyx_t_35);
  PyList_SET_ITEM(__pyx_t_1, 5, __pyx_t_35);
  __Pyx_GIVEREF(__pyx_t_36);
  PyList_SET_ITEM(__pyx_t_1, 6, __pyx_t_36);
  __Pyx_GIVEREF(__pyx_t_29);
  PyList_SET_ITEM(__pyx_t_1, 7, __pyx_t_29);
  __Pyx_GIVEREF(__pyx_t_28);
  PyList_SET_ITEM(__pyx_t_1, 8, __pyx_t_28);
  __Pyx_GIVEREF(__pyx_t_27);
  PyList_SET_ITEM(__pyx_t_1, 9, __pyx_t_27);
  __pyx_t_33 = 0;
  __pyx_t_32 = 0;
  __pyx_t_31 = 0;
  __pyx_t_30 = 0;
  __pyx_t_34 = 0;
  __pyx_t_35 = 0;
  __pyx_t_36 = 0;
  __pyx_t_29 = 0;
  __pyx_t_28 = 0;
  __pyx_t_27 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PyValueTypes, __pyx_t_1) < 0) __PYX_ERR(0, 219, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":233
 * 
 * PyControllerState = [
 *     EnumWithDoc('Normal').setDoc("No command in progress."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Starting').setDoc("The command is starting."),
 *     EnumWithDoc('Cancel').setDoc("The command was cancelled."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_27 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__146, NULL); if (unlikely(!__pyx_t_27)) __PYX_ERR(0, 233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_27);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_27, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_27); __pyx_t_27 = 0;
  __pyx_t_27 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__147, NULL); if (unlikely(!__pyx_t_27)) __PYX_ERR(0, 233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_27);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":234
 * PyControllerState = [
 *     EnumWithDoc('Normal').setDoc("No command in progress."),
 *     EnumWithDoc('Starting').setDoc("The command is starting."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Cancel').setDoc("The command was cancelled."),
 *     EnumWithDoc('Error').setDoc("Command invocation had error(s) and was aborted."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 234, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_28 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__148, NULL); if (unlikely(!__pyx_t_28)) __PYX_ERR(0, 234, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_28);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_28, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 234, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_28); __pyx_t_28 = 0;
  __pyx_t_28 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__149, NULL); if (unlikely(!__pyx_t_28)) __PYX_ERR(0, 234, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_28);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":235
 *     EnumWithDoc('Normal').setDoc("No command in progress."),
 *     EnumWithDoc('Starting').setDoc("The command is starting."),
 *     EnumWithDoc('Cancel').setDoc("The command was cancelled."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Error').setDoc("Command invocation had error(s) and was aborted."),
 *     EnumWithDoc('Waiting').setDoc("Controller is waiting for a user action."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 235, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_29 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__150, NULL); if (unlikely(!__pyx_t_29)) __PYX_ERR(0, 235, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_29);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_29, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 235, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_29); __pyx_t_29 = 0;
  __pyx_t_29 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__151, NULL); if (unlikely(!__pyx_t_29)) __PYX_ERR(0, 235, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_29);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":236
 *     EnumWithDoc('Starting').setDoc("The command is starting."),
 *     EnumWithDoc('Cancel').setDoc("The command was cancelled."),
 *     EnumWithDoc('Error').setDoc("Command invocation had error(s) and was aborted."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Waiting').setDoc("Controller is waiting for a user action."),
 *     EnumWithDoc('Sleeping').setDoc("Controller command is on a sleep queue wait for device."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 236, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_36 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__152, NULL); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 236, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_36, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 236, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;
  __pyx_t_36 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__153, NULL); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 236, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":237
 *     EnumWithDoc('Cancel').setDoc("The command was cancelled."),
 *     EnumWithDoc('Error').setDoc("Command invocation had error(s) and was aborted."),
 *     EnumWithDoc('Waiting').setDoc("Controller is waiting for a user action."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Sleeping').setDoc("Controller command is on a sleep queue wait for device."),
 *     EnumWithDoc('InProgress').setDoc("The controller is communicating with the other device to carry out the command."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 237, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__154, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 237, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_35, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 237, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_35); __pyx_t_35 = 0;
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__155, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 237, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":238
 *     EnumWithDoc('Error').setDoc("Command invocation had error(s) and was aborted."),
 *     EnumWithDoc('Waiting').setDoc("Controller is waiting for a user action."),
 *     EnumWithDoc('Sleeping').setDoc("Controller command is on a sleep queue wait for device."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('InProgress').setDoc("The controller is communicating with the other device to carry out the command."),
 *     EnumWithDoc('Completed').setDoc("The command has completed successfully."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 238, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__156, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 238, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_34, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 238, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_34); __pyx_t_34 = 0;
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__157, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 238, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":239
 *     EnumWithDoc('Waiting').setDoc("Controller is waiting for a user action."),
 *     EnumWithDoc('Sleeping').setDoc("Controller command is on a sleep queue wait for device."),
 *     EnumWithDoc('InProgress').setDoc("The controller is communicating with the other device to carry out the command."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Completed').setDoc("The command has completed successfully."),
 *     EnumWithDoc('Failed').setDoc("The command has failed."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 239, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__158, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 239, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_30, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 239, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_30); __pyx_t_30 = 0;
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__159, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 239, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":240
 *     EnumWithDoc('Sleeping').setDoc("Controller command is on a sleep queue wait for device."),
 *     EnumWithDoc('InProgress').setDoc("The controller is communicating with the other device to carry out the command."),
 *     EnumWithDoc('Completed').setDoc("The command has completed successfully."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Failed').setDoc("The command has failed."),
 *     EnumWithDoc('NodeOK').setDoc("Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node is OK."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 240, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_31 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__160, NULL); if (unlikely(!__pyx_t_31)) __PYX_ERR(0, 240, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_31);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_31, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 240, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_31); __pyx_t_31 = 0;
  __pyx_t_31 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__161, NULL); if (unlikely(!__pyx_t_31)) __PYX_ERR(0, 240, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_31);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":241
 *     EnumWithDoc('InProgress').setDoc("The controller is communicating with the other device to carry out the command."),
 *     EnumWithDoc('Completed').setDoc("The command has completed successfully."),
 *     EnumWithDoc('Failed').setDoc("The command has failed."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeOK').setDoc("Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node is OK."),
 *     EnumWithDoc('NodeFailed').setDoc("Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node has failed."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_32 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__162, NULL); if (unlikely(!__pyx_t_32)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_32);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_32, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_32); __pyx_t_32 = 0;
  __pyx_t_32 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__163, NULL); if (unlikely(!__pyx_t_32)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_32);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":242
 *     EnumWithDoc('Completed').setDoc("The command has completed successfully."),
 *     EnumWithDoc('Failed').setDoc("The command has failed."),
 *     EnumWithDoc('NodeOK').setDoc("Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node is OK."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeFailed').setDoc("Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node has failed."),
 *     ]
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 242, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_33 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__164, NULL); if (unlikely(!__pyx_t_33)) __PYX_ERR(0, 242, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_33);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_33, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 242, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_33); __pyx_t_33 = 0;
  __pyx_t_33 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__165, NULL); if (unlikely(!__pyx_t_33)) __PYX_ERR(0, 242, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_33);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":243
 *     EnumWithDoc('Failed').setDoc("The command has failed."),
 *     EnumWithDoc('NodeOK').setDoc("Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node is OK."),
 *     EnumWithDoc('NodeFailed').setDoc("Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node has failed."),             # <<<<<<<<<<<<<<
 *     ]
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_26 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__166, NULL); if (unlikely(!__pyx_t_26)) __PYX_ERR(0, 243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_26);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_26, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_26); __pyx_t_26 = 0;
  __pyx_t_26 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__167, NULL); if (unlikely(!__pyx_t_26)) __PYX_ERR(0, 243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_26);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":232
 *     ]
 * 
 * PyControllerState = [             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Normal').setDoc("No command in progress."),
 *     EnumWithDoc('Starting').setDoc("The command is starting."),
 */
  __pyx_t_1 = PyList_New(11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 232, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_27);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_t_27);
  __Pyx_GIVEREF(__pyx_t_28);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_t_28);
  __Pyx_GIVEREF(__pyx_t_29);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_t_29);
  __Pyx_GIVEREF(__pyx_t_36);
  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_t_36);
  __Pyx_GIVEREF(__pyx_t_35);
  PyList_SET_ITEM(__pyx_t_1, 4, __pyx_t_35);
  __Pyx_GIVEREF(__pyx_t_34);
  PyList_SET_ITEM(__pyx_t_1, 5, __pyx_t_34);
  __Pyx_GIVEREF(__pyx_t_30);
  PyList_SET_ITEM(__pyx_t_1, 6, __pyx_t_30);
  __Pyx_GIVEREF(__pyx_t_31);
  PyList_SET_ITEM(__pyx_t_1, 7, __pyx_t_31);
  __Pyx_GIVEREF(__pyx_t_32);
  PyList_SET_ITEM(__pyx_t_1, 8, __pyx_t_32);
  __Pyx_GIVEREF(__pyx_t_33);
  PyList_SET_ITEM(__pyx_t_1, 9, __pyx_t_33);
  __Pyx_GIVEREF(__pyx_t_26);
  PyList_SET_ITEM(__pyx_t_1, 10, __pyx_t_26);
  __pyx_t_27 = 0;
  __pyx_t_28 = 0;
  __pyx_t_29 = 0;
  __pyx_t_36 = 0;
  __pyx_t_35 = 0;
  __pyx_t_34 = 0;
  __pyx_t_30 = 0;
  __pyx_t_31 = 0;
  __pyx_t_32 = 0;
  __pyx_t_33 = 0;
  __pyx_t_26 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PyControllerState, __pyx_t_1) < 0) __PYX_ERR(0, 232, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":247
 * 
 * PyControllerCommand = [
 *     EnumWithDoc('None').setDoc("No command."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('AddDevice').setDoc("Add a new device (but not a controller) to the Z-Wave network."),
 *     EnumWithDoc('CreateNewPrimary').setDoc("Add a new controller to the Z-Wave network.  The new controller will be the primary, and the current primary will become a secondary controller."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_26 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__168, NULL); if (unlikely(!__pyx_t_26)) __PYX_ERR(0, 247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_26);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_26, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_26); __pyx_t_26 = 0;
  __pyx_t_26 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__169, NULL); if (unlikely(!__pyx_t_26)) __PYX_ERR(0, 247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_26);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":248
 * PyControllerCommand = [
 *     EnumWithDoc('None').setDoc("No command."),
 *     EnumWithDoc('AddDevice').setDoc("Add a new device (but not a controller) to the Z-Wave network."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('CreateNewPrimary').setDoc("Add a new controller to the Z-Wave network.  The new controller will be the primary, and the current primary will become a secondary controller."),
 *     EnumWithDoc('ReceiveConfiguration').setDoc("Receive Z-Wave network configuration information from another controller."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 248, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_33 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__170, NULL); if (unlikely(!__pyx_t_33)) __PYX_ERR(0, 248, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_33);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_33, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 248, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_33); __pyx_t_33 = 0;
  __pyx_t_33 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__171, NULL); if (unlikely(!__pyx_t_33)) __PYX_ERR(0, 248, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_33);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":249
 *     EnumWithDoc('None').setDoc("No command."),
 *     EnumWithDoc('AddDevice').setDoc("Add a new device (but not a controller) to the Z-Wave network."),
 *     EnumWithDoc('CreateNewPrimary').setDoc("Add a new controller to the Z-Wave network.  The new controller will be the primary, and the current primary will become a secondary controller."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ReceiveConfiguration').setDoc("Receive Z-Wave network configuration information from another controller."),
 *     EnumWithDoc('RemoveDevice').setDoc("Remove a new device (but not a controller) from the Z-Wave network."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 249, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_32 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__172, NULL); if (unlikely(!__pyx_t_32)) __PYX_ERR(0, 249, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_32);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_32, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 249, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_32); __pyx_t_32 = 0;
  __pyx_t_32 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__173, NULL); if (unlikely(!__pyx_t_32)) __PYX_ERR(0, 249, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_32);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":250
 *     EnumWithDoc('AddDevice').setDoc("Add a new device (but not a controller) to the Z-Wave network."),
 *     EnumWithDoc('CreateNewPrimary').setDoc("Add a new controller to the Z-Wave network.  The new controller will be the primary, and the current primary will become a secondary controller."),
 *     EnumWithDoc('ReceiveConfiguration').setDoc("Receive Z-Wave network configuration information from another controller."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('RemoveDevice').setDoc("Remove a new device (but not a controller) from the Z-Wave network."),
 *     EnumWithDoc('RemoveFailedNode').setDoc("Move a node to the controller's failed nodes list. This command will only work if the node cannot respond."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 250, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_31 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__174, NULL); if (unlikely(!__pyx_t_31)) __PYX_ERR(0, 250, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_31);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_31, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 250, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_31); __pyx_t_31 = 0;
  __pyx_t_31 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__175, NULL); if (unlikely(!__pyx_t_31)) __PYX_ERR(0, 250, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_31);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":251
 *     EnumWithDoc('CreateNewPrimary').setDoc("Add a new controller to the Z-Wave network.  The new controller will be the primary, and the current primary will become a secondary controller."),
 *     EnumWithDoc('ReceiveConfiguration').setDoc("Receive Z-Wave network configuration information from another controller."),
 *     EnumWithDoc('RemoveDevice').setDoc("Remove a new device (but not a controller) from the Z-Wave network."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('RemoveFailedNode').setDoc("Move a node to the controller's failed nodes list. This command will only work if the node cannot respond."),
 *     EnumWithDoc('HasNodeFailed').setDoc("Check whether a node is in the controller's failed nodes list."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 251, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__176, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 251, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_30, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 251, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_30); __pyx_t_30 = 0;
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__177, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 251, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":252
 *     EnumWithDoc('ReceiveConfiguration').setDoc("Receive Z-Wave network configuration information from another controller."),
 *     EnumWithDoc('RemoveDevice').setDoc("Remove a new device (but not a controller) from the Z-Wave network."),
 *     EnumWithDoc('RemoveFailedNode').setDoc("Move a node to the controller's failed nodes list. This command will only work if the node cannot respond."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('HasNodeFailed').setDoc("Check whether a node is in the controller's failed nodes list."),
 *     EnumWithDoc('ReplaceFailedNode').setDoc("Replace a non-responding node with another. The node must be in the controller's list of failed nodes for this command to succeed."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 252, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__178, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 252, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_34, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 252, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_34); __pyx_t_34 = 0;
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__179, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 252, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":253
 *     EnumWithDoc('RemoveDevice').setDoc("Remove a new device (but not a controller) from the Z-Wave network."),
 *     EnumWithDoc('RemoveFailedNode').setDoc("Move a node to the controller's failed nodes list. This command will only work if the node cannot respond."),
 *     EnumWithDoc('HasNodeFailed').setDoc("Check whether a node is in the controller's failed nodes list."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ReplaceFailedNode').setDoc("Replace a non-responding node with another. The node must be in the controller's list of failed nodes for this command to succeed."),
 *     EnumWithDoc('TransferPrimaryRole').setDoc("Make a different controller the primary."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 253, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__180, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 253, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_35, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 253, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_35); __pyx_t_35 = 0;
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__181, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 253, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":254
 *     EnumWithDoc('RemoveFailedNode').setDoc("Move a node to the controller's failed nodes list. This command will only work if the node cannot respond."),
 *     EnumWithDoc('HasNodeFailed').setDoc("Check whether a node is in the controller's failed nodes list."),
 *     EnumWithDoc('ReplaceFailedNode').setDoc("Replace a non-responding node with another. The node must be in the controller's list of failed nodes for this command to succeed."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('TransferPrimaryRole').setDoc("Make a different controller the primary."),
 *     EnumWithDoc('RequestNetworkUpdate').setDoc("Request network information from the SUC/SIS."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 254, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_36 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__182, NULL); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 254, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_36, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 254, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;
  __pyx_t_36 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__183, NULL); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 254, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":255
 *     EnumWithDoc('HasNodeFailed').setDoc("Check whether a node is in the controller's failed nodes list."),
 *     EnumWithDoc('ReplaceFailedNode').setDoc("Replace a non-responding node with another. The node must be in the controller's list of failed nodes for this command to succeed."),
 *     EnumWithDoc('TransferPrimaryRole').setDoc("Make a different controller the primary."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('RequestNetworkUpdate').setDoc("Request network information from the SUC/SIS."),
 *     EnumWithDoc('RequestNodeNeighborUpdate').setDoc("Get a node to rebuild its neighbour list.  This method also does ControllerCommand_RequestNodeNeighbors."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 255, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_29 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__184, NULL); if (unlikely(!__pyx_t_29)) __PYX_ERR(0, 255, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_29);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_29, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 255, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_29); __pyx_t_29 = 0;
  __pyx_t_29 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__185, NULL); if (unlikely(!__pyx_t_29)) __PYX_ERR(0, 255, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_29);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":256
 *     EnumWithDoc('ReplaceFailedNode').setDoc("Replace a non-responding node with another. The node must be in the controller's list of failed nodes for this command to succeed."),
 *     EnumWithDoc('TransferPrimaryRole').setDoc("Make a different controller the primary."),
 *     EnumWithDoc('RequestNetworkUpdate').setDoc("Request network information from the SUC/SIS."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('RequestNodeNeighborUpdate').setDoc("Get a node to rebuild its neighbour list.  This method also does ControllerCommand_RequestNodeNeighbors."),
 *     EnumWithDoc('AssignReturnRoute').setDoc("Assign a network return routes to a device."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 256, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_28 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__186, NULL); if (unlikely(!__pyx_t_28)) __PYX_ERR(0, 256, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_28);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_28, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 256, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_28); __pyx_t_28 = 0;
  __pyx_t_28 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__187, NULL); if (unlikely(!__pyx_t_28)) __PYX_ERR(0, 256, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_28);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":257
 *     EnumWithDoc('TransferPrimaryRole').setDoc("Make a different controller the primary."),
 *     EnumWithDoc('RequestNetworkUpdate').setDoc("Request network information from the SUC/SIS."),
 *     EnumWithDoc('RequestNodeNeighborUpdate').setDoc("Get a node to rebuild its neighbour list.  This method also does ControllerCommand_RequestNodeNeighbors."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('AssignReturnRoute').setDoc("Assign a network return routes to a device."),
 *     EnumWithDoc('DeleteAllReturnRoutes').setDoc("Delete all return routes from a device."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 257, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_27 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__188, NULL); if (unlikely(!__pyx_t_27)) __PYX_ERR(0, 257, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_27);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_27, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 257, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_27); __pyx_t_27 = 0;
  __pyx_t_27 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__189, NULL); if (unlikely(!__pyx_t_27)) __PYX_ERR(0, 257, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_27);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":258
 *     EnumWithDoc('RequestNetworkUpdate').setDoc("Request network information from the SUC/SIS."),
 *     EnumWithDoc('RequestNodeNeighborUpdate').setDoc("Get a node to rebuild its neighbour list.  This method also does ControllerCommand_RequestNodeNeighbors."),
 *     EnumWithDoc('AssignReturnRoute').setDoc("Assign a network return routes to a device."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('DeleteAllReturnRoutes').setDoc("Delete all return routes from a device."),
 *     EnumWithDoc('SendNodeInformation').setDoc("Send a node information frame."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 258, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_25 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__190, NULL); if (unlikely(!__pyx_t_25)) __PYX_ERR(0, 258, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_25);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_25, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 258, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_25); __pyx_t_25 = 0;
  __pyx_t_25 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__191, NULL); if (unlikely(!__pyx_t_25)) __PYX_ERR(0, 258, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_25);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":259
 *     EnumWithDoc('RequestNodeNeighborUpdate').setDoc("Get a node to rebuild its neighbour list.  This method also does ControllerCommand_RequestNodeNeighbors."),
 *     EnumWithDoc('AssignReturnRoute').setDoc("Assign a network return routes to a device."),
 *     EnumWithDoc('DeleteAllReturnRoutes').setDoc("Delete all return routes from a device."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('SendNodeInformation').setDoc("Send a node information frame."),
 *     EnumWithDoc('ReplicationSend').setDoc("Send information from primary to secondary."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_24 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__192, NULL); if (unlikely(!__pyx_t_24)) __PYX_ERR(0, 259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_24);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_24, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_24); __pyx_t_24 = 0;
  __pyx_t_24 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__193, NULL); if (unlikely(!__pyx_t_24)) __PYX_ERR(0, 259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_24);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":260
 *     EnumWithDoc('AssignReturnRoute').setDoc("Assign a network return routes to a device."),
 *     EnumWithDoc('DeleteAllReturnRoutes').setDoc("Delete all return routes from a device."),
 *     EnumWithDoc('SendNodeInformation').setDoc("Send a node information frame."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ReplicationSend').setDoc("Send information from primary to secondary."),
 *     EnumWithDoc('CreateButton').setDoc("Create an id that tracks handheld button presses."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 260, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_23 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__194, NULL); if (unlikely(!__pyx_t_23)) __PYX_ERR(0, 260, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_23);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_23, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 260, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_23); __pyx_t_23 = 0;
  __pyx_t_23 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__195, NULL); if (unlikely(!__pyx_t_23)) __PYX_ERR(0, 260, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_23);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":261
 *     EnumWithDoc('DeleteAllReturnRoutes').setDoc("Delete all return routes from a device."),
 *     EnumWithDoc('SendNodeInformation').setDoc("Send a node information frame."),
 *     EnumWithDoc('ReplicationSend').setDoc("Send information from primary to secondary."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('CreateButton').setDoc("Create an id that tracks handheld button presses."),
 *     EnumWithDoc('DeleteButton').setDoc("Delete id that tracks handheld button presses."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 261, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_22 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__196, NULL); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 261, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_22);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_22, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 261, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
  __pyx_t_22 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__197, NULL); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 261, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_22);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":262
 *     EnumWithDoc('SendNodeInformation').setDoc("Send a node information frame."),
 *     EnumWithDoc('ReplicationSend').setDoc("Send information from primary to secondary."),
 *     EnumWithDoc('CreateButton').setDoc("Create an id that tracks handheld button presses."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('DeleteButton').setDoc("Delete id that tracks handheld button presses."),
 *     ]
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 262, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_21 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__198, NULL); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 262, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_21);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_21, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 262, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
  __pyx_t_21 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__199, NULL); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 262, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_21);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":263
 *     EnumWithDoc('ReplicationSend').setDoc("Send information from primary to secondary."),
 *     EnumWithDoc('CreateButton').setDoc("Create an id that tracks handheld button presses."),
 *     EnumWithDoc('DeleteButton').setDoc("Delete id that tracks handheld button presses."),             # <<<<<<<<<<<<<<
 *     ]
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 263, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_20 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__200, NULL); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 263, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_20);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_20, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 263, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
  __pyx_t_20 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__201, NULL); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 263, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_20);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":246
 *     ]
 * 
 * PyControllerCommand = [             # <<<<<<<<<<<<<<
 *     EnumWithDoc('None').setDoc("No command."),
 *     EnumWithDoc('AddDevice').setDoc("Add a new device (but not a controller) to the Z-Wave network."),
 */
  __pyx_t_1 = PyList_New(17); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 246, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_26);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_t_26);
  __Pyx_GIVEREF(__pyx_t_33);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_t_33);
  __Pyx_GIVEREF(__pyx_t_32);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_t_32);
  __Pyx_GIVEREF(__pyx_t_31);
  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_t_31);
  __Pyx_GIVEREF(__pyx_t_30);
  PyList_SET_ITEM(__pyx_t_1, 4, __pyx_t_30);
  __Pyx_GIVEREF(__pyx_t_34);
  PyList_SET_ITEM(__pyx_t_1, 5, __pyx_t_34);
  __Pyx_GIVEREF(__pyx_t_35);
  PyList_SET_ITEM(__pyx_t_1, 6, __pyx_t_35);
  __Pyx_GIVEREF(__pyx_t_36);
  PyList_SET_ITEM(__pyx_t_1, 7, __pyx_t_36);
  __Pyx_GIVEREF(__pyx_t_29);
  PyList_SET_ITEM(__pyx_t_1, 8, __pyx_t_29);
  __Pyx_GIVEREF(__pyx_t_28);
  PyList_SET_ITEM(__pyx_t_1, 9, __pyx_t_28);
  __Pyx_GIVEREF(__pyx_t_27);
  PyList_SET_ITEM(__pyx_t_1, 10, __pyx_t_27);
  __Pyx_GIVEREF(__pyx_t_25);
  PyList_SET_ITEM(__pyx_t_1, 11, __pyx_t_25);
  __Pyx_GIVEREF(__pyx_t_24);
  PyList_SET_ITEM(__pyx_t_1, 12, __pyx_t_24);
  __Pyx_GIVEREF(__pyx_t_23);
  PyList_SET_ITEM(__pyx_t_1, 13, __pyx_t_23);
  __Pyx_GIVEREF(__pyx_t_22);
  PyList_SET_ITEM(__pyx_t_1, 14, __pyx_t_22);
  __Pyx_GIVEREF(__pyx_t_21);
  PyList_SET_ITEM(__pyx_t_1, 15, __pyx_t_21);
  __Pyx_GIVEREF(__pyx_t_20);
  PyList_SET_ITEM(__pyx_t_1, 16, __pyx_t_20);
  __pyx_t_26 = 0;
  __pyx_t_33 = 0;
  __pyx_t_32 = 0;
  __pyx_t_31 = 0;
  __pyx_t_30 = 0;
  __pyx_t_34 = 0;
  __pyx_t_35 = 0;
  __pyx_t_36 = 0;
  __pyx_t_29 = 0;
  __pyx_t_28 = 0;
  __pyx_t_27 = 0;
  __pyx_t_25 = 0;
  __pyx_t_24 = 0;
  __pyx_t_23 = 0;
  __pyx_t_22 = 0;
  __pyx_t_21 = 0;
  __pyx_t_20 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PyControllerCommand, __pyx_t_1) < 0) __PYX_ERR(0, 246, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":267
 * 
 * PyControllerError = [
 *     EnumWithDoc('None').setDoc("None."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('ButtonNotFound').setDoc("Button."),
 *     EnumWithDoc('NodeNotFound').setDoc("Button."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_20 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__202, NULL); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_20);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_20, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
  __pyx_t_20 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__203, NULL); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_20);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":268
 * PyControllerError = [
 *     EnumWithDoc('None').setDoc("None."),
 *     EnumWithDoc('ButtonNotFound').setDoc("Button."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NodeNotFound').setDoc("Button."),
 *     EnumWithDoc('NotBridge').setDoc("Button."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 268, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_21 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__204, NULL); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 268, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_21);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_21, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 268, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
  __pyx_t_21 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__205, NULL); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 268, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_21);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":269
 *     EnumWithDoc('None').setDoc("None."),
 *     EnumWithDoc('ButtonNotFound').setDoc("Button."),
 *     EnumWithDoc('NodeNotFound').setDoc("Button."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NotBridge').setDoc("Button."),
 *     EnumWithDoc('NotSUC').setDoc("CreateNewPrimary."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 269, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_22 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__206, NULL); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 269, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_22);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_22, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 269, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
  __pyx_t_22 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__207, NULL); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 269, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_22);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":270
 *     EnumWithDoc('ButtonNotFound').setDoc("Button."),
 *     EnumWithDoc('NodeNotFound').setDoc("Button."),
 *     EnumWithDoc('NotBridge').setDoc("Button."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NotSUC').setDoc("CreateNewPrimary."),
 *     EnumWithDoc('NotSecondary').setDoc("CreateNewPrimary."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 270, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_23 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__208, NULL); if (unlikely(!__pyx_t_23)) __PYX_ERR(0, 270, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_23);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_23, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 270, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_23); __pyx_t_23 = 0;
  __pyx_t_23 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__209, NULL); if (unlikely(!__pyx_t_23)) __PYX_ERR(0, 270, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_23);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":271
 *     EnumWithDoc('NodeNotFound').setDoc("Button."),
 *     EnumWithDoc('NotBridge').setDoc("Button."),
 *     EnumWithDoc('NotSUC').setDoc("CreateNewPrimary."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NotSecondary').setDoc("CreateNewPrimary."),
 *     EnumWithDoc('NotPrimary').setDoc("RemoveFailedNode, AddNodeToNetwork."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 271, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_24 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__210, NULL); if (unlikely(!__pyx_t_24)) __PYX_ERR(0, 271, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_24);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_24, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 271, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_24); __pyx_t_24 = 0;
  __pyx_t_24 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__211, NULL); if (unlikely(!__pyx_t_24)) __PYX_ERR(0, 271, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_24);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":272
 *     EnumWithDoc('NotBridge').setDoc("Button."),
 *     EnumWithDoc('NotSUC').setDoc("CreateNewPrimary."),
 *     EnumWithDoc('NotSecondary').setDoc("CreateNewPrimary."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NotPrimary').setDoc("RemoveFailedNode, AddNodeToNetwork."),
 *     EnumWithDoc('IsPrimary').setDoc("ReceiveConfiguration."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 272, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_25 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__212, NULL); if (unlikely(!__pyx_t_25)) __PYX_ERR(0, 272, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_25);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_25, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 272, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_25); __pyx_t_25 = 0;
  __pyx_t_25 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__213, NULL); if (unlikely(!__pyx_t_25)) __PYX_ERR(0, 272, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_25);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":273
 *     EnumWithDoc('NotSUC').setDoc("CreateNewPrimary."),
 *     EnumWithDoc('NotSecondary').setDoc("CreateNewPrimary."),
 *     EnumWithDoc('NotPrimary').setDoc("RemoveFailedNode, AddNodeToNetwork."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('IsPrimary').setDoc("ReceiveConfiguration."),
 *     EnumWithDoc('NotFound').setDoc("RemoveFailedNode."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 273, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_27 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__214, NULL); if (unlikely(!__pyx_t_27)) __PYX_ERR(0, 273, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_27);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_27, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 273, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_27); __pyx_t_27 = 0;
  __pyx_t_27 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__215, NULL); if (unlikely(!__pyx_t_27)) __PYX_ERR(0, 273, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_27);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":274
 *     EnumWithDoc('NotSecondary').setDoc("CreateNewPrimary."),
 *     EnumWithDoc('NotPrimary').setDoc("RemoveFailedNode, AddNodeToNetwork."),
 *     EnumWithDoc('IsPrimary').setDoc("ReceiveConfiguration."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('NotFound').setDoc("RemoveFailedNode."),
 *     EnumWithDoc('Busy').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 274, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_28 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__216, NULL); if (unlikely(!__pyx_t_28)) __PYX_ERR(0, 274, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_28);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_28, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 274, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_28); __pyx_t_28 = 0;
  __pyx_t_28 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__217, NULL); if (unlikely(!__pyx_t_28)) __PYX_ERR(0, 274, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_28);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":275
 *     EnumWithDoc('NotPrimary').setDoc("RemoveFailedNode, AddNodeToNetwork."),
 *     EnumWithDoc('IsPrimary').setDoc("ReceiveConfiguration."),
 *     EnumWithDoc('NotFound').setDoc("RemoveFailedNode."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Busy').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 *     EnumWithDoc('Failed').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 275, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_29 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__218, NULL); if (unlikely(!__pyx_t_29)) __PYX_ERR(0, 275, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_29);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_29, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 275, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_29); __pyx_t_29 = 0;
  __pyx_t_29 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__219, NULL); if (unlikely(!__pyx_t_29)) __PYX_ERR(0, 275, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_29);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":276
 *     EnumWithDoc('IsPrimary').setDoc("ReceiveConfiguration."),
 *     EnumWithDoc('NotFound').setDoc("RemoveFailedNode."),
 *     EnumWithDoc('Busy').setDoc("RemoveFailedNode, RequestNetworkUpdate."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Failed').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 *     EnumWithDoc('Disabled').setDoc("RequestNetworkUpdate error."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 276, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_36 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__220, NULL); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 276, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_36, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 276, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;
  __pyx_t_36 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__221, NULL); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 276, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":277
 *     EnumWithDoc('NotFound').setDoc("RemoveFailedNode."),
 *     EnumWithDoc('Busy').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 *     EnumWithDoc('Failed').setDoc("RemoveFailedNode, RequestNetworkUpdate."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Disabled').setDoc("RequestNetworkUpdate error."),
 *     EnumWithDoc('Overflow').setDoc("RequestNetworkUpdate error."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 277, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__222, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 277, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_35, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 277, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_35); __pyx_t_35 = 0;
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__223, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 277, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":278
 *     EnumWithDoc('Busy').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 *     EnumWithDoc('Failed').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 *     EnumWithDoc('Disabled').setDoc("RequestNetworkUpdate error."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Overflow').setDoc("RequestNetworkUpdate error."),
 *     ]
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 278, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__224, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 278, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_34, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 278, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_34); __pyx_t_34 = 0;
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__225, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 278, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":279
 *     EnumWithDoc('Failed').setDoc("RemoveFailedNode, RequestNetworkUpdate."),
 *     EnumWithDoc('Disabled').setDoc("RequestNetworkUpdate error."),
 *     EnumWithDoc('Overflow').setDoc("RequestNetworkUpdate error."),             # <<<<<<<<<<<<<<
 *     ]
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__226, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_30, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_30); __pyx_t_30 = 0;
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__227, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":266
 *     ]
 * 
 * PyControllerError = [             # <<<<<<<<<<<<<<
 *     EnumWithDoc('None').setDoc("None."),
 *     EnumWithDoc('ButtonNotFound').setDoc("Button."),
 */
  __pyx_t_1 = PyList_New(13); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 266, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_20);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_t_20);
  __Pyx_GIVEREF(__pyx_t_21);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_t_21);
  __Pyx_GIVEREF(__pyx_t_22);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_t_22);
  __Pyx_GIVEREF(__pyx_t_23);
  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_t_23);
  __Pyx_GIVEREF(__pyx_t_24);
  PyList_SET_ITEM(__pyx_t_1, 4, __pyx_t_24);
  __Pyx_GIVEREF(__pyx_t_25);
  PyList_SET_ITEM(__pyx_t_1, 5, __pyx_t_25);
  __Pyx_GIVEREF(__pyx_t_27);
  PyList_SET_ITEM(__pyx_t_1, 6, __pyx_t_27);
  __Pyx_GIVEREF(__pyx_t_28);
  PyList_SET_ITEM(__pyx_t_1, 7, __pyx_t_28);
  __Pyx_GIVEREF(__pyx_t_29);
  PyList_SET_ITEM(__pyx_t_1, 8, __pyx_t_29);
  __Pyx_GIVEREF(__pyx_t_36);
  PyList_SET_ITEM(__pyx_t_1, 9, __pyx_t_36);
  __Pyx_GIVEREF(__pyx_t_35);
  PyList_SET_ITEM(__pyx_t_1, 10, __pyx_t_35);
  __Pyx_GIVEREF(__pyx_t_34);
  PyList_SET_ITEM(__pyx_t_1, 11, __pyx_t_34);
  __Pyx_GIVEREF(__pyx_t_30);
  PyList_SET_ITEM(__pyx_t_1, 12, __pyx_t_30);
  __pyx_t_20 = 0;
  __pyx_t_21 = 0;
  __pyx_t_22 = 0;
  __pyx_t_23 = 0;
  __pyx_t_24 = 0;
  __pyx_t_25 = 0;
  __pyx_t_27 = 0;
  __pyx_t_28 = 0;
  __pyx_t_29 = 0;
  __pyx_t_36 = 0;
  __pyx_t_35 = 0;
  __pyx_t_34 = 0;
  __pyx_t_30 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PyControllerError, __pyx_t_1) < 0) __PYX_ERR(0, 266, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":283
 * 
 * PyControllerInterface = [
 *     EnumWithDoc('Unknown').setDoc("Controller interface use unknown protocol."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Serial').setDoc("Controller interface use serial protocol."),
 *     EnumWithDoc('Hid').setDoc("Controller interface use human interface device protocol."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 283, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__228, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 283, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_30, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 283, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_30); __pyx_t_30 = 0;
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__229, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 283, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":284
 * PyControllerInterface = [
 *     EnumWithDoc('Unknown').setDoc("Controller interface use unknown protocol."),
 *     EnumWithDoc('Serial').setDoc("Controller interface use serial protocol."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Hid').setDoc("Controller interface use human interface device protocol."),
 * ]
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 284, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__230, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 284, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_34, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 284, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_34); __pyx_t_34 = 0;
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__231, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 284, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":285
 *     EnumWithDoc('Unknown').setDoc("Controller interface use unknown protocol."),
 *     EnumWithDoc('Serial').setDoc("Controller interface use serial protocol."),
 *     EnumWithDoc('Hid').setDoc("Controller interface use human interface device protocol."),             # <<<<<<<<<<<<<<
 * ]
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 285, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__232, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 285, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_35, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 285, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_35); __pyx_t_35 = 0;
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__233, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 285, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":282
 *     ]
 * 
 * PyControllerInterface = [             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Unknown').setDoc("Controller interface use unknown protocol."),
 *     EnumWithDoc('Serial').setDoc("Controller interface use serial protocol."),
 */
  __pyx_t_1 = PyList_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_30);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_t_30);
  __Pyx_GIVEREF(__pyx_t_34);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_t_34);
  __Pyx_GIVEREF(__pyx_t_35);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_t_35);
  __pyx_t_30 = 0;
  __pyx_t_34 = 0;
  __pyx_t_35 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PyControllerInterface, __pyx_t_1) < 0) __PYX_ERR(0, 282, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":289
 * 
 * PyOptionType = [
 *     EnumWithDoc('Invalid').setDoc("Invalid type."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Bool').setDoc("Boolean."),
 *     EnumWithDoc('Int').setDoc("Integer."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 289, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__234, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 289, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_35, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 289, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_35); __pyx_t_35 = 0;
  __pyx_t_35 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__235, NULL); if (unlikely(!__pyx_t_35)) __PYX_ERR(0, 289, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_35);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":290
 * PyOptionType = [
 *     EnumWithDoc('Invalid').setDoc("Invalid type."),
 *     EnumWithDoc('Bool').setDoc("Boolean."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Int').setDoc("Integer."),
 *     EnumWithDoc('String').setDoc("String."),
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 290, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__236, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 290, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_34, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 290, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_34); __pyx_t_34 = 0;
  __pyx_t_34 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__237, NULL); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 290, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":291
 *     EnumWithDoc('Invalid').setDoc("Invalid type."),
 *     EnumWithDoc('Bool').setDoc("Boolean."),
 *     EnumWithDoc('Int').setDoc("Integer."),             # <<<<<<<<<<<<<<
 *     EnumWithDoc('String').setDoc("String."),
 * ]
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 291, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__238, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 291, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_30, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 291, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_30); __pyx_t_30 = 0;
  __pyx_t_30 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__239, NULL); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 291, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":292
 *     EnumWithDoc('Bool').setDoc("Boolean."),
 *     EnumWithDoc('Int').setDoc("Integer."),
 *     EnumWithDoc('String').setDoc("String."),             # <<<<<<<<<<<<<<
 * ]
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_EnumWithDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 292, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_36 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__240, NULL); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 292, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_36, __pyx_n_s_setDoc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 292, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;
  __pyx_t_36 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__241, NULL); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 292, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":288
 * ]
 * 
 * PyOptionType = [             # <<<<<<<<<<<<<<
 *     EnumWithDoc('Invalid').setDoc("Invalid type."),
 *     EnumWithDoc('Bool').setDoc("Boolean."),
 */
  __pyx_t_1 = PyList_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 288, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_35);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_t_35);
  __Pyx_GIVEREF(__pyx_t_34);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_t_34);
  __Pyx_GIVEREF(__pyx_t_30);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_t_30);
  __Pyx_GIVEREF(__pyx_t_36);
  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_t_36);
  __pyx_t_35 = 0;
  __pyx_t_34 = 0;
  __pyx_t_30 = 0;
  __pyx_t_36 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PyOptionType, __pyx_t_1) < 0) __PYX_ERR(0, 288, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":295
 * ]
 * 
 * class EnumWithDocType(str):             # <<<<<<<<<<<<<<
 *     """Enum helper"""
 *     def setDocType(self, doc, stype):
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 295, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(((PyObject *)(&PyString_Type)));
  __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyString_Type)));
  __pyx_t_36 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 295, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  __pyx_t_30 = __Pyx_Py3MetaclassPrepare(__pyx_t_36, __pyx_t_1, __pyx_n_s_EnumWithDocType, __pyx_n_s_EnumWithDocType, (PyObject *) NULL, __pyx_n_s_libopenzwave, __pyx_kp_s_Enum_helper); if (unlikely(!__pyx_t_30)) __PYX_ERR(0, 295, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_30);

  /* "libopenzwave.pyx":297
 * class EnumWithDocType(str):
 *     """Enum helper"""
 *     def setDocType(self, doc, stype):             # <<<<<<<<<<<<<<
 *         self.doc = doc
 *         self.type = stype
 */
  __pyx_t_34 = __Pyx_CyFunction_NewEx(&__pyx_mdef_12libopenzwave_15EnumWithDocType_1setDocType, 0, __pyx_n_s_EnumWithDocType_setDocType, NULL, __pyx_n_s_libopenzwave, __pyx_d, ((PyObject *)__pyx_codeobj__243)); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 297, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  if (PyObject_SetItem(__pyx_t_30, __pyx_n_s_setDocType, __pyx_t_34) < 0) __PYX_ERR(0, 297, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_34); __pyx_t_34 = 0;

  /* "libopenzwave.pyx":295
 * ]
 * 
 * class EnumWithDocType(str):             # <<<<<<<<<<<<<<
 *     """Enum helper"""
 *     def setDocType(self, doc, stype):
 */
  __pyx_t_34 = __Pyx_Py3ClassCreate(__pyx_t_36, __pyx_n_s_EnumWithDocType, __pyx_t_1, __pyx_t_30, NULL, 0, 1); if (unlikely(!__pyx_t_34)) __PYX_ERR(0, 295, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_34);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_EnumWithDocType, __pyx_t_34) < 0) __PYX_ERR(0, 295, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_34); __pyx_t_34 = 0;
  __Pyx_DECREF(__pyx_t_30); __pyx_t_30 = 0;
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":303
 * 
 * PyOptionList = {
 *     'ConfigPath' : {'doc' : "Path to the OpenZWave config folder.", 'type' : "String"},             # <<<<<<<<<<<<<<
 *     'UserPath' : {'doc' : "Path to the user's data folder.", 'type' : "String"},
 *     'Logging' : {'doc' : "Enable logging of library activity.", 'type' : "Bool"},
 */
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Path_to_the_OpenZWave_config_fol) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_String) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_ConfigPath, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":304
 * PyOptionList = {
 *     'ConfigPath' : {'doc' : "Path to the OpenZWave config folder.", 'type' : "String"},
 *     'UserPath' : {'doc' : "Path to the user's data folder.", 'type' : "String"},             # <<<<<<<<<<<<<<
 *     'Logging' : {'doc' : "Enable logging of library activity.", 'type' : "Bool"},
 *     'LogFileName' : {'doc' : "Name of the log file (can be changed via Log::SetLogFileName).", 'type' : "String"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 304, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Path_to_the_user_s_data_folder) < 0) __PYX_ERR(0, 304, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_String) < 0) __PYX_ERR(0, 304, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_UserPath, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":305
 *     'ConfigPath' : {'doc' : "Path to the OpenZWave config folder.", 'type' : "String"},
 *     'UserPath' : {'doc' : "Path to the user's data folder.", 'type' : "String"},
 *     'Logging' : {'doc' : "Enable logging of library activity.", 'type' : "Bool"},             # <<<<<<<<<<<<<<
 *     'LogFileName' : {'doc' : "Name of the log file (can be changed via Log::SetLogFileName).", 'type' : "String"},
 *     'AppendLogFile' : {'doc' : "Append new session logs to existing log file (false = overwrite).", 'type' : "Bool"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 305, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Enable_logging_of_library_activi) < 0) __PYX_ERR(0, 305, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Bool) < 0) __PYX_ERR(0, 305, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Logging, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":306
 *     'UserPath' : {'doc' : "Path to the user's data folder.", 'type' : "String"},
 *     'Logging' : {'doc' : "Enable logging of library activity.", 'type' : "Bool"},
 *     'LogFileName' : {'doc' : "Name of the log file (can be changed via Log::SetLogFileName).", 'type' : "String"},             # <<<<<<<<<<<<<<
 *     'AppendLogFile' : {'doc' : "Append new session logs to existing log file (false = overwrite).", 'type' : "Bool"},
 *     'ConsoleOutput' : {'doc' : "Display log information on console (as well as save to disk).", 'type' : "Bool"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 306, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Name_of_the_log_file_can_be_chan) < 0) __PYX_ERR(0, 306, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_String) < 0) __PYX_ERR(0, 306, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_LogFileName, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":307
 *     'Logging' : {'doc' : "Enable logging of library activity.", 'type' : "Bool"},
 *     'LogFileName' : {'doc' : "Name of the log file (can be changed via Log::SetLogFileName).", 'type' : "String"},
 *     'AppendLogFile' : {'doc' : "Append new session logs to existing log file (false = overwrite).", 'type' : "Bool"},             # <<<<<<<<<<<<<<
 *     'ConsoleOutput' : {'doc' : "Display log information on console (as well as save to disk).", 'type' : "Bool"},
 *     'SaveLogLevel' : {'doc' : "Save (to file) log messages equal to or above LogLevel_Detail.", 'type' : "Int"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 307, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Append_new_session_logs_to_exist) < 0) __PYX_ERR(0, 307, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Bool) < 0) __PYX_ERR(0, 307, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_AppendLogFile, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":308
 *     'LogFileName' : {'doc' : "Name of the log file (can be changed via Log::SetLogFileName).", 'type' : "String"},
 *     'AppendLogFile' : {'doc' : "Append new session logs to existing log file (false = overwrite).", 'type' : "Bool"},
 *     'ConsoleOutput' : {'doc' : "Display log information on console (as well as save to disk).", 'type' : "Bool"},             # <<<<<<<<<<<<<<
 *     'SaveLogLevel' : {'doc' : "Save (to file) log messages equal to or above LogLevel_Detail.", 'type' : "Int"},
 *     'QueueLogLevel' : {'doc' : "Save (in RAM) log messages equal to or above LogLevel_Debug.", 'type' : "Int"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 308, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Display_log_information_on_conso) < 0) __PYX_ERR(0, 308, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Bool) < 0) __PYX_ERR(0, 308, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_ConsoleOutput, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":309
 *     'AppendLogFile' : {'doc' : "Append new session logs to existing log file (false = overwrite).", 'type' : "Bool"},
 *     'ConsoleOutput' : {'doc' : "Display log information on console (as well as save to disk).", 'type' : "Bool"},
 *     'SaveLogLevel' : {'doc' : "Save (to file) log messages equal to or above LogLevel_Detail.", 'type' : "Int"},             # <<<<<<<<<<<<<<
 *     'QueueLogLevel' : {'doc' : "Save (in RAM) log messages equal to or above LogLevel_Debug.", 'type' : "Int"},
 *     'DumpTriggerLevel' : {'doc' : "Default is to never dump RAM-stored log messages.", 'type' : "Int"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 309, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Save_to_file_log_messages_equal) < 0) __PYX_ERR(0, 309, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Int) < 0) __PYX_ERR(0, 309, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_SaveLogLevel, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":310
 *     'ConsoleOutput' : {'doc' : "Display log information on console (as well as save to disk).", 'type' : "Bool"},
 *     'SaveLogLevel' : {'doc' : "Save (to file) log messages equal to or above LogLevel_Detail.", 'type' : "Int"},
 *     'QueueLogLevel' : {'doc' : "Save (in RAM) log messages equal to or above LogLevel_Debug.", 'type' : "Int"},             # <<<<<<<<<<<<<<
 *     'DumpTriggerLevel' : {'doc' : "Default is to never dump RAM-stored log messages.", 'type' : "Int"},
 *     'Associate' : {'doc' : "Enable automatic association of the controller with group one of every device.", 'type' : "Bool"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 310, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Save_in_RAM_log_messages_equal_t) < 0) __PYX_ERR(0, 310, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Int) < 0) __PYX_ERR(0, 310, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_QueueLogLevel, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":311
 *     'SaveLogLevel' : {'doc' : "Save (to file) log messages equal to or above LogLevel_Detail.", 'type' : "Int"},
 *     'QueueLogLevel' : {'doc' : "Save (in RAM) log messages equal to or above LogLevel_Debug.", 'type' : "Int"},
 *     'DumpTriggerLevel' : {'doc' : "Default is to never dump RAM-stored log messages.", 'type' : "Int"},             # <<<<<<<<<<<<<<
 *     'Associate' : {'doc' : "Enable automatic association of the controller with group one of every device.", 'type' : "Bool"},
 *     'Exclude' : {'doc' : "Remove support for the listed command classes.", 'type' : "String"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 311, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Default_is_to_never_dump_RAM_sto) < 0) __PYX_ERR(0, 311, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Int) < 0) __PYX_ERR(0, 311, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_DumpTriggerLevel, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":312
 *     'QueueLogLevel' : {'doc' : "Save (in RAM) log messages equal to or above LogLevel_Debug.", 'type' : "Int"},
 *     'DumpTriggerLevel' : {'doc' : "Default is to never dump RAM-stored log messages.", 'type' : "Int"},
 *     'Associate' : {'doc' : "Enable automatic association of the controller with group one of every device.", 'type' : "Bool"},             # <<<<<<<<<<<<<<
 *     'Exclude' : {'doc' : "Remove support for the listed command classes.", 'type' : "String"},
 *     'Include' : {'doc' : "Only handle the specified command classes. The Exclude option is ignored if anything is listed here.", 'type' : "String"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 312, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Enable_automatic_association_of) < 0) __PYX_ERR(0, 312, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Bool) < 0) __PYX_ERR(0, 312, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Associate, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":313
 *     'DumpTriggerLevel' : {'doc' : "Default is to never dump RAM-stored log messages.", 'type' : "Int"},
 *     'Associate' : {'doc' : "Enable automatic association of the controller with group one of every device.", 'type' : "Bool"},
 *     'Exclude' : {'doc' : "Remove support for the listed command classes.", 'type' : "String"},             # <<<<<<<<<<<<<<
 *     'Include' : {'doc' : "Only handle the specified command classes. The Exclude option is ignored if anything is listed here.", 'type' : "String"},
 *     'NotifyTransactions' : {'doc' : "Notifications when transaction complete is reported.", 'type' : "Bool"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 313, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Remove_support_for_the_listed_co) < 0) __PYX_ERR(0, 313, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_String) < 0) __PYX_ERR(0, 313, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Exclude, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":314
 *     'Associate' : {'doc' : "Enable automatic association of the controller with group one of every device.", 'type' : "Bool"},
 *     'Exclude' : {'doc' : "Remove support for the listed command classes.", 'type' : "String"},
 *     'Include' : {'doc' : "Only handle the specified command classes. The Exclude option is ignored if anything is listed here.", 'type' : "String"},             # <<<<<<<<<<<<<<
 *     'NotifyTransactions' : {'doc' : "Notifications when transaction complete is reported.", 'type' : "Bool"},
 *     'Interface' : {'doc' : "Identify the serial port to be accessed (TODO: change the code so more than one serial port can be specified and HID).", 'type' : "String"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 314, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Only_handle_the_specified_comman) < 0) __PYX_ERR(0, 314, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_String) < 0) __PYX_ERR(0, 314, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Include, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":315
 *     'Exclude' : {'doc' : "Remove support for the listed command classes.", 'type' : "String"},
 *     'Include' : {'doc' : "Only handle the specified command classes. The Exclude option is ignored if anything is listed here.", 'type' : "String"},
 *     'NotifyTransactions' : {'doc' : "Notifications when transaction complete is reported.", 'type' : "Bool"},             # <<<<<<<<<<<<<<
 *     'Interface' : {'doc' : "Identify the serial port to be accessed (TODO: change the code so more than one serial port can be specified and HID).", 'type' : "String"},
 *     'SaveConfiguration' : {'doc' : "Save the XML configuration upon driver close.", 'type' : "Bool"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 315, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Notifications_when_transaction_c) < 0) __PYX_ERR(0, 315, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Bool) < 0) __PYX_ERR(0, 315, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_NotifyTransactions, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":316
 *     'Include' : {'doc' : "Only handle the specified command classes. The Exclude option is ignored if anything is listed here.", 'type' : "String"},
 *     'NotifyTransactions' : {'doc' : "Notifications when transaction complete is reported.", 'type' : "Bool"},
 *     'Interface' : {'doc' : "Identify the serial port to be accessed (TODO: change the code so more than one serial port can be specified and HID).", 'type' : "String"},             # <<<<<<<<<<<<<<
 *     'SaveConfiguration' : {'doc' : "Save the XML configuration upon driver close.", 'type' : "Bool"},
 *     'DriverMaxAttempts' : {'doc' : ".", 'type' : "Int"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 316, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Identify_the_serial_port_to_be_a) < 0) __PYX_ERR(0, 316, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_String) < 0) __PYX_ERR(0, 316, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Interface, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":317
 *     'NotifyTransactions' : {'doc' : "Notifications when transaction complete is reported.", 'type' : "Bool"},
 *     'Interface' : {'doc' : "Identify the serial port to be accessed (TODO: change the code so more than one serial port can be specified and HID).", 'type' : "String"},
 *     'SaveConfiguration' : {'doc' : "Save the XML configuration upon driver close.", 'type' : "Bool"},             # <<<<<<<<<<<<<<
 *     'DriverMaxAttempts' : {'doc' : ".", 'type' : "Int"},
 *     'PollInterval' : {'doc' : "30 seconds (can easily poll 30 values in this time; ~120 values is the effective limit for 30 seconds).", 'type' : "Int"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 317, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Save_the_XML_configuration_upon) < 0) __PYX_ERR(0, 317, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Bool) < 0) __PYX_ERR(0, 317, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_SaveConfiguration, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":318
 *     'Interface' : {'doc' : "Identify the serial port to be accessed (TODO: change the code so more than one serial port can be specified and HID).", 'type' : "String"},
 *     'SaveConfiguration' : {'doc' : "Save the XML configuration upon driver close.", 'type' : "Bool"},
 *     'DriverMaxAttempts' : {'doc' : ".", 'type' : "Int"},             # <<<<<<<<<<<<<<
 *     'PollInterval' : {'doc' : "30 seconds (can easily poll 30 values in this time; ~120 values is the effective limit for 30 seconds).", 'type' : "Int"},
 *     'IntervalBetweenPolls' : {'doc' : "If false, try to execute the entire poll list within the PollInterval time frame. If true, wait for PollInterval milliseconds between polls.", 'type' : "Bool"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 318, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s__29) < 0) __PYX_ERR(0, 318, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Int) < 0) __PYX_ERR(0, 318, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_DriverMaxAttempts, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":319
 *     'SaveConfiguration' : {'doc' : "Save the XML configuration upon driver close.", 'type' : "Bool"},
 *     'DriverMaxAttempts' : {'doc' : ".", 'type' : "Int"},
 *     'PollInterval' : {'doc' : "30 seconds (can easily poll 30 values in this time; ~120 values is the effective limit for 30 seconds).", 'type' : "Int"},             # <<<<<<<<<<<<<<
 *     'IntervalBetweenPolls' : {'doc' : "If false, try to execute the entire poll list within the PollInterval time frame. If true, wait for PollInterval milliseconds between polls.", 'type' : "Bool"},
 *     'SuppressValueRefresh' : {'doc' : "If true, notifications for refreshed (but unchanged) values will not be sent.", 'type' : "Bool"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 319, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_30_seconds_can_easily_poll_30_va) < 0) __PYX_ERR(0, 319, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Int) < 0) __PYX_ERR(0, 319, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_PollInterval, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":320
 *     'DriverMaxAttempts' : {'doc' : ".", 'type' : "Int"},
 *     'PollInterval' : {'doc' : "30 seconds (can easily poll 30 values in this time; ~120 values is the effective limit for 30 seconds).", 'type' : "Int"},
 *     'IntervalBetweenPolls' : {'doc' : "If false, try to execute the entire poll list within the PollInterval time frame. If true, wait for PollInterval milliseconds between polls.", 'type' : "Bool"},             # <<<<<<<<<<<<<<
 *     'SuppressValueRefresh' : {'doc' : "If true, notifications for refreshed (but unchanged) values will not be sent.", 'type' : "Bool"},
 *     'PerformReturnRoutes' : {'doc' : "If true, return routes will be updated.", 'type' : "Bool"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 320, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_If_false_try_to_execute_the_enti) < 0) __PYX_ERR(0, 320, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Bool) < 0) __PYX_ERR(0, 320, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_IntervalBetweenPolls, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":321
 *     'PollInterval' : {'doc' : "30 seconds (can easily poll 30 values in this time; ~120 values is the effective limit for 30 seconds).", 'type' : "Int"},
 *     'IntervalBetweenPolls' : {'doc' : "If false, try to execute the entire poll list within the PollInterval time frame. If true, wait for PollInterval milliseconds between polls.", 'type' : "Bool"},
 *     'SuppressValueRefresh' : {'doc' : "If true, notifications for refreshed (but unchanged) values will not be sent.", 'type' : "Bool"},             # <<<<<<<<<<<<<<
 *     'PerformReturnRoutes' : {'doc' : "If true, return routes will be updated.", 'type' : "Bool"},
 *     'NetworkKey' : {'doc' : "Key used to negotiate and communicate with devices that support Security Command Class", 'type' : "String"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 321, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_If_true_notifications_for_refres) < 0) __PYX_ERR(0, 321, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Bool) < 0) __PYX_ERR(0, 321, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_SuppressValueRefresh, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":322
 *     'IntervalBetweenPolls' : {'doc' : "If false, try to execute the entire poll list within the PollInterval time frame. If true, wait for PollInterval milliseconds between polls.", 'type' : "Bool"},
 *     'SuppressValueRefresh' : {'doc' : "If true, notifications for refreshed (but unchanged) values will not be sent.", 'type' : "Bool"},
 *     'PerformReturnRoutes' : {'doc' : "If true, return routes will be updated.", 'type' : "Bool"},             # <<<<<<<<<<<<<<
 *     'NetworkKey' : {'doc' : "Key used to negotiate and communicate with devices that support Security Command Class", 'type' : "String"},
 *     'RefreshAllUserCodes' : {'doc' : "If true, during startup, we refresh all the UserCodes the device reports it supports. If False, we stop after we get the first 'Available' slot (Some devices have 250+ usercode slots! - That makes our Session Stage Very Long ).", 'type' : "Bool"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 322, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_If_true_return_routes_will_be_up) < 0) __PYX_ERR(0, 322, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Bool) < 0) __PYX_ERR(0, 322, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_PerformReturnRoutes, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":323
 *     'SuppressValueRefresh' : {'doc' : "If true, notifications for refreshed (but unchanged) values will not be sent.", 'type' : "Bool"},
 *     'PerformReturnRoutes' : {'doc' : "If true, return routes will be updated.", 'type' : "Bool"},
 *     'NetworkKey' : {'doc' : "Key used to negotiate and communicate with devices that support Security Command Class", 'type' : "String"},             # <<<<<<<<<<<<<<
 *     'RefreshAllUserCodes' : {'doc' : "If true, during startup, we refresh all the UserCodes the device reports it supports. If False, we stop after we get the first 'Available' slot (Some devices have 250+ usercode slots! - That makes our Session Stage Very Long ).", 'type' : "Bool"},
 *     'RetryTimeout' : {'doc' : "How long do we wait to timeout messages sent.", 'type' : "Int"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 323, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Key_used_to_negotiate_and_commun) < 0) __PYX_ERR(0, 323, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_String) < 0) __PYX_ERR(0, 323, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_NetworkKey, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":324
 *     'PerformReturnRoutes' : {'doc' : "If true, return routes will be updated.", 'type' : "Bool"},
 *     'NetworkKey' : {'doc' : "Key used to negotiate and communicate with devices that support Security Command Class", 'type' : "String"},
 *     'RefreshAllUserCodes' : {'doc' : "If true, during startup, we refresh all the UserCodes the device reports it supports. If False, we stop after we get the first 'Available' slot (Some devices have 250+ usercode slots! - That makes our Session Stage Very Long ).", 'type' : "Bool"},             # <<<<<<<<<<<<<<
 *     'RetryTimeout' : {'doc' : "How long do we wait to timeout messages sent.", 'type' : "Int"},
 *     'EnableSIS' : {'doc' : "Automatically become a SUC if there is no SUC on the network.", 'type' : "Bool"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 324, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_If_true_during_startup_we_refres) < 0) __PYX_ERR(0, 324, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Bool) < 0) __PYX_ERR(0, 324, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_RefreshAllUserCodes, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":325
 *     'NetworkKey' : {'doc' : "Key used to negotiate and communicate with devices that support Security Command Class", 'type' : "String"},
 *     'RefreshAllUserCodes' : {'doc' : "If true, during startup, we refresh all the UserCodes the device reports it supports. If False, we stop after we get the first 'Available' slot (Some devices have 250+ usercode slots! - That makes our Session Stage Very Long ).", 'type' : "Bool"},
 *     'RetryTimeout' : {'doc' : "How long do we wait to timeout messages sent.", 'type' : "Int"},             # <<<<<<<<<<<<<<
 *     'EnableSIS' : {'doc' : "Automatically become a SUC if there is no SUC on the network.", 'type' : "Bool"},
 *     'AssumeAwake' : {'doc' : "Assume Devices that Support the Wakeup CC are awake when we first query them ...", 'type' : "Bool"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 325, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_How_long_do_we_wait_to_timeout_m) < 0) __PYX_ERR(0, 325, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Int) < 0) __PYX_ERR(0, 325, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_RetryTimeout, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":326
 *     'RefreshAllUserCodes' : {'doc' : "If true, during startup, we refresh all the UserCodes the device reports it supports. If False, we stop after we get the first 'Available' slot (Some devices have 250+ usercode slots! - That makes our Session Stage Very Long ).", 'type' : "Bool"},
 *     'RetryTimeout' : {'doc' : "How long do we wait to timeout messages sent.", 'type' : "Int"},
 *     'EnableSIS' : {'doc' : "Automatically become a SUC if there is no SUC on the network.", 'type' : "Bool"},             # <<<<<<<<<<<<<<
 *     'AssumeAwake' : {'doc' : "Assume Devices that Support the Wakeup CC are awake when we first query them ...", 'type' : "Bool"},
 *     'NotifyOnDriverUnload' : {'doc' : "Should we send the Node/Value Notifications on Driver Unloading - Read comments in Driver::~Driver() method about possible race conditions.", 'type' : "Bool"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 326, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Automatically_become_a_SUC_if_th) < 0) __PYX_ERR(0, 326, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Bool) < 0) __PYX_ERR(0, 326, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_EnableSIS, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":327
 *     'RetryTimeout' : {'doc' : "How long do we wait to timeout messages sent.", 'type' : "Int"},
 *     'EnableSIS' : {'doc' : "Automatically become a SUC if there is no SUC on the network.", 'type' : "Bool"},
 *     'AssumeAwake' : {'doc' : "Assume Devices that Support the Wakeup CC are awake when we first query them ...", 'type' : "Bool"},             # <<<<<<<<<<<<<<
 *     'NotifyOnDriverUnload' : {'doc' : "Should we send the Node/Value Notifications on Driver Unloading - Read comments in Driver::~Driver() method about possible race conditions.", 'type' : "Bool"},
 *     'SecurityStrategy' : {'doc' : "Should we encrypt CC's that are available via both clear text and Security CC?.", 'type' : "String", 'value' : 'SUPPORTED'},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 327, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Assume_Devices_that_Support_the) < 0) __PYX_ERR(0, 327, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Bool) < 0) __PYX_ERR(0, 327, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_AssumeAwake, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":328
 *     'EnableSIS' : {'doc' : "Automatically become a SUC if there is no SUC on the network.", 'type' : "Bool"},
 *     'AssumeAwake' : {'doc' : "Assume Devices that Support the Wakeup CC are awake when we first query them ...", 'type' : "Bool"},
 *     'NotifyOnDriverUnload' : {'doc' : "Should we send the Node/Value Notifications on Driver Unloading - Read comments in Driver::~Driver() method about possible race conditions.", 'type' : "Bool"},             # <<<<<<<<<<<<<<
 *     'SecurityStrategy' : {'doc' : "Should we encrypt CC's that are available via both clear text and Security CC?.", 'type' : "String", 'value' : 'SUPPORTED'},
 *     'CustomSecuredCC' : {'doc' : "What List of Custom CC should we always encrypt if SecurityStrategy is CUSTOM.", 'type' : "String", 'value' : '0x62,0x4c,0x63'},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 328, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Should_we_send_the_Node_Value_No) < 0) __PYX_ERR(0, 328, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Bool) < 0) __PYX_ERR(0, 328, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_NotifyOnDriverUnload, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":329
 *     'AssumeAwake' : {'doc' : "Assume Devices that Support the Wakeup CC are awake when we first query them ...", 'type' : "Bool"},
 *     'NotifyOnDriverUnload' : {'doc' : "Should we send the Node/Value Notifications on Driver Unloading - Read comments in Driver::~Driver() method about possible race conditions.", 'type' : "Bool"},
 *     'SecurityStrategy' : {'doc' : "Should we encrypt CC's that are available via both clear text and Security CC?.", 'type' : "String", 'value' : 'SUPPORTED'},             # <<<<<<<<<<<<<<
 *     'CustomSecuredCC' : {'doc' : "What List of Custom CC should we always encrypt if SecurityStrategy is CUSTOM.", 'type' : "String", 'value' : '0x62,0x4c,0x63'},
 *     'EnforceSecureReception' : {'doc' : "If we recieve a clear text message for a CC that is Secured, should we drop the message", 'type' : "Bool"},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 329, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Should_we_encrypt_CC_s_that_are) < 0) __PYX_ERR(0, 329, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_String) < 0) __PYX_ERR(0, 329, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_value, __pyx_n_s_SUPPORTED) < 0) __PYX_ERR(0, 329, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_SecurityStrategy, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":330
 *     'NotifyOnDriverUnload' : {'doc' : "Should we send the Node/Value Notifications on Driver Unloading - Read comments in Driver::~Driver() method about possible race conditions.", 'type' : "Bool"},
 *     'SecurityStrategy' : {'doc' : "Should we encrypt CC's that are available via both clear text and Security CC?.", 'type' : "String", 'value' : 'SUPPORTED'},
 *     'CustomSecuredCC' : {'doc' : "What List of Custom CC should we always encrypt if SecurityStrategy is CUSTOM.", 'type' : "String", 'value' : '0x62,0x4c,0x63'},             # <<<<<<<<<<<<<<
 *     'EnforceSecureReception' : {'doc' : "If we recieve a clear text message for a CC that is Secured, should we drop the message", 'type' : "Bool"},
 * }
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 330, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_What_List_of_Custom_CC_should_we) < 0) __PYX_ERR(0, 330, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_String) < 0) __PYX_ERR(0, 330, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_value, __pyx_kp_s_0x62_0x4c_0x63) < 0) __PYX_ERR(0, 330, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_CustomSecuredCC, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":331
 *     'SecurityStrategy' : {'doc' : "Should we encrypt CC's that are available via both clear text and Security CC?.", 'type' : "String", 'value' : 'SUPPORTED'},
 *     'CustomSecuredCC' : {'doc' : "What List of Custom CC should we always encrypt if SecurityStrategy is CUSTOM.", 'type' : "String", 'value' : '0x62,0x4c,0x63'},
 *     'EnforceSecureReception' : {'doc' : "If we recieve a clear text message for a CC that is Secured, should we drop the message", 'type' : "Bool"},             # <<<<<<<<<<<<<<
 * }
 * 
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 331, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_If_we_recieve_a_clear_text_messa) < 0) __PYX_ERR(0, 331, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_type, __pyx_n_s_Bool) < 0) __PYX_ERR(0, 331, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_EnforceSecureReception, __pyx_t_36) < 0) __PYX_ERR(0, 303, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PyOptionList, __pyx_t_1) < 0) __PYX_ERR(0, 302, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":335
 * 
 * PyStatDriver = {
 *     'SOFCnt' : "Number of SOF bytes received",             # <<<<<<<<<<<<<<
 *     'ACKWaiting' : "Number of unsolicited messages while waiting for an ACK",
 *     'readAborts' : "Number of times read were aborted due to timeouts",
 */
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 335, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_SOFCnt, __pyx_kp_s_Number_of_SOF_bytes_received) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_ACKWaiting, __pyx_kp_s_Number_of_unsolicited_messages_w) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_readAborts, __pyx_kp_s_Number_of_times_read_were_aborte) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_badChecksum, __pyx_kp_s_Number_of_bad_checksums) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_readCnt, __pyx_kp_s_Number_of_messages_successfully) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_writeCnt, __pyx_kp_s_Number_of_messages_successfully_2) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_CANCnt, __pyx_kp_s_Number_of_CAN_bytes_received) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_NAKCnt, __pyx_kp_s_Number_of_NAK_bytes_received) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_ACKCnt, __pyx_kp_s_Number_of_ACK_bytes_received) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_OOFCnt, __pyx_kp_s_Number_of_bytes_out_of_framing) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_dropped, __pyx_kp_s_Number_of_messages_dropped_not_d) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_retries, __pyx_kp_s_Number_of_messages_retransmitted) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_callbacks, __pyx_kp_s_Number_of_unexpected_callbacks) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_badroutes, __pyx_kp_s_Number_of_failed_messages_due_to) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_noack, __pyx_kp_s_Number_of_no_ACK_returned_errors) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_netbusy, __pyx_kp_s_Number_of_network_busy_failure_m) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_nondelivery, __pyx_kp_s_Number_of_messages_not_delivered) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_routedbusy, __pyx_kp_s_Number_of_messages_received_with) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_broadcastReadCnt, __pyx_kp_s_Number_of_broadcasts_read) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_broadcastWriteCnt, __pyx_kp_s_Number_of_broadcasts_sent) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PyStatDriver, __pyx_t_1) < 0) __PYX_ERR(0, 334, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":358
 * 
 * PyLogLevels = {
 *     'Invalid' : {'doc':'Invalid Log Status', 'value':0},             # <<<<<<<<<<<<<<
 *     'None' : {'doc':'Disable all logging', 'value':1},
 *     'Always' : {'doc':'These messages should always be shown', 'value':2},
 */
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 358, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 358, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Invalid_Log_Status) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_value, __pyx_int_0) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Invalid, __pyx_t_36) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":359
 * PyLogLevels = {
 *     'Invalid' : {'doc':'Invalid Log Status', 'value':0},
 *     'None' : {'doc':'Disable all logging', 'value':1},             # <<<<<<<<<<<<<<
 *     'Always' : {'doc':'These messages should always be shown', 'value':2},
 *     'Fatal' : {'doc':'A likely fatal issue in the library', 'value':3},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 359, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Disable_all_logging) < 0) __PYX_ERR(0, 359, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_value, __pyx_int_1) < 0) __PYX_ERR(0, 359, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_None, __pyx_t_36) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":360
 *     'Invalid' : {'doc':'Invalid Log Status', 'value':0},
 *     'None' : {'doc':'Disable all logging', 'value':1},
 *     'Always' : {'doc':'These messages should always be shown', 'value':2},             # <<<<<<<<<<<<<<
 *     'Fatal' : {'doc':'A likely fatal issue in the library', 'value':3},
 *     'Error' : {'doc':'A serious issue with the library or the network', 'value':4},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 360, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_These_messages_should_always_be) < 0) __PYX_ERR(0, 360, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_value, __pyx_int_2) < 0) __PYX_ERR(0, 360, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Always, __pyx_t_36) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":361
 *     'None' : {'doc':'Disable all logging', 'value':1},
 *     'Always' : {'doc':'These messages should always be shown', 'value':2},
 *     'Fatal' : {'doc':'A likely fatal issue in the library', 'value':3},             # <<<<<<<<<<<<<<
 *     'Error' : {'doc':'A serious issue with the library or the network', 'value':4},
 *     'Warning' : {'doc':'A minor issue from which the library should be able to recover', 'value':5},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 361, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_A_likely_fatal_issue_in_the_libr) < 0) __PYX_ERR(0, 361, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_value, __pyx_int_3) < 0) __PYX_ERR(0, 361, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Fatal, __pyx_t_36) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":362
 *     'Always' : {'doc':'These messages should always be shown', 'value':2},
 *     'Fatal' : {'doc':'A likely fatal issue in the library', 'value':3},
 *     'Error' : {'doc':'A serious issue with the library or the network', 'value':4},             # <<<<<<<<<<<<<<
 *     'Warning' : {'doc':'A minor issue from which the library should be able to recover', 'value':5},
 *     'Alert' : {'doc':'Something unexpected by the library about which the controlling application should be aware', 'value':6},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 362, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_A_serious_issue_with_the_library) < 0) __PYX_ERR(0, 362, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_value, __pyx_int_4) < 0) __PYX_ERR(0, 362, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Error, __pyx_t_36) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":363
 *     'Fatal' : {'doc':'A likely fatal issue in the library', 'value':3},
 *     'Error' : {'doc':'A serious issue with the library or the network', 'value':4},
 *     'Warning' : {'doc':'A minor issue from which the library should be able to recover', 'value':5},             # <<<<<<<<<<<<<<
 *     'Alert' : {'doc':'Something unexpected by the library about which the controlling application should be aware', 'value':6},
 *     'Info' : {'doc':"Everything's working fine...these messages provide streamlined feedback on each message", 'value':7},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 363, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_A_minor_issue_from_which_the_lib) < 0) __PYX_ERR(0, 363, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_value, __pyx_int_5) < 0) __PYX_ERR(0, 363, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Warning, __pyx_t_36) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":364
 *     'Error' : {'doc':'A serious issue with the library or the network', 'value':4},
 *     'Warning' : {'doc':'A minor issue from which the library should be able to recover', 'value':5},
 *     'Alert' : {'doc':'Something unexpected by the library about which the controlling application should be aware', 'value':6},             # <<<<<<<<<<<<<<
 *     'Info' : {'doc':"Everything's working fine...these messages provide streamlined feedback on each message", 'value':7},
 *     'Detail' : {'doc':'Detailed information on the progress of each message', 'value':8},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 364, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Something_unexpected_by_the_libr) < 0) __PYX_ERR(0, 364, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_value, __pyx_int_6) < 0) __PYX_ERR(0, 364, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Alert, __pyx_t_36) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":365
 *     'Warning' : {'doc':'A minor issue from which the library should be able to recover', 'value':5},
 *     'Alert' : {'doc':'Something unexpected by the library about which the controlling application should be aware', 'value':6},
 *     'Info' : {'doc':"Everything's working fine...these messages provide streamlined feedback on each message", 'value':7},             # <<<<<<<<<<<<<<
 *     'Detail' : {'doc':'Detailed information on the progress of each message', 'value':8},
 *     'Debug' : {'doc':'Very detailed information on progress that will create a huge log file quickly but this level (as others) can be queued and sent to the log only on an error or warning', 'value':9},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 365, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Everything_s_working_fine_these) < 0) __PYX_ERR(0, 365, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_value, __pyx_int_7) < 0) __PYX_ERR(0, 365, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Info, __pyx_t_36) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":366
 *     'Alert' : {'doc':'Something unexpected by the library about which the controlling application should be aware', 'value':6},
 *     'Info' : {'doc':"Everything's working fine...these messages provide streamlined feedback on each message", 'value':7},
 *     'Detail' : {'doc':'Detailed information on the progress of each message', 'value':8},             # <<<<<<<<<<<<<<
 *     'Debug' : {'doc':'Very detailed information on progress that will create a huge log file quickly but this level (as others) can be queued and sent to the log only on an error or warning', 'value':9},
 *     'StreamDetail' : {'doc':'Will include low-level byte transfers from controller to buffer to application and back', 'value':10},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 366, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Detailed_information_on_the_prog) < 0) __PYX_ERR(0, 366, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_value, __pyx_int_8) < 0) __PYX_ERR(0, 366, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Detail, __pyx_t_36) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":367
 *     'Info' : {'doc':"Everything's working fine...these messages provide streamlined feedback on each message", 'value':7},
 *     'Detail' : {'doc':'Detailed information on the progress of each message', 'value':8},
 *     'Debug' : {'doc':'Very detailed information on progress that will create a huge log file quickly but this level (as others) can be queued and sent to the log only on an error or warning', 'value':9},             # <<<<<<<<<<<<<<
 *     'StreamDetail' : {'doc':'Will include low-level byte transfers from controller to buffer to application and back', 'value':10},
 *     'Internal' : {'doc':'Used only within the log class (uses existing timestamp, etc', 'value':11},
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 367, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Very_detailed_information_on_pro) < 0) __PYX_ERR(0, 367, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_value, __pyx_int_9) < 0) __PYX_ERR(0, 367, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Debug, __pyx_t_36) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":368
 *     'Detail' : {'doc':'Detailed information on the progress of each message', 'value':8},
 *     'Debug' : {'doc':'Very detailed information on progress that will create a huge log file quickly but this level (as others) can be queued and sent to the log only on an error or warning', 'value':9},
 *     'StreamDetail' : {'doc':'Will include low-level byte transfers from controller to buffer to application and back', 'value':10},             # <<<<<<<<<<<<<<
 *     'Internal' : {'doc':'Used only within the log class (uses existing timestamp, etc', 'value':11},
 *     }
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 368, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Will_include_low_level_byte_tran) < 0) __PYX_ERR(0, 368, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_value, __pyx_int_10) < 0) __PYX_ERR(0, 368, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_StreamDetail, __pyx_t_36) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;

  /* "libopenzwave.pyx":369
 *     'Debug' : {'doc':'Very detailed information on progress that will create a huge log file quickly but this level (as others) can be queued and sent to the log only on an error or warning', 'value':9},
 *     'StreamDetail' : {'doc':'Will include low-level byte transfers from controller to buffer to application and back', 'value':10},
 *     'Internal' : {'doc':'Used only within the log class (uses existing timestamp, etc', 'value':11},             # <<<<<<<<<<<<<<
 *     }
 * 
 */
  __pyx_t_36 = PyDict_New(); if (unlikely(!__pyx_t_36)) __PYX_ERR(0, 369, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_36);
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_doc, __pyx_kp_s_Used_only_within_the_log_class_u) < 0) __PYX_ERR(0, 369, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_36, __pyx_n_s_value, __pyx_int_11) < 0) __PYX_ERR(0, 369, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Internal, __pyx_t_36) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_36); __pyx_t_36 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PyLogLevels, __pyx_t_1) < 0) __PYX_ERR(0, 357, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":598
 *     cdef DriverData data
 * 
 * def configPath():             # <<<<<<<<<<<<<<
 *     '''
 *     Retrieve the config path. This directory hold the xml files.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_12libopenzwave_3configPath, NULL, __pyx_n_s_libopenzwave); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 598, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_configPath, __pyx_t_1) < 0) __PYX_ERR(0, 598, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "libopenzwave.pyx":1023
 *     '''
 *     COMMAND_CLASS_DESC = {
 *         0x00: 'COMMAND_CLASS_NO_OPERATION',             # <<<<<<<<<<<<<<
 *         0x20: 'COMMAND_CLASS_BASIC',
 *         0x21: 'COMMAND_CLASS_CONTROLLER_REPLICATION',
 */
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1023, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_0, __pyx_n_s_COMMAND_CLASS_NO_OPERATION) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_32, __pyx_n_s_COMMAND_CLASS_BASIC) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_33, __pyx_n_s_COMMAND_CLASS_CONTROLLER_REPLICA) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_34, __pyx_n_s_COMMAND_CLASS_APPLICATION_STATUS) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_35, __pyx_n_s_COMMAND_CLASS_ZIP_SERVICES) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_36, __pyx_n_s_COMMAND_CLASS_ZIP_SERVER) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_37, __pyx_n_s_COMMAND_CLASS_SWITCH_BINARY) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_38, __pyx_n_s_COMMAND_CLASS_SWITCH_MULTILEVEL) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_39, __pyx_n_s_COMMAND_CLASS_SWITCH_ALL) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_40, __pyx_n_s_COMMAND_CLASS_SWITCH_TOGGLE_BINA) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_41, __pyx_n_s_COMMAND_CLASS_SWITCH_TOGGLE_MULT) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_42, __pyx_n_s_COMMAND_CLASS_CHIMNEY_FAN) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_43, __pyx_n_s_COMMAND_CLASS_SCENE_ACTIVATION) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_44, __pyx_n_s_COMMAND_CLASS_SCENE_ACTUATOR_CON) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_45, __pyx_n_s_COMMAND_CLASS_SCENE_CONTROLLER_C) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_46, __pyx_n_s_COMMAND_CLASS_ZIP_CLIENT) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_47, __pyx_n_s_COMMAND_CLASS_ZIP_ADV_SERVICES) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_48, __pyx_n_s_COMMAND_CLASS_SENSOR_BINARY) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_49, __pyx_n_s_COMMAND_CLASS_SENSOR_MULTILEVEL) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_50, __pyx_n_s_COMMAND_CLASS_METER) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_51, __pyx_n_s_COMMAND_CLASS_COLOR) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_52, __pyx_n_s_COMMAND_CLASS_ZIP_ADV_CLIENT) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_53, __pyx_n_s_COMMAND_CLASS_METER_PULSE) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_60, __pyx_n_s_COMMAND_CLASS_METER_TBL_CONFIG) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_61, __pyx_n_s_COMMAND_CLASS_METER_TBL_MONITOR) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_62, __pyx_n_s_COMMAND_CLASS_METER_TBL_PUSH) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_56, __pyx_n_s_COMMAND_CLASS_THERMOSTAT_HEATING) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_64, __pyx_n_s_COMMAND_CLASS_THERMOSTAT_MODE) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_66, __pyx_n_s_COMMAND_CLASS_THERMOSTAT_OPERATI) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_67, __pyx_n_s_COMMAND_CLASS_THERMOSTAT_SETPOIN) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_68, __pyx_n_s_COMMAND_CLASS_THERMOSTAT_FAN_MOD) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_69, __pyx_n_s_COMMAND_CLASS_THERMOSTAT_FAN_STA) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_70, __pyx_n_s_COMMAND_CLASS_CLIMATE_CONTROL_SC) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_71, __pyx_n_s_COMMAND_CLASS_THERMOSTAT_SETBACK) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_76, __pyx_n_s_COMMAND_CLASS_DOOR_LOCK_LOGGING) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_78, __pyx_n_s_COMMAND_CLASS_SCHEDULE_ENTRY_LOC) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_80, __pyx_n_s_COMMAND_CLASS_BASIC_WINDOW_COVER) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_81, __pyx_n_s_COMMAND_CLASS_MTP_WINDOW_COVERIN) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_86, __pyx_n_s_COMMAND_CLASS_CRC_16_ENCAP) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_90, __pyx_n_s_COMMAND_CLASS_DEVICE_RESET_LOCAL) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_91, __pyx_n_s_COMMAND_CLASS_CENTRAL_SCENE) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_94, __pyx_n_s_COMMAND_CLASS_ZWAVE_PLUS_INFO) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_96, __pyx_kp_s_COMMAND_CLASS_MULTI_INSTANCE_CHA) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_97, __pyx_n_s_COMMAND_CLASS_DISPLAY) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_98, __pyx_n_s_COMMAND_CLASS_DOOR_LOCK) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_99, __pyx_n_s_COMMAND_CLASS_USER_CODE) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_100, __pyx_n_s_COMMAND_CLASS_GARAGE_DOOR) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_102, __pyx_n_s_COMMAND_CLASS_BARRIER_OPERATOR) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_112, __pyx_n_s_COMMAND_CLASS_CONFIGURATION) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_113, __pyx_n_s_COMMAND_CLASS_ALARM) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_114, __pyx_n_s_COMMAND_CLASS_MANUFACTURER_SPECI) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_115, __pyx_n_s_COMMAND_CLASS_POWERLEVEL) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_117, __pyx_n_s_COMMAND_CLASS_PROTECTION) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_118, __pyx_n_s_COMMAND_CLASS_LOCK) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_119, __pyx_n_s_COMMAND_CLASS_NODE_NAMING) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_120, __pyx_n_s_COMMAND_CLASS_ACTUATOR_MULTILEVE) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_121, __pyx_n_s_COMMAND_CLASS_KICK) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_122, __pyx_n_s_COMMAND_CLASS_FIRMWARE_UPDATE_MD) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_123, __pyx_n_s_COMMAND_CLASS_GROUPING_NAME) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_124, __pyx_n_s_COMMAND_CLASS_REMOTE_ASSOCIATION) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_125, __pyx_n_s_COMMAND_CLASS_REMOTE_ASSOCIATION_2) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_128, __pyx_n_s_COMMAND_CLASS_BATTERY) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_129, __pyx_n_s_COMMAND_CLASS_CLOCK) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_130, __pyx_n_s_COMMAND_CLASS_HAIL) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_131, __pyx_n_s_COMMAND_CLASS_NETWORK_STAT) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_132, __pyx_n_s_COMMAND_CLASS_WAKE_UP) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_133, __pyx_n_s_COMMAND_CLASS_ASSOCIATION) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_134, __pyx_n_s_COMMAND_CLASS_VERSION) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_135, __pyx_n_s_COMMAND_CLASS_INDICATOR) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_136, __pyx_n_s_COMMAND_CLASS_PROPRIETARY) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_137, __pyx_n_s_COMMAND_CLASS_LANGUAGE) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_138, __pyx_n_s_COMMAND_CLASS_TIME) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_139, __pyx_n_s_COMMAND_CLASS_TIME_PARAMETERS) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_140, __pyx_n_s_COMMAND_CLASS_GEOGRAPHIC_LOCATIO) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_141, __pyx_n_s_COMMAND_CLASS_COMPOSITE) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_142, __pyx_n_s_COMMAND_CLASS_MULTI_CHANNEL_ASSO) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_143, __pyx_n_s_COMMAND_CLASS_MULTI_CMD) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_144, __pyx_n_s_COMMAND_CLASS_ENERGY_PRODUCTION) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_145, __pyx_n_s_COMMAND_CLASS_MANUFACTURER_PROPR) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_146, __pyx_n_s_COMMAND_CLASS_SCREEN_MD) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_147, __pyx_n_s_COMMAND_CLASS_SCREEN_ATTRIBUTES) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_148, __pyx_n_s_COMMAND_CLASS_SIMPLE_AV_CONTROL) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_149, __pyx_n_s_COMMAND_CLASS_AV_CONTENT_DIRECTO) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_150, __pyx_n_s_COMMAND_CLASS_AV_RENDERER_STATUS) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_151, __pyx_n_s_COMMAND_CLASS_AV_CONTENT_SEARCH) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_152, __pyx_n_s_COMMAND_CLASS_SECURITY) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_153, __pyx_n_s_COMMAND_CLASS_AV_TAGGING_MD) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_154, __pyx_n_s_COMMAND_CLASS_IP_CONFIGURATION) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_155, __pyx_n_s_COMMAND_CLASS_ASSOCIATION_COMMAN) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_156, __pyx_n_s_COMMAND_CLASS_SENSOR_ALARM) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_157, __pyx_n_s_COMMAND_CLASS_SILENCE_ALARM) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_158, __pyx_n_s_COMMAND_CLASS_SENSOR_CONFIGURATI) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_239, __pyx_n_s_COMMAND_CLASS_MARK) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_int_240, __pyx_n_s_COMMAND_CLASS_NON_INTEROPERABLE) < 0) __PYX_ERR(0, 1023, __pyx_L1_error)
  if (PyDict_SetItem((PyObject *)__pyx_ptype_12libopenzwave_PyManager->tp_dict, __pyx_n_s_COMMAND_CLASS_DESC, __pyx_t_1) < 0) __PYX_ERR(0, 1022, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_12libopenzwave_PyManager);

  /* "libopenzwave.pyx":1123
 *     '''
 * 
 *     CALLBACK_DESC = ('value added','value removed','value changed','groups changed','new node','node added',             # <<<<<<<<<<<<<<
 *                      'node removed','node protocol info','node naming','node event','polling disabled',
 *                      'polling enabled','driver ready','driver reset','message complete','node queries complete',
 */
  if (PyDict_SetItem((PyObject *)__pyx_ptype_12libopenzwave_PyManager->tp_dict, __pyx_n_s_CALLBACK_DESC, __pyx_tuple__246) < 0) __PYX_ERR(0, 1123, __pyx_L1_error)
  PyType_Modified(__pyx_ptype_12libopenzwave_PyManager);

  /* "libopenzwave.pyx":1
 * # -*- coding: utf-8 -*-             # <<<<<<<<<<<<<<
 * #cython: c_string_type=unicode, c_string_encoding=utf8
 * 
 */
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "string.to_py":55
 * 
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
 * 
 */

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_XDECREF(__pyx_t_14);
  __Pyx_XDECREF(__pyx_t_15);
  __Pyx_XDECREF(__pyx_t_16);
  __Pyx_XDECREF(__pyx_t_17);
  __Pyx_XDECREF(__pyx_t_18);
  __Pyx_XDECREF(__pyx_t_19);
  __Pyx_XDECREF(__pyx_t_20);
  __Pyx_XDECREF(__pyx_t_21);
  __Pyx_XDECREF(__pyx_t_22);
  __Pyx_XDECREF(__pyx_t_23);
  __Pyx_XDECREF(__pyx_t_24);
  __Pyx_XDECREF(__pyx_t_25);
  __Pyx_XDECREF(__pyx_t_26);
  __Pyx_XDECREF(__pyx_t_27);
  __Pyx_XDECREF(__pyx_t_28);
  __Pyx_XDECREF(__pyx_t_29);
  __Pyx_XDECREF(__pyx_t_30);
  __Pyx_XDECREF(__pyx_t_31);
  __Pyx_XDECREF(__pyx_t_32);
  __Pyx_XDECREF(__pyx_t_33);
  __Pyx_XDECREF(__pyx_t_34);
  __Pyx_XDECREF(__pyx_t_35);
  __Pyx_XDECREF(__pyx_t_36);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init libopenzwave", __pyx_clineno, __pyx_lineno, __pyx_filename);
    }
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init libopenzwave");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

/* --- Runtime support code --- */
/* Refnanny */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

/* GetBuiltinName */
static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

/* RaiseArgTupleInvalid */
static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

/* RaiseDoubleKeywords */
static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

/* ParseKeywords */
static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

/* PyObjectCall */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = func->ob_type->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyErrFetchRestore */
#if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
}
#endif

/* WriteUnraisableException */
static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
                                  int full_traceback, CYTHON_UNUSED int nogil) {
    PyObject *old_exc, *old_val, *old_tb;
    PyObject *ctx;
    __Pyx_PyThreadState_declare
#ifdef WITH_THREAD
    PyGILState_STATE state;
    if (nogil)
        state = PyGILState_Ensure();
#ifdef _MSC_VER
    else state = (PyGILState_STATE)-1;
#endif
#endif
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
    if (full_traceback) {
        Py_XINCREF(old_exc);
        Py_XINCREF(old_val);
        Py_XINCREF(old_tb);
        __Pyx_ErrRestore(old_exc, old_val, old_tb);
        PyErr_PrintEx(1);
    }
    #if PY_MAJOR_VERSION < 3
    ctx = PyString_FromString(name);
    #else
    ctx = PyUnicode_FromString(name);
    #endif
    __Pyx_ErrRestore(old_exc, old_val, old_tb);
    if (!ctx) {
        PyErr_WriteUnraisable(Py_None);
    } else {
        PyErr_WriteUnraisable(ctx);
        Py_DECREF(ctx);
    }
#ifdef WITH_THREAD
    if (nogil)
        PyGILState_Release(state);
#endif
}

/* GetModuleGlobalName */
static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
    PyObject *result;
#if !CYTHON_AVOID_BORROWED_REFS
    result = PyDict_GetItem(__pyx_d, name);
    if (likely(result)) {
        Py_INCREF(result);
    } else {
#else
    result = PyObject_GetItem(__pyx_d, name);
    if (!result) {
        PyErr_Clear();
#endif
        result = __Pyx_GetBuiltinName(name);
    }
    return result;
}

/* SaveResetException */
  #if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    *type = tstate->exc_type;
    *value = tstate->exc_value;
    *tb = tstate->exc_traceback;
    Py_XINCREF(*type);
    Py_XINCREF(*value);
    Py_XINCREF(*tb);
}
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = type;
    tstate->exc_value = value;
    tstate->exc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
#endif

/* GetException */
  #if CYTHON_FAST_THREAD_STATE
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb) {
#endif
    PyObject *local_type, *local_value, *local_tb;
#if CYTHON_FAST_THREAD_STATE
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    local_type = tstate->curexc_type;
    local_value = tstate->curexc_value;
    local_tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(&local_type, &local_value, &local_tb);
#endif
    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
#if CYTHON_FAST_THREAD_STATE
    if (unlikely(tstate->curexc_type))
#else
    if (unlikely(PyErr_Occurred()))
#endif
        goto bad;
    #if PY_MAJOR_VERSION >= 3
    if (local_tb) {
        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
            goto bad;
    }
    #endif
    Py_XINCREF(local_tb);
    Py_XINCREF(local_type);
    Py_XINCREF(local_value);
    *type = local_type;
    *value = local_value;
    *tb = local_tb;
#if CYTHON_FAST_THREAD_STATE
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = local_type;
    tstate->exc_value = local_value;
    tstate->exc_traceback = local_tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_SetExcInfo(local_type, local_value, local_tb);
#endif
    return 0;
bad:
    *type = 0;
    *value = 0;
    *tb = 0;
    Py_XDECREF(local_type);
    Py_XDECREF(local_value);
    Py_XDECREF(local_tb);
    return -1;
}

/* PyCFunctionFastCall */
    #if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
    PyObject *self = PyCFunction_GET_SELF(func);
    assert(PyCFunction_Check(func));
    assert(METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST)));
    assert(nargs >= 0);
    assert(nargs == 0 || args != NULL);
    /* _PyCFunction_FastCallDict() must not be called with an exception set,
       because it may clear it (directly or indirectly) and so the
       caller loses its exception */
    assert(!PyErr_Occurred());
    return (*((__Pyx_PyCFunctionFast)meth)) (self, args, nargs, NULL);
}
#endif  // CYTHON_FAST_PYCCALL

/* PyFunctionFastCall */
    #if CYTHON_FAST_PYCALL
#include "frameobject.h"
static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
                                               PyObject *globals) {
    PyFrameObject *f;
    PyThreadState *tstate = PyThreadState_GET();
    PyObject **fastlocals;
    Py_ssize_t i;
    PyObject *result;
    assert(globals != NULL);
    /* XXX Perhaps we should create a specialized
       PyFrame_New() that doesn't take locals, but does
       take builtins without sanity checking them.
       */
    assert(tstate != NULL);
    f = PyFrame_New(tstate, co, globals, NULL);
    if (f == NULL) {
        return NULL;
    }
    fastlocals = f->f_localsplus;
    for (i = 0; i < na; i++) {
        Py_INCREF(*args);
        fastlocals[i] = *args++;
    }
    result = PyEval_EvalFrameEx(f,0);
    ++tstate->recursion_depth;
    Py_DECREF(f);
    --tstate->recursion_depth;
    return result;
}
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, int nargs, PyObject *kwargs) {
    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
    PyObject *globals = PyFunction_GET_GLOBALS(func);
    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
    PyObject *closure;
#if PY_MAJOR_VERSION >= 3
    PyObject *kwdefs;
#endif
    PyObject *kwtuple, **k;
    PyObject **d;
    Py_ssize_t nd;
    Py_ssize_t nk;
    PyObject *result;
    assert(kwargs == NULL || PyDict_Check(kwargs));
    nk = kwargs ? PyDict_Size(kwargs) : 0;
    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
        return NULL;
    }
    if (
#if PY_MAJOR_VERSION >= 3
            co->co_kwonlyargcount == 0 &&
#endif
            likely(kwargs == NULL || nk == 0) &&
            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
        if (argdefs == NULL && co->co_argcount == nargs) {
            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
            goto done;
        }
        else if (nargs == 0 && argdefs != NULL
                 && co->co_argcount == Py_SIZE(argdefs)) {
            /* function called with no arguments, but all parameters have
               a default value: use default values as arguments .*/
            args = &PyTuple_GET_ITEM(argdefs, 0);
            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
            goto done;
        }
    }
    if (kwargs != NULL) {
        Py_ssize_t pos, i;
        kwtuple = PyTuple_New(2 * nk);
        if (kwtuple == NULL) {
            result = NULL;
            goto done;
        }
        k = &PyTuple_GET_ITEM(kwtuple, 0);
        pos = i = 0;
        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
            Py_INCREF(k[i]);
            Py_INCREF(k[i+1]);
            i += 2;
        }
        nk = i / 2;
    }
    else {
        kwtuple = NULL;
        k = NULL;
    }
    closure = PyFunction_GET_CLOSURE(func);
#if PY_MAJOR_VERSION >= 3
    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
#endif
    if (argdefs != NULL) {
        d = &PyTuple_GET_ITEM(argdefs, 0);
        nd = Py_SIZE(argdefs);
    }
    else {
        d = NULL;
        nd = 0;
    }
#if PY_MAJOR_VERSION >= 3
    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
                               args, nargs,
                               k, (int)nk,
                               d, (int)nd, kwdefs, closure);
#else
    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
                               args, nargs,
                               k, (int)nk,
                               d, (int)nd, closure);
#endif
    Py_XDECREF(kwtuple);
done:
    Py_LeaveRecursiveCall();
    return result;
}
#endif  // CPython < 3.6
#endif  // CYTHON_FAST_PYCALL

/* PyObjectCallMethO */
    #if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
    PyObject *self, *result;
    PyCFunction cfunc;
    cfunc = PyCFunction_GET_FUNCTION(func);
    self = PyCFunction_GET_SELF(func);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = cfunc(self, arg);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyObjectCallOneArg */
    #if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_New(1);
    if (unlikely(!args)) return NULL;
    Py_INCREF(arg);
    PyTuple_SET_ITEM(args, 0, arg);
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, &arg, 1);
    }
#endif
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
            return __Pyx_PyObject_CallMethO(func, arg);
#if CYTHON_FAST_PYCCALL
        } else if (PyCFunction_GET_FLAGS(func) & METH_FASTCALL) {
            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
#endif
        }
    }
    return __Pyx__PyObject_CallOneArg(func, arg);
}
#else
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_Pack(1, arg);
    if (unlikely(!args)) return NULL;
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
#endif

/* BytesEquals */
      static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
#if CYTHON_COMPILING_IN_PYPY
    return PyObject_RichCompareBool(s1, s2, equals);
#else
    if (s1 == s2) {
        return (equals == Py_EQ);
    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
        const char *ps1, *ps2;
        Py_ssize_t length = PyBytes_GET_SIZE(s1);
        if (length != PyBytes_GET_SIZE(s2))
            return (equals == Py_NE);
        ps1 = PyBytes_AS_STRING(s1);
        ps2 = PyBytes_AS_STRING(s2);
        if (ps1[0] != ps2[0]) {
            return (equals == Py_NE);
        } else if (length == 1) {
            return (equals == Py_EQ);
        } else {
            int result = memcmp(ps1, ps2, (size_t)length);
            return (equals == Py_EQ) ? (result == 0) : (result != 0);
        }
    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
        return (equals == Py_NE);
    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
        return (equals == Py_NE);
    } else {
        int result;
        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
        if (!py_result)
            return -1;
        result = __Pyx_PyObject_IsTrue(py_result);
        Py_DECREF(py_result);
        return result;
    }
#endif
}

/* UnicodeEquals */
      static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
#if CYTHON_COMPILING_IN_PYPY
    return PyObject_RichCompareBool(s1, s2, equals);
#else
#if PY_MAJOR_VERSION < 3
    PyObject* owned_ref = NULL;
#endif
    int s1_is_unicode, s2_is_unicode;
    if (s1 == s2) {
        goto return_eq;
    }
    s1_is_unicode = PyUnicode_CheckExact(s1);
    s2_is_unicode = PyUnicode_CheckExact(s2);
#if PY_MAJOR_VERSION < 3
    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
        owned_ref = PyUnicode_FromObject(s2);
        if (unlikely(!owned_ref))
            return -1;
        s2 = owned_ref;
        s2_is_unicode = 1;
    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
        owned_ref = PyUnicode_FromObject(s1);
        if (unlikely(!owned_ref))
            return -1;
        s1 = owned_ref;
        s1_is_unicode = 1;
    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
        return __Pyx_PyBytes_Equals(s1, s2, equals);
    }
#endif
    if (s1_is_unicode & s2_is_unicode) {
        Py_ssize_t length;
        int kind;
        void *data1, *data2;
        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
            return -1;
        length = __Pyx_PyUnicode_GET_LENGTH(s1);
        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
            goto return_ne;
        }
        kind = __Pyx_PyUnicode_KIND(s1);
        if (kind != __Pyx_PyUnicode_KIND(s2)) {
            goto return_ne;
        }
        data1 = __Pyx_PyUnicode_DATA(s1);
        data2 = __Pyx_PyUnicode_DATA(s2);
        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
            goto return_ne;
        } else if (length == 1) {
            goto return_eq;
        } else {
            int result = memcmp(data1, data2, (size_t)(length * kind));
            #if PY_MAJOR_VERSION < 3
            Py_XDECREF(owned_ref);
            #endif
            return (equals == Py_EQ) ? (result == 0) : (result != 0);
        }
    } else if ((s1 == Py_None) & s2_is_unicode) {
        goto return_ne;
    } else if ((s2 == Py_None) & s1_is_unicode) {
        goto return_ne;
    } else {
        int result;
        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
        if (!py_result)
            return -1;
        result = __Pyx_PyObject_IsTrue(py_result);
        Py_DECREF(py_result);
        return result;
    }
return_eq:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(owned_ref);
    #endif
    return (equals == Py_EQ);
return_ne:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(owned_ref);
    #endif
    return (equals == Py_NE);
#endif
}

/* GetItemInt */
      static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
    PyObject *r;
    if (!j) return NULL;
    r = PyObject_GetItem(o, j);
    Py_DECREF(j);
    return r;
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              CYTHON_NCP_UNUSED int wraparound,
                                                              CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    if (wraparound & unlikely(i < 0)) i += PyList_GET_SIZE(o);
    if ((!boundscheck) || likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
        PyObject *r = PyList_GET_ITEM(o, i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              CYTHON_NCP_UNUSED int wraparound,
                                                              CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    if (wraparound & unlikely(i < 0)) i += PyTuple_GET_SIZE(o);
    if ((!boundscheck) || likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
        PyObject *r = PyTuple_GET_ITEM(o, i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
                                                     CYTHON_NCP_UNUSED int wraparound,
                                                     CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
    if (is_list || PyList_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
        if ((!boundscheck) || (likely((n >= 0) & (n < PyList_GET_SIZE(o))))) {
            PyObject *r = PyList_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    }
    else if (PyTuple_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
        if ((!boundscheck) || likely((n >= 0) & (n < PyTuple_GET_SIZE(o)))) {
            PyObject *r = PyTuple_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    } else {
        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
        if (likely(m && m->sq_item)) {
            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
                Py_ssize_t l = m->sq_length(o);
                if (likely(l >= 0)) {
                    i += l;
                } else {
                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
                        return NULL;
                    PyErr_Clear();
                }
            }
            return m->sq_item(o, i);
        }
    }
#else
    if (is_list || PySequence_Check(o)) {
        return PySequence_GetItem(o, i);
    }
#endif
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
}

/* None */
      static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname) {
    PyErr_Format(PyExc_UnboundLocalError, "local variable '%s' referenced before assignment", varname);
}

/* Import */
      static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_VERSION_HEX < 0x03030000
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                #if PY_VERSION_HEX < 0x03030000
                PyObject *py_level = PyInt_FromLong(1);
                if (!py_level)
                    goto bad;
                module = PyObject_CallFunctionObjArgs(py_import,
                    name, global_dict, empty_dict, list, py_level, NULL);
                Py_DECREF(py_level);
                #else
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                #endif
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0;
        }
        #endif
        if (!module) {
            #if PY_VERSION_HEX < 0x03030000
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
bad:
    #if PY_VERSION_HEX < 0x03030000
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

/* ImportFrom */
      static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Format(PyExc_ImportError,
        #if PY_MAJOR_VERSION < 3
            "cannot import name %.230s", PyString_AS_STRING(name));
        #else
            "cannot import name %S", name);
        #endif
    }
    return value;
}

/* PyErrExceptionMatches */
      #if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
    PyObject *exc_type = tstate->curexc_type;
    if (exc_type == err) return 1;
    if (unlikely(!exc_type)) return 0;
    return PyErr_GivenExceptionMatches(exc_type, err);
}
#endif

/* PyObjectCallNoArg */
      #if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, NULL, 0);
    }
#endif
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
            return __Pyx_PyObject_CallMethO(func, NULL);
        }
    }
    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
}
#endif

/* RaiseException */
        #if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    __Pyx_PyThreadState_declare
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    if (PyType_Check(type)) {
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
    }
    __Pyx_PyThreadState_assign
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *instance_class = NULL;
        if (value && PyExceptionInstance_Check(value)) {
            instance_class = (PyObject*) Py_TYPE(value);
            if (instance_class != type) {
                int is_subclass = PyObject_IsSubclass(instance_class, type);
                if (!is_subclass) {
                    instance_class = NULL;
                } else if (unlikely(is_subclass == -1)) {
                    goto bad;
                } else {
                    type = instance_class;
                }
            }
        }
        if (!instance_class) {
            PyObject *args;
            if (!value)
                args = PyTuple_New(0);
            else if (PyTuple_Check(value)) {
                Py_INCREF(value);
                args = value;
            } else
                args = PyTuple_Pack(1, value);
            if (!args)
                goto bad;
            owned_instance = PyObject_Call(type, args, NULL);
            Py_DECREF(args);
            if (!owned_instance)
                goto bad;
            value = owned_instance;
            if (!PyExceptionInstance_Check(value)) {
                PyErr_Format(PyExc_TypeError,
                             "calling %R should have returned an instance of "
                             "BaseException, not %R",
                             type, Py_TYPE(value));
                goto bad;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
#if PY_VERSION_HEX >= 0x03030000
    if (cause) {
#else
    if (cause && cause != Py_None) {
#endif
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
#if CYTHON_COMPILING_IN_PYPY
        PyObject *tmp_type, *tmp_value, *tmp_tb;
        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
        Py_INCREF(tb);
        PyErr_Restore(tmp_type, tmp_value, tb);
        Py_XDECREF(tmp_tb);
#else
        PyThreadState *tstate = PyThreadState_GET();
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
#endif
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

/* ArgTypeTest */
          static void __Pyx_RaiseArgumentTypeInvalid(const char* name, PyObject *obj, PyTypeObject *type) {
    PyErr_Format(PyExc_TypeError,
        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
        name, type->tp_name, Py_TYPE(obj)->tp_name);
}
static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact)
{
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (none_allowed && obj == Py_None) return 1;
    else if (exact) {
        if (likely(Py_TYPE(obj) == type)) return 1;
        #if PY_MAJOR_VERSION == 2
        else if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
        #endif
    }
    else {
        if (likely(PyObject_TypeCheck(obj, type))) return 1;
    }
    __Pyx_RaiseArgumentTypeInvalid(name, obj, type);
    return 0;
}

/* PyObjectCallMethod1 */
          static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg) {
    PyObject *method, *result = NULL;
    method = __Pyx_PyObject_GetAttrStr(obj, method_name);
    if (unlikely(!method)) goto done;
#if CYTHON_UNPACK_METHODS
    if (likely(PyMethod_Check(method))) {
        PyObject *self = PyMethod_GET_SELF(method);
        if (likely(self)) {
            PyObject *args;
            PyObject *function = PyMethod_GET_FUNCTION(method);
            #if CYTHON_FAST_PYCALL
            if (PyFunction_Check(function)) {
                PyObject *args[2] = {self, arg};
                result = __Pyx_PyFunction_FastCall(function, args, 2);
                goto done;
            }
            #endif
            #if CYTHON_FAST_PYCCALL
            if (__Pyx_PyFastCFunction_Check(function)) {
                PyObject *args[2] = {self, arg};
                result = __Pyx_PyCFunction_FastCall(function, args, 2);
                goto done;
            }
            #endif
            args = PyTuple_New(2);
            if (unlikely(!args)) goto done;
            Py_INCREF(self);
            PyTuple_SET_ITEM(args, 0, self);
            Py_INCREF(arg);
            PyTuple_SET_ITEM(args, 1, arg);
            Py_INCREF(function);
            Py_DECREF(method); method = NULL;
            result = __Pyx_PyObject_Call(function, args, NULL);
            Py_DECREF(args);
            Py_DECREF(function);
            return result;
        }
    }
#endif
    result = __Pyx_PyObject_CallOneArg(method, arg);
done:
    Py_XDECREF(method);
    return result;
}

/* append */
          static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x) {
    if (likely(PyList_CheckExact(L))) {
        if (unlikely(__Pyx_PyList_Append(L, x) < 0)) return -1;
    } else {
        PyObject* retval = __Pyx_PyObject_CallMethod1(L, __pyx_n_s_append, x);
        if (unlikely(!retval))
            return -1;
        Py_DECREF(retval);
    }
    return 0;
}

/* SwapException */
          #if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = *type;
    tstate->exc_value = *value;
    tstate->exc_traceback = *tb;
    *type = tmp_type;
    *value = tmp_value;
    *tb = tmp_tb;
}
#else
static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyErr_GetExcInfo(&tmp_type, &tmp_value, &tmp_tb);
    PyErr_SetExcInfo(*type, *value, *tb);
    *type = tmp_type;
    *value = tmp_value;
    *tb = tmp_tb;
}
#endif

/* UnicodeAsUCS4 */
          static CYTHON_INLINE Py_UCS4 __Pyx_PyUnicode_AsPy_UCS4(PyObject* x) {
   Py_ssize_t length;
   #if CYTHON_PEP393_ENABLED
   length = PyUnicode_GET_LENGTH(x);
   if (likely(length == 1)) {
       return PyUnicode_READ_CHAR(x, 0);
   }
   #else
   length = PyUnicode_GET_SIZE(x);
   if (likely(length == 1)) {
       return PyUnicode_AS_UNICODE(x)[0];
   }
   #if Py_UNICODE_SIZE == 2
   else if (PyUnicode_GET_SIZE(x) == 2) {
       Py_UCS4 high_val = PyUnicode_AS_UNICODE(x)[0];
       if (high_val >= 0xD800 && high_val <= 0xDBFF) {
           Py_UCS4 low_val = PyUnicode_AS_UNICODE(x)[1];
           if (low_val >= 0xDC00 && low_val <= 0xDFFF) {
               return 0x10000 + (((high_val & ((1<<10)-1)) << 10) | (low_val & ((1<<10)-1)));
           }
       }
   }
   #endif
   #endif
   PyErr_Format(PyExc_ValueError,
                "only single character unicode strings can be converted to Py_UCS4, "
                "got length %" CYTHON_FORMAT_SSIZE_T "d", length);
   return (Py_UCS4)-1;
}

/* object_ord */
          static long __Pyx__PyObject_Ord(PyObject* c) {
    Py_ssize_t size;
    if (PyBytes_Check(c)) {
        size = PyBytes_GET_SIZE(c);
        if (likely(size == 1)) {
            return (unsigned char) PyBytes_AS_STRING(c)[0];
        }
#if PY_MAJOR_VERSION < 3
    } else if (PyUnicode_Check(c)) {
        return (long)__Pyx_PyUnicode_AsPy_UCS4(c);
#endif
#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
    } else if (PyByteArray_Check(c)) {
        size = PyByteArray_GET_SIZE(c);
        if (likely(size == 1)) {
            return (unsigned char) PyByteArray_AS_STRING(c)[0];
        }
#endif
    } else {
        PyErr_Format(PyExc_TypeError,
            "ord() expected string of length 1, but %.200s found", c->ob_type->tp_name);
        return (long)(Py_UCS4)-1;
    }
    PyErr_Format(PyExc_TypeError,
        "ord() expected a character, but string of length %zd found", size);
    return (long)(Py_UCS4)-1;
}

/* PyIntBinop */
          #if !CYTHON_COMPILING_IN_PYPY
static PyObject* __Pyx_PyInt_EqObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED int inplace) {
    if (op1 == op2) {
        Py_RETURN_TRUE;
    }
    #if PY_MAJOR_VERSION < 3
    if (likely(PyInt_CheckExact(op1))) {
        const long b = intval;
        long a = PyInt_AS_LONG(op1);
        if (a == b) {
            Py_RETURN_TRUE;
        } else {
            Py_RETURN_FALSE;
        }
    }
    #endif
    #if CYTHON_USE_PYLONG_INTERNALS
    if (likely(PyLong_CheckExact(op1))) {
        const long b = intval;
        long a;
        const digit* digits = ((PyLongObject*)op1)->ob_digit;
        const Py_ssize_t size = Py_SIZE(op1);
        if (likely(__Pyx_sst_abs(size) <= 1)) {
            a = likely(size) ? digits[0] : 0;
            if (size == -1) a = -a;
        } else {
            switch (size) {
                case -2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    }
                case 2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = (long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    }
                case -3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    }
                case 3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = (long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    }
                case -4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    }
                case 4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = (long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    }
                #if PyLong_SHIFT < 30 && PyLong_SHIFT != 15
                default: return PyLong_Type.tp_richcompare(op1, op2, Py_EQ);
                #else
                default: Py_RETURN_FALSE;
                #endif
            }
        }
            if (a == b) {
                Py_RETURN_TRUE;
            } else {
                Py_RETURN_FALSE;
            }
    }
    #endif
    if (PyFloat_CheckExact(op1)) {
        const long b = intval;
        double a = PyFloat_AS_DOUBLE(op1);
            if ((double)a == (double)b) {
                Py_RETURN_TRUE;
            } else {
                Py_RETURN_FALSE;
            }
    }
    return PyObject_RichCompare(op1, op2, Py_EQ);
}
#endif

/* PyIntBinop */
          #if !CYTHON_COMPILING_IN_PYPY
static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED int inplace) {
    #if PY_MAJOR_VERSION < 3
    if (likely(PyInt_CheckExact(op1))) {
        const long b = intval;
        long x;
        long a = PyInt_AS_LONG(op1);
            x = (long)((unsigned long)a + b);
            if (likely((x^a) >= 0 || (x^b) >= 0))
                return PyInt_FromLong(x);
            return PyLong_Type.tp_as_number->nb_add(op1, op2);
    }
    #endif
    #if CYTHON_USE_PYLONG_INTERNALS
    if (likely(PyLong_CheckExact(op1))) {
        const long b = intval;
        long a, x;
#ifdef HAVE_LONG_LONG
        const PY_LONG_LONG llb = intval;
        PY_LONG_LONG lla, llx;
#endif
        const digit* digits = ((PyLongObject*)op1)->ob_digit;
        const Py_ssize_t size = Py_SIZE(op1);
        if (likely(__Pyx_sst_abs(size) <= 1)) {
            a = likely(size) ? digits[0] : 0;
            if (size == -1) a = -a;
        } else {
            switch (size) {
                case -2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                case 2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = (long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                case -3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                case 3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = (long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                case -4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                case 4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = (long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                default: return PyLong_Type.tp_as_number->nb_add(op1, op2);
            }
        }
                x = a + b;
            return PyLong_FromLong(x);
#ifdef HAVE_LONG_LONG
        long_long:
                llx = lla + llb;
            return PyLong_FromLongLong(llx);
#endif
        
        
    }
    #endif
    if (PyFloat_CheckExact(op1)) {
        const long b = intval;
        double a = PyFloat_AS_DOUBLE(op1);
            double result;
            PyFPE_START_PROTECT("add", return NULL)
            result = ((double)a) + (double)b;
            PyFPE_END_PROTECT(result)
            return PyFloat_FromDouble(result);
    }
    return (inplace ? PyNumber_InPlaceAdd : PyNumber_Add)(op1, op2);
}
#endif

/* CalculateMetaclass */
          static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases) {
    Py_ssize_t i, nbases = PyTuple_GET_SIZE(bases);
    for (i=0; i < nbases; i++) {
        PyTypeObject *tmptype;
        PyObject *tmp = PyTuple_GET_ITEM(bases, i);
        tmptype = Py_TYPE(tmp);
#if PY_MAJOR_VERSION < 3
        if (tmptype == &PyClass_Type)
            continue;
#endif
        if (!metaclass) {
            metaclass = tmptype;
            continue;
        }
        if (PyType_IsSubtype(metaclass, tmptype))
            continue;
        if (PyType_IsSubtype(tmptype, metaclass)) {
            metaclass = tmptype;
            continue;
        }
        PyErr_SetString(PyExc_TypeError,
                        "metaclass conflict: "
                        "the metaclass of a derived class "
                        "must be a (non-strict) subclass "
                        "of the metaclasses of all its bases");
        return NULL;
    }
    if (!metaclass) {
#if PY_MAJOR_VERSION < 3
        metaclass = &PyClass_Type;
#else
        metaclass = &PyType_Type;
#endif
    }
    Py_INCREF((PyObject*) metaclass);
    return (PyObject*) metaclass;
}

/* FetchCommonType */
          static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
    PyObject* fake_module;
    PyTypeObject* cached_type = NULL;
    fake_module = PyImport_AddModule((char*) "_cython_" CYTHON_ABI);
    if (!fake_module) return NULL;
    Py_INCREF(fake_module);
    cached_type = (PyTypeObject*) PyObject_GetAttrString(fake_module, type->tp_name);
    if (cached_type) {
        if (!PyType_Check((PyObject*)cached_type)) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s is not a type object",
                type->tp_name);
            goto bad;
        }
        if (cached_type->tp_basicsize != type->tp_basicsize) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s has the wrong size, try recompiling",
                type->tp_name);
            goto bad;
        }
    } else {
        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
        PyErr_Clear();
        if (PyType_Ready(type) < 0) goto bad;
        if (PyObject_SetAttrString(fake_module, type->tp_name, (PyObject*) type) < 0)
            goto bad;
        Py_INCREF(type);
        cached_type = type;
    }
done:
    Py_DECREF(fake_module);
    return cached_type;
bad:
    Py_XDECREF(cached_type);
    cached_type = NULL;
    goto done;
}

/* CythonFunction */
          static PyObject *
__Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *closure)
{
    if (unlikely(op->func_doc == NULL)) {
        if (op->func.m_ml->ml_doc) {
#if PY_MAJOR_VERSION >= 3
            op->func_doc = PyUnicode_FromString(op->func.m_ml->ml_doc);
#else
            op->func_doc = PyString_FromString(op->func.m_ml->ml_doc);
#endif
            if (unlikely(op->func_doc == NULL))
                return NULL;
        } else {
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    Py_INCREF(op->func_doc);
    return op->func_doc;
}
static int
__Pyx_CyFunction_set_doc(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp = op->func_doc;
    if (value == NULL) {
        value = Py_None;
    }
    Py_INCREF(value);
    op->func_doc = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_name(__pyx_CyFunctionObject *op)
{
    if (unlikely(op->func_name == NULL)) {
#if PY_MAJOR_VERSION >= 3
        op->func_name = PyUnicode_InternFromString(op->func.m_ml->ml_name);
#else
        op->func_name = PyString_InternFromString(op->func.m_ml->ml_name);
#endif
        if (unlikely(op->func_name == NULL))
            return NULL;
    }
    Py_INCREF(op->func_name);
    return op->func_name;
}
static int
__Pyx_CyFunction_set_name(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__name__ must be set to a string object");
        return -1;
    }
    tmp = op->func_name;
    Py_INCREF(value);
    op->func_name = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_qualname(__pyx_CyFunctionObject *op)
{
    Py_INCREF(op->func_qualname);
    return op->func_qualname;
}
static int
__Pyx_CyFunction_set_qualname(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__qualname__ must be set to a string object");
        return -1;
    }
    tmp = op->func_qualname;
    Py_INCREF(value);
    op->func_qualname = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_self(__pyx_CyFunctionObject *m, CYTHON_UNUSED void *closure)
{
    PyObject *self;
    self = m->func_closure;
    if (self == NULL)
        self = Py_None;
    Py_INCREF(self);
    return self;
}
static PyObject *
__Pyx_CyFunction_get_dict(__pyx_CyFunctionObject *op)
{
    if (unlikely(op->func_dict == NULL)) {
        op->func_dict = PyDict_New();
        if (unlikely(op->func_dict == NULL))
            return NULL;
    }
    Py_INCREF(op->func_dict);
    return op->func_dict;
}
static int
__Pyx_CyFunction_set_dict(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
    if (unlikely(value == NULL)) {
        PyErr_SetString(PyExc_TypeError,
               "function's dictionary may not be deleted");
        return -1;
    }
    if (unlikely(!PyDict_Check(value))) {
        PyErr_SetString(PyExc_TypeError,
               "setting function's dictionary to a non-dict");
        return -1;
    }
    tmp = op->func_dict;
    Py_INCREF(value);
    op->func_dict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_globals(__pyx_CyFunctionObject *op)
{
    Py_INCREF(op->func_globals);
    return op->func_globals;
}
static PyObject *
__Pyx_CyFunction_get_closure(CYTHON_UNUSED __pyx_CyFunctionObject *op)
{
    Py_INCREF(Py_None);
    return Py_None;
}
static PyObject *
__Pyx_CyFunction_get_code(__pyx_CyFunctionObject *op)
{
    PyObject* result = (op->func_code) ? op->func_code : Py_None;
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_init_defaults(__pyx_CyFunctionObject *op) {
    int result = 0;
    PyObject *res = op->defaults_getter((PyObject *) op);
    if (unlikely(!res))
        return -1;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
    Py_INCREF(op->defaults_tuple);
    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
    Py_INCREF(op->defaults_kwdict);
    #else
    op->defaults_tuple = PySequence_ITEM(res, 0);
    if (unlikely(!op->defaults_tuple)) result = -1;
    else {
        op->defaults_kwdict = PySequence_ITEM(res, 1);
        if (unlikely(!op->defaults_kwdict)) result = -1;
    }
    #endif
    Py_DECREF(res);
    return result;
}
static int
__Pyx_CyFunction_set_defaults(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyTuple_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__defaults__ must be set to a tuple object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_tuple;
    op->defaults_tuple = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_defaults(__pyx_CyFunctionObject *op) {
    PyObject* result = op->defaults_tuple;
    if (unlikely(!result)) {
        if (op->defaults_getter) {
            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_tuple;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_set_kwdefaults(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__kwdefaults__ must be set to a dict object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_kwdict;
    op->defaults_kwdict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_kwdefaults(__pyx_CyFunctionObject *op) {
    PyObject* result = op->defaults_kwdict;
    if (unlikely(!result)) {
        if (op->defaults_getter) {
            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_kwdict;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_set_annotations(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value || value == Py_None) {
        value = NULL;
    } else if (!PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__annotations__ must be set to a dict object");
        return -1;
    }
    Py_XINCREF(value);
    tmp = op->func_annotations;
    op->func_annotations = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_annotations(__pyx_CyFunctionObject *op) {
    PyObject* result = op->func_annotations;
    if (unlikely(!result)) {
        result = PyDict_New();
        if (unlikely(!result)) return NULL;
        op->func_annotations = result;
    }
    Py_INCREF(result);
    return result;
}
static PyGetSetDef __pyx_CyFunction_getsets[] = {
    {(char *) "func_doc", (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
    {(char *) "__doc__",  (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
    {(char *) "func_name", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
    {(char *) "__name__", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
    {(char *) "__qualname__", (getter)__Pyx_CyFunction_get_qualname, (setter)__Pyx_CyFunction_set_qualname, 0, 0},
    {(char *) "__self__", (getter)__Pyx_CyFunction_get_self, 0, 0, 0},
    {(char *) "func_dict", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
    {(char *) "__dict__", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
    {(char *) "func_globals", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
    {(char *) "__globals__", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
    {(char *) "func_closure", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
    {(char *) "__closure__", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
    {(char *) "func_code", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
    {(char *) "__code__", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
    {(char *) "func_defaults", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
    {(char *) "__defaults__", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
    {(char *) "__kwdefaults__", (getter)__Pyx_CyFunction_get_kwdefaults, (setter)__Pyx_CyFunction_set_kwdefaults, 0, 0},
    {(char *) "__annotations__", (getter)__Pyx_CyFunction_get_annotations, (setter)__Pyx_CyFunction_set_annotations, 0, 0},
    {0, 0, 0, 0, 0}
};
static PyMemberDef __pyx_CyFunction_members[] = {
    {(char *) "__module__", T_OBJECT, offsetof(__pyx_CyFunctionObject, func.m_module), PY_WRITE_RESTRICTED, 0},
    {0, 0, 0,  0, 0}
};
static PyObject *
__Pyx_CyFunction_reduce(__pyx_CyFunctionObject *m, CYTHON_UNUSED PyObject *args)
{
#if PY_MAJOR_VERSION >= 3
    return PyUnicode_FromString(m->func.m_ml->ml_name);
#else
    return PyString_FromString(m->func.m_ml->ml_name);
#endif
}
static PyMethodDef __pyx_CyFunction_methods[] = {
    {"__reduce__", (PyCFunction)__Pyx_CyFunction_reduce, METH_VARARGS, 0},
    {0, 0, 0, 0}
};
#if PY_VERSION_HEX < 0x030500A0
#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
#else
#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func.m_weakreflist)
#endif
static PyObject *__Pyx_CyFunction_New(PyTypeObject *type, PyMethodDef *ml, int flags, PyObject* qualname,
                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
    __pyx_CyFunctionObject *op = PyObject_GC_New(__pyx_CyFunctionObject, type);
    if (op == NULL)
        return NULL;
    op->flags = flags;
    __Pyx_CyFunction_weakreflist(op) = NULL;
    op->func.m_ml = ml;
    op->func.m_self = (PyObject *) op;
    Py_XINCREF(closure);
    op->func_closure = closure;
    Py_XINCREF(module);
    op->func.m_module = module;
    op->func_dict = NULL;
    op->func_name = NULL;
    Py_INCREF(qualname);
    op->func_qualname = qualname;
    op->func_doc = NULL;
    op->func_classobj = NULL;
    op->func_globals = globals;
    Py_INCREF(op->func_globals);
    Py_XINCREF(code);
    op->func_code = code;
    op->defaults_pyobjects = 0;
    op->defaults = NULL;
    op->defaults_tuple = NULL;
    op->defaults_kwdict = NULL;
    op->defaults_getter = NULL;
    op->func_annotations = NULL;
    PyObject_GC_Track(op);
    return (PyObject *) op;
}
static int
__Pyx_CyFunction_clear(__pyx_CyFunctionObject *m)
{
    Py_CLEAR(m->func_closure);
    Py_CLEAR(m->func.m_module);
    Py_CLEAR(m->func_dict);
    Py_CLEAR(m->func_name);
    Py_CLEAR(m->func_qualname);
    Py_CLEAR(m->func_doc);
    Py_CLEAR(m->func_globals);
    Py_CLEAR(m->func_code);
    Py_CLEAR(m->func_classobj);
    Py_CLEAR(m->defaults_tuple);
    Py_CLEAR(m->defaults_kwdict);
    Py_CLEAR(m->func_annotations);
    if (m->defaults) {
        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_XDECREF(pydefaults[i]);
        PyObject_Free(m->defaults);
        m->defaults = NULL;
    }
    return 0;
}
static void __Pyx_CyFunction_dealloc(__pyx_CyFunctionObject *m)
{
    PyObject_GC_UnTrack(m);
    if (__Pyx_CyFunction_weakreflist(m) != NULL)
        PyObject_ClearWeakRefs((PyObject *) m);
    __Pyx_CyFunction_clear(m);
    PyObject_GC_Del(m);
}
static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)
{
    Py_VISIT(m->func_closure);
    Py_VISIT(m->func.m_module);
    Py_VISIT(m->func_dict);
    Py_VISIT(m->func_name);
    Py_VISIT(m->func_qualname);
    Py_VISIT(m->func_doc);
    Py_VISIT(m->func_globals);
    Py_VISIT(m->func_code);
    Py_VISIT(m->func_classobj);
    Py_VISIT(m->defaults_tuple);
    Py_VISIT(m->defaults_kwdict);
    if (m->defaults) {
        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_VISIT(pydefaults[i]);
    }
    return 0;
}
static PyObject *__Pyx_CyFunction_descr_get(PyObject *func, PyObject *obj, PyObject *type)
{
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    if (m->flags & __Pyx_CYFUNCTION_STATICMETHOD) {
        Py_INCREF(func);
        return func;
    }
    if (m->flags & __Pyx_CYFUNCTION_CLASSMETHOD) {
        if (type == NULL)
            type = (PyObject *)(Py_TYPE(obj));
        return __Pyx_PyMethod_New(func, type, (PyObject *)(Py_TYPE(type)));
    }
    if (obj == Py_None)
        obj = NULL;
    return __Pyx_PyMethod_New(func, obj, type);
}
static PyObject*
__Pyx_CyFunction_repr(__pyx_CyFunctionObject *op)
{
#if PY_MAJOR_VERSION >= 3
    return PyUnicode_FromFormat("<cyfunction %U at %p>",
                                op->func_qualname, (void *)op);
#else
    return PyString_FromFormat("<cyfunction %s at %p>",
                               PyString_AsString(op->func_qualname), (void *)op);
#endif
}
static PyObject * __Pyx_CyFunction_CallMethod(PyObject *func, PyObject *self, PyObject *arg, PyObject *kw) {
    PyCFunctionObject* f = (PyCFunctionObject*)func;
    PyCFunction meth = f->m_ml->ml_meth;
    Py_ssize_t size;
    switch (f->m_ml->ml_flags & (METH_VARARGS | METH_KEYWORDS | METH_NOARGS | METH_O)) {
    case METH_VARARGS:
        if (likely(kw == NULL || PyDict_Size(kw) == 0))
            return (*meth)(self, arg);
        break;
    case METH_VARARGS | METH_KEYWORDS:
        return (*(PyCFunctionWithKeywords)meth)(self, arg, kw);
    case METH_NOARGS:
        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
            size = PyTuple_GET_SIZE(arg);
            if (likely(size == 0))
                return (*meth)(self, NULL);
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
                f->m_ml->ml_name, size);
            return NULL;
        }
        break;
    case METH_O:
        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
            size = PyTuple_GET_SIZE(arg);
            if (likely(size == 1)) {
                PyObject *result, *arg0 = PySequence_ITEM(arg, 0);
                if (unlikely(!arg0)) return NULL;
                result = (*meth)(self, arg0);
                Py_DECREF(arg0);
                return result;
            }
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
                f->m_ml->ml_name, size);
            return NULL;
        }
        break;
    default:
        PyErr_SetString(PyExc_SystemError, "Bad call flags in "
                        "__Pyx_CyFunction_Call. METH_OLDARGS is no "
                        "longer supported!");
        return NULL;
    }
    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
                 f->m_ml->ml_name);
    return NULL;
}
static CYTHON_INLINE PyObject *__Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    return __Pyx_CyFunction_CallMethod(func, ((PyCFunctionObject*)func)->m_self, arg, kw);
}
static PyObject *__Pyx_CyFunction_CallAsMethod(PyObject *func, PyObject *args, PyObject *kw) {
    PyObject *result;
    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *) func;
    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
        Py_ssize_t argc;
        PyObject *new_args;
        PyObject *self;
        argc = PyTuple_GET_SIZE(args);
        new_args = PyTuple_GetSlice(args, 1, argc);
        if (unlikely(!new_args))
            return NULL;
        self = PyTuple_GetItem(args, 0);
        if (unlikely(!self)) {
            Py_DECREF(new_args);
            return NULL;
        }
        result = __Pyx_CyFunction_CallMethod(func, self, new_args, kw);
        Py_DECREF(new_args);
    } else {
        result = __Pyx_CyFunction_Call(func, args, kw);
    }
    return result;
}
static PyTypeObject __pyx_CyFunctionType_type = {
    PyVarObject_HEAD_INIT(0, 0)
    "cython_function_or_method",
    sizeof(__pyx_CyFunctionObject),
    0,
    (destructor) __Pyx_CyFunction_dealloc,
    0,
    0,
    0,
#if PY_MAJOR_VERSION < 3
    0,
#else
    0,
#endif
    (reprfunc) __Pyx_CyFunction_repr,
    0,
    0,
    0,
    0,
    __Pyx_CyFunction_CallAsMethod,
    0,
    0,
    0,
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
    0,
    (traverseproc) __Pyx_CyFunction_traverse,
    (inquiry) __Pyx_CyFunction_clear,
    0,
#if PY_VERSION_HEX < 0x030500A0
    offsetof(__pyx_CyFunctionObject, func_weakreflist),
#else
    offsetof(PyCFunctionObject, m_weakreflist),
#endif
    0,
    0,
    __pyx_CyFunction_methods,
    __pyx_CyFunction_members,
    __pyx_CyFunction_getsets,
    0,
    0,
    __Pyx_CyFunction_descr_get,
    0,
    offsetof(__pyx_CyFunctionObject, func_dict),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
#if PY_VERSION_HEX >= 0x030400a1
    0,
#endif
};
static int __pyx_CyFunction_init(void) {
    __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
    if (__pyx_CyFunctionType == NULL) {
        return -1;
    }
    return 0;
}
static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *func, size_t size, int pyobjects) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults = PyObject_Malloc(size);
    if (!m->defaults)
        return PyErr_NoMemory();
    memset(m->defaults, 0, size);
    m->defaults_pyobjects = pyobjects;
    return m->defaults;
}
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *func, PyObject *tuple) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults_tuple = tuple;
    Py_INCREF(tuple);
}
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *func, PyObject *dict) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults_kwdict = dict;
    Py_INCREF(dict);
}
static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->func_annotations = dict;
    Py_INCREF(dict);
}

/* Py3ClassCreate */
              static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name,
                                           PyObject *qualname, PyObject *mkw, PyObject *modname, PyObject *doc) {
    PyObject *ns;
    if (metaclass) {
        PyObject *prep = __Pyx_PyObject_GetAttrStr(metaclass, __pyx_n_s_prepare);
        if (prep) {
            PyObject *pargs = PyTuple_Pack(2, name, bases);
            if (unlikely(!pargs)) {
                Py_DECREF(prep);
                return NULL;
            }
            ns = PyObject_Call(prep, pargs, mkw);
            Py_DECREF(prep);
            Py_DECREF(pargs);
        } else {
            if (unlikely(!PyErr_ExceptionMatches(PyExc_AttributeError)))
                return NULL;
            PyErr_Clear();
            ns = PyDict_New();
        }
    } else {
        ns = PyDict_New();
    }
    if (unlikely(!ns))
        return NULL;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_module, modname) < 0)) goto bad;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_qualname, qualname) < 0)) goto bad;
    if (unlikely(doc && PyObject_SetItem(ns, __pyx_n_s_doc_2, doc) < 0)) goto bad;
    return ns;
bad:
    Py_DECREF(ns);
    return NULL;
}
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases,
                                      PyObject *dict, PyObject *mkw,
                                      int calculate_metaclass, int allow_py2_metaclass) {
    PyObject *result, *margs;
    PyObject *owned_metaclass = NULL;
    if (allow_py2_metaclass) {
        owned_metaclass = PyObject_GetItem(dict, __pyx_n_s_metaclass);
        if (owned_metaclass) {
            metaclass = owned_metaclass;
        } else if (likely(PyErr_ExceptionMatches(PyExc_KeyError))) {
            PyErr_Clear();
        } else {
            return NULL;
        }
    }
    if (calculate_metaclass && (!metaclass || PyType_Check(metaclass))) {
        metaclass = __Pyx_CalculateMetaclass((PyTypeObject*) metaclass, bases);
        Py_XDECREF(owned_metaclass);
        if (unlikely(!metaclass))
            return NULL;
        owned_metaclass = metaclass;
    }
    margs = PyTuple_Pack(3, name, bases, dict);
    if (unlikely(!margs)) {
        result = NULL;
    } else {
        result = PyObject_Call(metaclass, margs, mkw);
        Py_DECREF(margs);
    }
    Py_XDECREF(owned_metaclass);
    return result;
}

/* CodeObjectCache */
              static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = start + (end - start) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, (size_t)new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

/* AddTraceback */
              #include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        __pyx_d,      /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

/* CIntFromPyVerify */
              #define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
#define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
#define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
    {\
        func_type value = func_value;\
        if (sizeof(target_type) < sizeof(func_type)) {\
            if (unlikely(value != (func_type) (target_type) value)) {\
                func_type zero = 0;\
                if (exc && unlikely(value == (func_type)-1 && PyErr_Occurred()))\
                    return (target_type) -1;\
                if (is_unsigned && unlikely(value < zero))\
                    goto raise_neg_overflow;\
                else\
                    goto raise_overflow;\
            }\
        }\
        return (target_type) value;\
    }

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueType(enum OpenZWave::ValueID::ValueType value) {
    const enum OpenZWave::ValueID::ValueType neg_one = (enum OpenZWave::ValueID::ValueType) -1, const_zero = (enum OpenZWave::ValueID::ValueType) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum OpenZWave::ValueID::ValueType) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum OpenZWave::ValueID::ValueType) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum OpenZWave::ValueID::ValueType) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(enum OpenZWave::ValueID::ValueType) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum OpenZWave::ValueID::ValueType) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum OpenZWave::ValueID::ValueType),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint8_t(uint8_t value) {
    const uint8_t neg_one = (uint8_t) -1, const_zero = (uint8_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(uint8_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(uint8_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(uint8_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(uint8_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(uint8_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(uint8_t),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int32_t(int32_t value) {
    const int32_t neg_one = (int32_t) -1, const_zero = (int32_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int32_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int32_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int32_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(int32_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int32_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int32_t),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int16_t(int16_t value) {
    const int16_t neg_one = (int16_t) -1, const_zero = (int16_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int16_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int16_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int16_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(int16_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int16_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int16_t),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint64_t(uint64_t value) {
    const uint64_t neg_one = (uint64_t) -1, const_zero = (uint64_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(uint64_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(uint64_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(uint64_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(uint64_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(uint64_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(uint64_t),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__OpenZWave_3a__3a_ValueID_3a__3a_ValueGenre(enum OpenZWave::ValueID::ValueGenre value) {
    const enum OpenZWave::ValueID::ValueGenre neg_one = (enum OpenZWave::ValueID::ValueGenre) -1, const_zero = (enum OpenZWave::ValueID::ValueGenre) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum OpenZWave::ValueID::ValueGenre) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum OpenZWave::ValueID::ValueGenre) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum OpenZWave::ValueID::ValueGenre) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(enum OpenZWave::ValueID::ValueGenre) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum OpenZWave::ValueID::ValueGenre) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum OpenZWave::ValueID::ValueGenre),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint32_t(uint32_t value) {
    const uint32_t neg_one = (uint32_t) -1, const_zero = (uint32_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(uint32_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(uint32_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(uint32_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(uint32_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(uint32_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(uint32_t),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Notification_3a__3a_NotificationType(enum OpenZWave::Notification::NotificationType value) {
    const enum OpenZWave::Notification::NotificationType neg_one = (enum OpenZWave::Notification::NotificationType) -1, const_zero = (enum OpenZWave::Notification::NotificationType) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum OpenZWave::Notification::NotificationType) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum OpenZWave::Notification::NotificationType) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum OpenZWave::Notification::NotificationType) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(enum OpenZWave::Notification::NotificationType) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum OpenZWave::Notification::NotificationType) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum OpenZWave::Notification::NotificationType),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerState(enum OpenZWave::Driver::ControllerState value) {
    const enum OpenZWave::Driver::ControllerState neg_one = (enum OpenZWave::Driver::ControllerState) -1, const_zero = (enum OpenZWave::Driver::ControllerState) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum OpenZWave::Driver::ControllerState) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum OpenZWave::Driver::ControllerState) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum OpenZWave::Driver::ControllerState) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(enum OpenZWave::Driver::ControllerState) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum OpenZWave::Driver::ControllerState) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum OpenZWave::Driver::ControllerState),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerError(enum OpenZWave::Driver::ControllerError value) {
    const enum OpenZWave::Driver::ControllerError neg_one = (enum OpenZWave::Driver::ControllerError) -1, const_zero = (enum OpenZWave::Driver::ControllerError) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum OpenZWave::Driver::ControllerError) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum OpenZWave::Driver::ControllerError) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum OpenZWave::Driver::ControllerError) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(enum OpenZWave::Driver::ControllerError) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum OpenZWave::Driver::ControllerError) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum OpenZWave::Driver::ControllerError),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerInterface(enum OpenZWave::Driver::ControllerInterface value) {
    const enum OpenZWave::Driver::ControllerInterface neg_one = (enum OpenZWave::Driver::ControllerInterface) -1, const_zero = (enum OpenZWave::Driver::ControllerInterface) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum OpenZWave::Driver::ControllerInterface) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum OpenZWave::Driver::ControllerInterface) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum OpenZWave::Driver::ControllerInterface) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(enum OpenZWave::Driver::ControllerInterface) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum OpenZWave::Driver::ControllerInterface) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum OpenZWave::Driver::ControllerInterface),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint16_t(uint16_t value) {
    const uint16_t neg_one = (uint16_t) -1, const_zero = (uint16_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(uint16_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(uint16_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(uint16_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(uint16_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(uint16_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(uint16_t),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
    const long neg_one = (long) -1, const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int8_t(int8_t value) {
    const int8_t neg_one = (int8_t) -1, const_zero = (int8_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int8_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int8_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int8_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(int8_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int8_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int8_t),
                                     little, !is_unsigned);
    }
}

/* CIntFromPy */
              static CYTHON_INLINE uint32_t __Pyx_PyInt_As_uint32_t(PyObject *x) {
    const uint32_t neg_one = (uint32_t) -1, const_zero = (uint32_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(uint32_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(uint32_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (uint32_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (uint32_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(uint32_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(uint32_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) >= 2 * PyLong_SHIFT) {
                            return (uint32_t) (((((uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(uint32_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) >= 3 * PyLong_SHIFT) {
                            return (uint32_t) (((((((uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(uint32_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) >= 4 * PyLong_SHIFT) {
                            return (uint32_t) (((((((((uint32_t)digits[3]) << PyLong_SHIFT) | (uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (uint32_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(uint32_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint32_t, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(uint32_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint32_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (uint32_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(uint32_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(uint32_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(uint32_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 2 * PyLong_SHIFT) {
                            return (uint32_t) (((uint32_t)-1)*(((((uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(uint32_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 2 * PyLong_SHIFT) {
                            return (uint32_t) ((((((uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(uint32_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 3 * PyLong_SHIFT) {
                            return (uint32_t) (((uint32_t)-1)*(((((((uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(uint32_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 3 * PyLong_SHIFT) {
                            return (uint32_t) ((((((((uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(uint32_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 4 * PyLong_SHIFT) {
                            return (uint32_t) (((uint32_t)-1)*(((((((((uint32_t)digits[3]) << PyLong_SHIFT) | (uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(uint32_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 4 * PyLong_SHIFT) {
                            return (uint32_t) ((((((((((uint32_t)digits[3]) << PyLong_SHIFT) | (uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(uint32_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint32_t, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(uint32_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint32_t, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            uint32_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (uint32_t) -1;
        }
    } else {
        uint32_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (uint32_t) -1;
        val = __Pyx_PyInt_As_uint32_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to uint32_t");
    return (uint32_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to uint32_t");
    return (uint32_t) -1;
}

/* CIntFromPy */
              static CYTHON_INLINE uint8_t __Pyx_PyInt_As_uint8_t(PyObject *x) {
    const uint8_t neg_one = (uint8_t) -1, const_zero = (uint8_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(uint8_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(uint8_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (uint8_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (uint8_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(uint8_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(uint8_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint8_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint8_t) >= 2 * PyLong_SHIFT) {
                            return (uint8_t) (((((uint8_t)digits[1]) << PyLong_SHIFT) | (uint8_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(uint8_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint8_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint8_t) >= 3 * PyLong_SHIFT) {
                            return (uint8_t) (((((((uint8_t)digits[2]) << PyLong_SHIFT) | (uint8_t)digits[1]) << PyLong_SHIFT) | (uint8_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(uint8_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint8_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint8_t) >= 4 * PyLong_SHIFT) {
                            return (uint8_t) (((((((((uint8_t)digits[3]) << PyLong_SHIFT) | (uint8_t)digits[2]) << PyLong_SHIFT) | (uint8_t)digits[1]) << PyLong_SHIFT) | (uint8_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (uint8_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(uint8_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint8_t, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(uint8_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint8_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (uint8_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(uint8_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(uint8_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(uint8_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint8_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint8_t) - 1 > 2 * PyLong_SHIFT) {
                            return (uint8_t) (((uint8_t)-1)*(((((uint8_t)digits[1]) << PyLong_SHIFT) | (uint8_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(uint8_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint8_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint8_t) - 1 > 2 * PyLong_SHIFT) {
                            return (uint8_t) ((((((uint8_t)digits[1]) << PyLong_SHIFT) | (uint8_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(uint8_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint8_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint8_t) - 1 > 3 * PyLong_SHIFT) {
                            return (uint8_t) (((uint8_t)-1)*(((((((uint8_t)digits[2]) << PyLong_SHIFT) | (uint8_t)digits[1]) << PyLong_SHIFT) | (uint8_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(uint8_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint8_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint8_t) - 1 > 3 * PyLong_SHIFT) {
                            return (uint8_t) ((((((((uint8_t)digits[2]) << PyLong_SHIFT) | (uint8_t)digits[1]) << PyLong_SHIFT) | (uint8_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(uint8_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint8_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint8_t) - 1 > 4 * PyLong_SHIFT) {
                            return (uint8_t) (((uint8_t)-1)*(((((((((uint8_t)digits[3]) << PyLong_SHIFT) | (uint8_t)digits[2]) << PyLong_SHIFT) | (uint8_t)digits[1]) << PyLong_SHIFT) | (uint8_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(uint8_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint8_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint8_t) - 1 > 4 * PyLong_SHIFT) {
                            return (uint8_t) ((((((((((uint8_t)digits[3]) << PyLong_SHIFT) | (uint8_t)digits[2]) << PyLong_SHIFT) | (uint8_t)digits[1]) << PyLong_SHIFT) | (uint8_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(uint8_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint8_t, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(uint8_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint8_t, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            uint8_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (uint8_t) -1;
        }
    } else {
        uint8_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (uint8_t) -1;
        val = __Pyx_PyInt_As_uint8_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to uint8_t");
    return (uint8_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to uint8_t");
    return (uint8_t) -1;
}

/* CIntFromPy */
              static CYTHON_INLINE uint64_t __Pyx_PyInt_As_uint64_t(PyObject *x) {
    const uint64_t neg_one = (uint64_t) -1, const_zero = (uint64_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(uint64_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(uint64_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (uint64_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (uint64_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(uint64_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(uint64_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) >= 2 * PyLong_SHIFT) {
                            return (uint64_t) (((((uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(uint64_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) >= 3 * PyLong_SHIFT) {
                            return (uint64_t) (((((((uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(uint64_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) >= 4 * PyLong_SHIFT) {
                            return (uint64_t) (((((((((uint64_t)digits[3]) << PyLong_SHIFT) | (uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (uint64_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(uint64_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint64_t, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(uint64_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint64_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (uint64_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(uint64_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(uint64_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(uint64_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 2 * PyLong_SHIFT) {
                            return (uint64_t) (((uint64_t)-1)*(((((uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(uint64_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 2 * PyLong_SHIFT) {
                            return (uint64_t) ((((((uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(uint64_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 3 * PyLong_SHIFT) {
                            return (uint64_t) (((uint64_t)-1)*(((((((uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(uint64_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 3 * PyLong_SHIFT) {
                            return (uint64_t) ((((((((uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(uint64_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 4 * PyLong_SHIFT) {
                            return (uint64_t) (((uint64_t)-1)*(((((((((uint64_t)digits[3]) << PyLong_SHIFT) | (uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(uint64_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 4 * PyLong_SHIFT) {
                            return (uint64_t) ((((((((((uint64_t)digits[3]) << PyLong_SHIFT) | (uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(uint64_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint64_t, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(uint64_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint64_t, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            uint64_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (uint64_t) -1;
        }
    } else {
        uint64_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (uint64_t) -1;
        val = __Pyx_PyInt_As_uint64_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to uint64_t");
    return (uint64_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to uint64_t");
    return (uint64_t) -1;
}

/* CIntFromPy */
              static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
    const long neg_one = (long) -1, const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (long) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

/* CIntFromPy */
              static CYTHON_INLINE int32_t __Pyx_PyInt_As_int32_t(PyObject *x) {
    const int32_t neg_one = (int32_t) -1, const_zero = (int32_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int32_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int32_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int32_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int32_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int32_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(int32_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) >= 2 * PyLong_SHIFT) {
                            return (int32_t) (((((int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int32_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) >= 3 * PyLong_SHIFT) {
                            return (int32_t) (((((((int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int32_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) >= 4 * PyLong_SHIFT) {
                            return (int32_t) (((((((((int32_t)digits[3]) << PyLong_SHIFT) | (int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int32_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int32_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int32_t, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int32_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int32_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int32_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int32_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int32_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int32_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 2 * PyLong_SHIFT) {
                            return (int32_t) (((int32_t)-1)*(((((int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int32_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 2 * PyLong_SHIFT) {
                            return (int32_t) ((((((int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int32_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 3 * PyLong_SHIFT) {
                            return (int32_t) (((int32_t)-1)*(((((((int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int32_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 3 * PyLong_SHIFT) {
                            return (int32_t) ((((((((int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int32_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 4 * PyLong_SHIFT) {
                            return (int32_t) (((int32_t)-1)*(((((((((int32_t)digits[3]) << PyLong_SHIFT) | (int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int32_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 4 * PyLong_SHIFT) {
                            return (int32_t) ((((((((((int32_t)digits[3]) << PyLong_SHIFT) | (int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int32_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int32_t, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int32_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int32_t, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int32_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int32_t) -1;
        }
    } else {
        int32_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int32_t) -1;
        val = __Pyx_PyInt_As_int32_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int32_t");
    return (int32_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int32_t");
    return (int32_t) -1;
}

/* CIntFromPy */
              static CYTHON_INLINE int16_t __Pyx_PyInt_As_int16_t(PyObject *x) {
    const int16_t neg_one = (int16_t) -1, const_zero = (int16_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int16_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int16_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int16_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int16_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int16_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(int16_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int16_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int16_t) >= 2 * PyLong_SHIFT) {
                            return (int16_t) (((((int16_t)digits[1]) << PyLong_SHIFT) | (int16_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int16_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int16_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int16_t) >= 3 * PyLong_SHIFT) {
                            return (int16_t) (((((((int16_t)digits[2]) << PyLong_SHIFT) | (int16_t)digits[1]) << PyLong_SHIFT) | (int16_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int16_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int16_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int16_t) >= 4 * PyLong_SHIFT) {
                            return (int16_t) (((((((((int16_t)digits[3]) << PyLong_SHIFT) | (int16_t)digits[2]) << PyLong_SHIFT) | (int16_t)digits[1]) << PyLong_SHIFT) | (int16_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int16_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int16_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int16_t, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int16_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int16_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int16_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int16_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int16_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int16_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int16_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int16_t) - 1 > 2 * PyLong_SHIFT) {
                            return (int16_t) (((int16_t)-1)*(((((int16_t)digits[1]) << PyLong_SHIFT) | (int16_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int16_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int16_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int16_t) - 1 > 2 * PyLong_SHIFT) {
                            return (int16_t) ((((((int16_t)digits[1]) << PyLong_SHIFT) | (int16_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int16_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int16_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int16_t) - 1 > 3 * PyLong_SHIFT) {
                            return (int16_t) (((int16_t)-1)*(((((((int16_t)digits[2]) << PyLong_SHIFT) | (int16_t)digits[1]) << PyLong_SHIFT) | (int16_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int16_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int16_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int16_t) - 1 > 3 * PyLong_SHIFT) {
                            return (int16_t) ((((((((int16_t)digits[2]) << PyLong_SHIFT) | (int16_t)digits[1]) << PyLong_SHIFT) | (int16_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int16_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int16_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int16_t) - 1 > 4 * PyLong_SHIFT) {
                            return (int16_t) (((int16_t)-1)*(((((((((int16_t)digits[3]) << PyLong_SHIFT) | (int16_t)digits[2]) << PyLong_SHIFT) | (int16_t)digits[1]) << PyLong_SHIFT) | (int16_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int16_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int16_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int16_t) - 1 > 4 * PyLong_SHIFT) {
                            return (int16_t) ((((((((((int16_t)digits[3]) << PyLong_SHIFT) | (int16_t)digits[2]) << PyLong_SHIFT) | (int16_t)digits[1]) << PyLong_SHIFT) | (int16_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int16_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int16_t, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int16_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int16_t, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int16_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int16_t) -1;
        }
    } else {
        int16_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int16_t) -1;
        val = __Pyx_PyInt_As_int16_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int16_t");
    return (int16_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int16_t");
    return (int16_t) -1;
}

/* CIntFromPy */
              static CYTHON_INLINE enum OpenZWave::Driver::ControllerCommand __Pyx_PyInt_As_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerCommand(PyObject *x) {
    const enum OpenZWave::Driver::ControllerCommand neg_one = (enum OpenZWave::Driver::ControllerCommand) -1, const_zero = (enum OpenZWave::Driver::ControllerCommand) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum OpenZWave::Driver::ControllerCommand) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum OpenZWave::Driver::ControllerCommand, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum OpenZWave::Driver::ControllerCommand) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum OpenZWave::Driver::ControllerCommand) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum OpenZWave::Driver::ControllerCommand, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum OpenZWave::Driver::ControllerCommand, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) >= 2 * PyLong_SHIFT) {
                            return (enum OpenZWave::Driver::ControllerCommand) (((((enum OpenZWave::Driver::ControllerCommand)digits[1]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum OpenZWave::Driver::ControllerCommand, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) >= 3 * PyLong_SHIFT) {
                            return (enum OpenZWave::Driver::ControllerCommand) (((((((enum OpenZWave::Driver::ControllerCommand)digits[2]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[1]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum OpenZWave::Driver::ControllerCommand, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) >= 4 * PyLong_SHIFT) {
                            return (enum OpenZWave::Driver::ControllerCommand) (((((((((enum OpenZWave::Driver::ControllerCommand)digits[3]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[2]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[1]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum OpenZWave::Driver::ControllerCommand) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum OpenZWave::Driver::ControllerCommand) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum OpenZWave::Driver::ControllerCommand, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum OpenZWave::Driver::ControllerCommand) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum OpenZWave::Driver::ControllerCommand, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum OpenZWave::Driver::ControllerCommand) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum OpenZWave::Driver::ControllerCommand, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(enum OpenZWave::Driver::ControllerCommand,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum OpenZWave::Driver::ControllerCommand, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) - 1 > 2 * PyLong_SHIFT) {
                            return (enum OpenZWave::Driver::ControllerCommand) (((enum OpenZWave::Driver::ControllerCommand)-1)*(((((enum OpenZWave::Driver::ControllerCommand)digits[1]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum OpenZWave::Driver::ControllerCommand, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) - 1 > 2 * PyLong_SHIFT) {
                            return (enum OpenZWave::Driver::ControllerCommand) ((((((enum OpenZWave::Driver::ControllerCommand)digits[1]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum OpenZWave::Driver::ControllerCommand, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) - 1 > 3 * PyLong_SHIFT) {
                            return (enum OpenZWave::Driver::ControllerCommand) (((enum OpenZWave::Driver::ControllerCommand)-1)*(((((((enum OpenZWave::Driver::ControllerCommand)digits[2]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[1]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum OpenZWave::Driver::ControllerCommand, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) - 1 > 3 * PyLong_SHIFT) {
                            return (enum OpenZWave::Driver::ControllerCommand) ((((((((enum OpenZWave::Driver::ControllerCommand)digits[2]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[1]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum OpenZWave::Driver::ControllerCommand, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) - 1 > 4 * PyLong_SHIFT) {
                            return (enum OpenZWave::Driver::ControllerCommand) (((enum OpenZWave::Driver::ControllerCommand)-1)*(((((((((enum OpenZWave::Driver::ControllerCommand)digits[3]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[2]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[1]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum OpenZWave::Driver::ControllerCommand, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum OpenZWave::Driver::ControllerCommand) - 1 > 4 * PyLong_SHIFT) {
                            return (enum OpenZWave::Driver::ControllerCommand) ((((((((((enum OpenZWave::Driver::ControllerCommand)digits[3]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[2]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[1]) << PyLong_SHIFT) | (enum OpenZWave::Driver::ControllerCommand)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum OpenZWave::Driver::ControllerCommand) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum OpenZWave::Driver::ControllerCommand, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum OpenZWave::Driver::ControllerCommand) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum OpenZWave::Driver::ControllerCommand, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum OpenZWave::Driver::ControllerCommand val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum OpenZWave::Driver::ControllerCommand) -1;
        }
    } else {
        enum OpenZWave::Driver::ControllerCommand val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (enum OpenZWave::Driver::ControllerCommand) -1;
        val = __Pyx_PyInt_As_enum__OpenZWave_3a__3a_Driver_3a__3a_ControllerCommand(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum OpenZWave::Driver::ControllerCommand");
    return (enum OpenZWave::Driver::ControllerCommand) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum OpenZWave::Driver::ControllerCommand");
    return (enum OpenZWave::Driver::ControllerCommand) -1;
}

/* CIntFromPy */
              static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
    const int neg_one = (int) -1, const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

/* CheckBinaryVersion */
              static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

/* InitStrings */
              static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if CYTHON_COMPILING_IN_CPYTHON && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
#if PY_VERSION_HEX < 0x03030000
        char* defenc_c;
        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
        if (!defenc) return NULL;
        defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        {
            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
            char* c;
            for (c = defenc_c; c < end; c++) {
                if ((unsigned char) (*c) >= 128) {
                    PyUnicode_AsASCIIString(o);
                    return NULL;
                }
            }
        }
#endif
        *length = PyBytes_GET_SIZE(defenc);
        return defenc_c;
#else
        if (__Pyx_PyUnicode_READY(o) == -1) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        if (PyUnicode_IS_ASCII(o)) {
            *length = PyUnicode_GET_LENGTH(o);
            return PyUnicode_AsUTF8(o);
        } else {
            PyUnicode_AsASCIIString(o);
            return NULL;
        }
#else
        return PyUnicode_AsUTF8AndSize(o, length);
#endif
#endif
    } else
#endif
#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
#if CYTHON_USE_TYPE_SLOTS
  PyNumberMethods *m;
#endif
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return __Pyx_NewRef(x);
#if CYTHON_USE_TYPE_SLOTS
  m = Py_TYPE(x)->tp_as_number;
  #if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
  #else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
  #endif
#else
  res = PyNumber_Int(x);
#endif
  if (res) {
#if PY_MAJOR_VERSION < 3
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%.4s__ returned non-%.4s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b))) {
    if (sizeof(Py_ssize_t) >= sizeof(long))
        return PyInt_AS_LONG(b);
    else
        return PyInt_AsSsize_t(x);
  }
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_USE_PYLONG_INTERNALS
    const digit* digits = ((PyLongObject*)b)->ob_digit;
    const Py_ssize_t size = Py_SIZE(b);
    if (likely(__Pyx_sst_abs(size) <= 1)) {
        ival = likely(size) ? digits[0] : 0;
        if (size == -1) ival = -ival;
        return ival;
    } else {
      switch (size) {
         case 2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
      }
    }
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
